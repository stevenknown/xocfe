diff --git a/src/cfe.prj/xocfe.cpp b/src/cfe.prj/xocfe.cpp
index 389c838..53ebbe1 100644
--- a/src/cfe.prj/xocfe.cpp
+++ b/src/cfe.prj/xocfe.cpp
@@ -115,7 +115,7 @@ INT main(INT argc, CHAR * argv[])
 #endif
 	if (!process_cmd(argc, argv)) return 1;
 	init_parser();
-	g_fe_sym_tab = new SYM_TAB(64);
+	g_fe_sym_tab = new SymTab(64);
 	fe_process();
 
 	//Show you all info that generated by CfrontEnd.
diff --git a/src/cfe/cell.cpp b/src/cfe/cell.cpp
index 1946557..848982f 100644
--- a/src/cfe/cell.cpp
+++ b/src/cfe/cell.cpp
@@ -27,13 +27,13 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 @*/
 #include "cfecom.h"
 
-static LIST<CELL*> g_cell_free_list;
+static List<CELL*> g_cell_free_list;
 
 
 static void * xmalloc(size_t size)
 {
 	IS_TRUE0(g_pool_general_used != NULL);
-	void * p = smpool_malloc_h(size, g_pool_general_used);
+	void * p = smpoolMalloc(size, g_pool_general_used);
 	if (p == NULL) return NULL;
 	memset(p, 0, size);
 	return p;
diff --git a/src/cfe/cfexport.h b/src/cfe/cfexport.h
index 94319f0..85221f7 100644
--- a/src/cfe/cfexport.h
+++ b/src/cfe/cfexport.h
@@ -34,4 +34,4 @@ class TREE;
 //Frontend Exported Variable.
 extern CHAR * g_target_file_name;
 extern CHAR * g_source_file_name;
-extern SMEM_POOL * g_pool_tmp_used; //local temporary usage
\ No newline at end of file
+extern SMemPool * g_pool_tmp_used; //local temporary usage
\ No newline at end of file
diff --git a/src/cfe/decl.cpp b/src/cfe/decl.cpp
index 78d439c..1bbea25 100644
--- a/src/cfe/decl.cpp
+++ b/src/cfe/decl.cpp
@@ -121,7 +121,7 @@ CHAR * g_dcl_name [] = {
 
 static void * xmalloc(unsigned long size)
 {
-	void * p = smpool_malloc_h(size, g_pool_tree_used);
+	void * p = smpoolMalloc(size, g_pool_tree_used);
 	IS_TRUE0(p != NULL);
 	memset(p, 0, size);
 	return p;
@@ -2219,8 +2219,8 @@ TYPE * cp_spec(TYPE * ty)
 
 /*
 pointer:
-	'*' type-qualifier-list(opt)
-	'*' type-qualifier-list(opt) pointer
+	'*' type-qualifier-list(pass)
+	'*' type-qualifier-list(pass) pointer
 */
 static DECL * pointer(TYPE ** qua)
 {
@@ -2270,12 +2270,12 @@ static DECL * declarator(TYPE * qua)
 static INT label_ck(SCOPE *s)
 {
 	if (s == NULL) return ST_ERR;
-	LABEL_INFO * lref = SCOPE_ref_label_list(s).get_head();
-	LABEL_INFO * lj = NULL;
+	LabelInfo * lref = SCOPE_ref_label_list(s).get_head();
+	LabelInfo * lj = NULL;
 	while (lref != NULL) {
 		CHAR * name = SYM_name(LABEL_INFO_name(lref));
 		IS_TRUE0(name);
-		LABEL_INFO * li = SCOPE_label_list(s).get_head();
+		LabelInfo * li = SCOPE_label_list(s).get_head();
 		for (; li != NULL; li = SCOPE_label_list(s).get_next()) {
 			if (strcmp(SYM_name(LABEL_INFO_name(li)), name) == 0) {
 				LABEL_INFO_is_used(li) = true;
@@ -2357,7 +2357,7 @@ static void fix_para_array_index(DECL * decl)
 
 //Change array to pointer if it is formal parameter.
 //Fulfill the first dimension to at least 1 if it is a parameter.
-static TREE * refine_array(TREE * t)
+static TREE * refineArray(TREE * t)
 {
 	IS_TRUE0(TREE_type(t) == TR_ARRAY);
 
@@ -2398,9 +2398,9 @@ static TREE * refine_array(TREE * t)
 				//The base of pointer is an array. Convert a[] to (*a)[].
 				TREE * deref = new_tree_node(TR_DEREF, TREE_lineno(base));
 				TREE_lchild(deref) = base;
-				set_parent(deref, TREE_lchild(deref));
+				setParent(deref, TREE_lchild(deref));
 				TREE_array_base(t) = deref;
-				set_parent(t, TREE_array_base(t));
+				setParent(t, TREE_array_base(t));
 				fix_para_array_index(decl);
 			}
 		}
@@ -2418,7 +2418,7 @@ static TREE * refine_tree(TREE * t)
 {
 	if (t == NULL) return NULL;
 	if (TREE_type(t) == TR_ARRAY) {
-		t = refine_array(t);
+		t = refineArray(t);
 	} else if (TREE_type(t) == TR_SCOPE) {
 		SCOPE * s = TREE_scope(t);
 		SCOPE_stmt_list(s) = refine_tree_list(SCOPE_stmt_list(s));
@@ -2743,7 +2743,7 @@ bool is_user_type_exist(IN USER_TYPE_LIST * ut_list, IN CHAR * ut_name,
 }
 
 
-bool is_struct_type_exist(LIST<STRUCT*> & struct_list, 
+bool is_struct_type_exist(List<STRUCT*> & struct_list, 
 						  IN CHAR * tag, OUT STRUCT ** s)
 {
 	if (tag == NULL) { return false; }
@@ -2764,7 +2764,7 @@ bool is_struct_type_exist(LIST<STRUCT*> & struct_list,
 
 
 //Seach UNION list accroding to the 'tag' of union-type.
-bool is_union_type_exist(LIST<UNION*> & u_list, IN CHAR * tag, OUT UNION ** u)
+bool is_union_type_exist(List<UNION*> & u_list, IN CHAR * tag, OUT UNION ** u)
 {
 	if (tag == NULL) { return false; }
 
@@ -3588,7 +3588,7 @@ INT format_declaration(IN OUT CHAR buf[], IN DECL * decl)
 //Print indent blank.
 static void pd(INT indent)
 {
-	while (indent-- > 0) fprintf(g_tfile, " ");
+	while (indent-- > 0) { fprintf(g_tfile, " "); }
 }
 
 
@@ -4546,4 +4546,4 @@ bool declaration_list()
 		find |= declaration();
 	}
 	return find;
-}
+}
\ No newline at end of file
diff --git a/src/cfe/decl.h b/src/cfe/decl.h
index e9171ff..a8cf796 100644
--- a/src/cfe/decl.h
+++ b/src/cfe/decl.h
@@ -499,9 +499,9 @@ bool is_enum_const_exist_in_outer_scope(CHAR * name, OUT ENUM ** e,
 bool is_enum_const_exist_in_cur_scope(IN CHAR * cl, OUT ENUM ** e,
 									  OUT INT * idx);
 bool is_user_type_exist(USER_TYPE_LIST * ut_list, CHAR * ut_name, DECL ** ut);
-bool is_struct_type_exist(LIST<STRUCT*> & struct_list, IN CHAR * tag, 
+bool is_struct_type_exist(List<STRUCT*> & struct_list, IN CHAR * tag, 
 							OUT STRUCT ** s);
-bool is_union_type_exist(LIST<UNION*> & u_list, IN CHAR * tag, OUT UNION ** s);
+bool is_union_type_exist(List<UNION*> & u_list, IN CHAR * tag, OUT UNION ** s);
 bool is_union(TYPE * type);
 bool is_union(DECL * decl);
 bool is_struct(TYPE * type);
diff --git a/src/cfe/err.cpp b/src/cfe/err.cpp
index 4ea2ba9..7990e86 100644
--- a/src/cfe/err.cpp
+++ b/src/cfe/err.cpp
@@ -30,12 +30,12 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define ERR_BUF_LEN 1024
 #define WARN_BUF_LEN 1024
 
-LIST<ERR_MSG*> g_err_msg_list;
-LIST<WARN_MSG*> g_warn_msg_list;
+List<ERR_MSG*> g_err_msg_list;
+List<WARN_MSG*> g_warn_msg_list;
 
 static void * xmalloc(size_t size)
 {
-	void * p = smpool_malloc_h(size, g_pool_general_used);
+	void * p = smpoolMalloc(size, g_pool_general_used);
 	if (p == NULL) return NULL;
 	memset(p, 0, size);
 	return p;
diff --git a/src/cfe/err.h b/src/cfe/err.h
index 8049fd8..05668cb 100644
--- a/src/cfe/err.h
+++ b/src/cfe/err.h
@@ -54,8 +54,8 @@ public:
 
 
 //Exported Variables
-extern LIST<ERR_MSG*> g_err_msg_list;
-extern LIST<WARN_MSG*> g_warn_msg_list;
+extern List<ERR_MSG*> g_err_msg_list;
+extern List<WARN_MSG*> g_warn_msg_list;
 
 //Exported Functions
 void warn1(CHAR * msg, ...);
diff --git a/src/cfe/exectree.cpp b/src/cfe/exectree.cpp
index 62b85b3..fbb3002 100644
--- a/src/cfe/exectree.cpp
+++ b/src/cfe/exectree.cpp
@@ -34,7 +34,7 @@ Computing expected value in compiling period, such as constant expression.
 */
 
 static bool g_is_allow_float = false;
-static SSTACK<CELL*> g_cell_stack;
+static Stack<CELL*> g_cell_stack;
 static bool compute_conditional_exp(IN TREE * t);
 
 static CELL * pushv(LONGLONG v)
@@ -83,9 +83,9 @@ static bool compute_sizeof(TREE * t)
 		IS_TRUE0(dcl && DECL_dt(dcl) == DCL_TYPE_NAME);
 		IS_TRUE0(DECL_spec(dcl));
 
-		if (is_user_type_ref(dcl)) {
-			dcl = factor_user_type(dcl);
-			TREE_type_name(p) = dcl;
+		if (is_user_type_ref(dcl)) {
+			dcl = factor_user_type(dcl);
+			TREE_type_name(p) = dcl;
 		}
 
 		ULONG sz = get_decl_size(dcl);
diff --git a/src/cfe/lex.cpp b/src/cfe/lex.cpp
index a290bcc..6a0b2b0 100644
--- a/src/cfe/lex.cpp
+++ b/src/cfe/lex.cpp
@@ -185,7 +185,7 @@ TOKEN_INFO g_token_info[] =
 	{ T_STATIC,		"static" },
 	{ T_TYPEDEF,	"typedef" },
 
-	//qualifiers-opt
+	//qualifiers-pass
 	{ T_CONST,		"const" },
 	{ T_VOLATILE,	"volatile" },
 	{ T_RESTRICT,	"restrict" },
@@ -242,7 +242,7 @@ static KEYWORD_INFO g_keyword_info[] = {
 	{ T_STATIC,		"static" },
 	{ T_TYPEDEF,	"typedef" },
 
-	//qualifiers-opt
+	//qualifiers-pass
 	{ T_CONST,		"const" },
 	{ T_VOLATILE,	"volatile" },
 	{ T_RESTRICT,	"restrict" },
@@ -409,9 +409,9 @@ FEOF:
 }
 
 
-class STR2TOKEN : public HMAP<CHAR const*, TOKEN, HASH_FUNC_STR2> {
+class STR2TOKEN : public HMap<CHAR const*, TOKEN, HashFuncString2> {
 public:
-	STR2TOKEN(UINT bsize) : HMAP<CHAR const*, TOKEN, HASH_FUNC_STR2>(bsize) {}
+	STR2TOKEN(UINT bsize) : HMap<CHAR const*, TOKEN, HashFuncString2>(bsize) {}
 	virtual ~STR2TOKEN() {}
 };
 
@@ -419,7 +419,7 @@ STR2TOKEN g_str2token(0);
 
 void init_key_word_tab()
 {
-	g_str2token.init(64); //Must be power of 2 since we use HASH_FUNC_STR2.
+	g_str2token.init(64); //Must be power of 2 since we use HashFuncString2.
 	for (UINT i = 0; i < g_keyword_num; i++) {
 		g_str2token.set(KEYWORD_INFO_name(&g_keyword_info[i]),
 						KEYWORD_INFO_token(&g_keyword_info[i]));
@@ -908,11 +908,11 @@ TOKEN get_token()
 		}
 		break;
 	case '\t':
-		while ((g_cur_char = get_next_char()) == '\t');
+		while ((g_cur_char = get_next_char()) == '\t') { }
 		token = get_token();
 		break;
 	case ' ':
-		while((g_cur_char = get_next_char())==' ');
+		while((g_cur_char = get_next_char())==' ') { }
 		token = get_token();
 		break;
 	case '@':
diff --git a/src/cfe/lex.h b/src/cfe/lex.h
index f4209e9..89a679a 100644
--- a/src/cfe/lex.h
+++ b/src/cfe/lex.h
@@ -138,7 +138,7 @@ typedef enum _TOKEN {
 	T_STATIC,
 	T_TYPEDEF,
 
-	//qualifiers-opt
+	//qualifiers-pass
 	T_CONST,
 	T_VOLATILE,
 	T_RESTRICT,
diff --git a/src/cfe/scope.cpp b/src/cfe/scope.cpp
index ca4755e..1e118ec 100644
--- a/src/cfe/scope.cpp
+++ b/src/cfe/scope.cpp
@@ -32,13 +32,13 @@ The outermost scope is global region which id is 0, and the inner
 scope scope is function body-stmt which id is 1, etc.
 */
 SCOPE * g_cur_scope = NULL;
-LIST<SCOPE*> g_scope_list;
+List<SCOPE*> g_scope_list;
 UINT g_scope_count = 0;
 LAB2LINE_MAP g_lab2lineno;
 
 static void * xmalloc(size_t size)
 {
-	void * p = smpool_malloc_h(size, g_pool_general_used);
+	void * p = smpoolMalloc(size, g_pool_general_used);
 	IS_TRUE0(p);
 	memset(p, 0, size);
 	return p;
@@ -150,7 +150,7 @@ void dump_scope_tree(SCOPE * s, INT indent)
 	if (s == NULL) return;
 	fprintf(g_tfile, "\n");
 	INT i = indent;
-	while (i-- > 0) fprintf(g_tfile, "    ");
+	while (i-- > 0) { fprintf(g_tfile, "    "); }
 	fprintf(g_tfile, "SCOPE(%d),level(%d)", SCOPE_id(s), SCOPE_level(s));
 	fflush(g_tfile);
 	dump_scope_tree(SCOPE_sub(s), indent+1);
@@ -181,7 +181,7 @@ void dump_scope(SCOPE * s, UINT flag)
 	}
 
 	//all of defined customer label in code
-	LABEL_INFO * li = SCOPE_label_list(s).get_head();
+	LabelInfo * li = SCOPE_label_list(s).get_head();
 	if (li != NULL) {
 		note("\nDEFINED LABEL:");
 		g_indent++;
@@ -212,7 +212,7 @@ void dump_scope(SCOPE * s, UINT flag)
 	//enums
 	ENUM_LIST * el = SCOPE_enum_list(s);
 	if (el != NULL) {
-		note("\nENUM LIST:");
+		note("\nENUM List:");
 		g_indent++;
 		note("\n");
 		while (el != NULL) {
@@ -330,13 +330,13 @@ void destroy_scope_list()
 }
 
 
-UINT map_lab2lineno(LABEL_INFO * li)
+UINT map_lab2lineno(LabelInfo * li)
 {
 	return g_lab2lineno.get(li);
 }
 
 
-void set_map_lab2lineno(LABEL_INFO * li, UINT lineno)
+void set_map_lab2lineno(LabelInfo * li, UINT lineno)
 {
 	g_lab2lineno.set(li, lineno);
 }
diff --git a/src/cfe/scope.h b/src/cfe/scope.h
index d40d106..4417e06 100644
--- a/src/cfe/scope.h
+++ b/src/cfe/scope.h
@@ -88,11 +88,11 @@ public:
 	ENUM_LIST * enum_list;		//enum-type list
 	USER_TYPE_LIST * utl_list;	//record type defined with 'typedef'
 
-	LIST<LABEL_INFO*> li_list;	//label definition
-	LIST<LABEL_INFO*> lref_list;//reference label
+	List<LabelInfo*> li_list;	//label definition
+	List<LabelInfo*> lref_list;//reference label
 
-	LIST<STRUCT*> struct_list;	//structure list of current scope
-	LIST<UNION*> union_list;	//union list of current scope
+	List<STRUCT*> struct_list;	//structure list of current scope
+	List<UNION*> union_list;	//union list of current scope
 
 	DECL * decl_list;			//record identifier declaration info
 	SYM_LIST * sym_tab_list;	//record identifier name
@@ -123,18 +123,18 @@ public:
 };
 
 
-typedef TMAP<LABEL_INFO*, UINT> LAB2LINE_MAP;
+typedef TMap<LabelInfo*, UINT> LAB2LINE_MAP;
 
 
 class Compare_Lab {
 public:
-	bool is_less(LABEL_INFO * t1, LABEL_INFO * t2) const
-	{ return lab_hash_value(t1) < lab_hash_value(t2); }
+	bool is_less(LabelInfo * t1, LabelInfo * t2) const
+	{ return computeLabelHashValue(t1) < computeLabelHashValue(t2); }
 
-	bool is_equ(LABEL_INFO * t1, LABEL_INFO * t2) const
-	{ return is_same_label(t1, t2); }
+	bool is_equ(LabelInfo * t1, LabelInfo * t2) const
+	{ return isSameLabel(t1, t2); }
 };
-typedef TTAB<LABEL_INFO*, Compare_Lab> LABTAB;
+typedef TTab<LabelInfo*, Compare_Lab> LABTAB;
 
 
 //Exported functions
@@ -149,8 +149,8 @@ SCOPE * get_global_scope();
 void dump_scope(SCOPE * s, UINT flag);
 void dump_scope_tree(SCOPE * s, INT indent);
 void destroy_scope_list();
-UINT map_lab2lineno(LABEL_INFO * li);
-void set_map_lab2lineno(LABEL_INFO * li, UINT lineno);
+UINT map_lab2lineno(LabelInfo * li);
+void set_map_lab2lineno(LabelInfo * li, UINT lineno);
 
 
 //Export Variables
diff --git a/src/cfe/st.cpp b/src/cfe/st.cpp
index b29a8b3..efaf94f 100644
--- a/src/cfe/st.cpp
+++ b/src/cfe/st.cpp
@@ -27,7 +27,7 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 @*/
 #include "cfecom.h"
 
-static SSTACK<CELL*> g_cell_stack;
+static Stack<CELL*> g_cell_stack;
 ST_INFO g_st_info[]={
 	st_NULL,				"NULL" ,
 
@@ -132,7 +132,7 @@ ST_INFO g_st_info[]={
 	st_STATIC,              "static",
 	st_TYPEDEF,             "typedef",
 
-	//qualifiers-opt
+	//qualifiers-pass
 	st_CONST,               "const",
 	st_VOLATILE,            "volatile",
 
diff --git a/src/cfe/st.h b/src/cfe/st.h
index 2640178..596798f 100644
--- a/src/cfe/st.h
+++ b/src/cfe/st.h
@@ -137,7 +137,7 @@ typedef enum {
 	st_STATIC,
 	st_TYPEDEF,
 
-	//qualifiers-opt
+	//qualifiers-pass
 	st_CONST,
 	st_VOLATILE,
 
@@ -157,20 +157,20 @@ typedef enum {
 		//declaration
 
 	st_function_definition,
-		//declaration_specifiers(opt) declarator declaration_list(opt)
-		//{ declaration-list(opt) statement-list(opt) }
+		//declaration_specifiers(pass) declarator declaration_list(pass)
+		//{ declaration-list(pass) statement-list(pass) }
 
 	st_declaration,
-		//declaration_specifiers init_declarator_list(opt);
+		//declaration_specifiers init_declarator_list(pass);
 
 	st_declaration_list,
 		//declaration
 		//declaration_list declaration
 
 	st_declaration_specifiers,
-		//storage_class_specifier declaration_specifiers(opt)
-		//type_specifier declaration_specifiers(opt)
-		//type_qualifier declaration_specifiers(opt)
+		//storage_class_specifier declaration_specifiers(pass)
+		//type_specifier declaration_specifiers(pass)
+		//type_qualifier declaration_specifiers(pass)
 
 	st_storage_class_specifier,
 		//one of auto  register  static  extern  typedef
@@ -185,7 +185,7 @@ typedef enum {
 		//const  volatile
 
 	st_struct_or_union_specifier,
-		//struct_or_union identifier(opt)  {struct_declaration_list}
+		//struct_or_union identifier(pass)  {struct_declaration_list}
 		//struct_or_union identifier
 
 	st_struct_or_union,
@@ -208,8 +208,8 @@ typedef enum {
 		//specifier_qualifier_list struct_declarator_list;
 
 	st_specifier_qualifier_list,
-		//type_specifier specifier_qualifier_list(opt)
-		//type_qualifier specifier_qualifier_list(opt)
+		//type_specifier specifier_qualifier_list(pass)
+		//type_qualifier specifier_qualifier_list(pass)
 
 	st_struct_declarator_list,
 		//struct_declarator
@@ -217,10 +217,10 @@ typedef enum {
 
 	st_struct_declarator,
 		//declarator
-		//declarator(opt) , constant_expression
+		//declarator(pass) , constant_expression
 
 	st_enum_specifier,
-		//enum identifier(opt) { enumerator_list }
+		//enum identifier(pass) { enumerator_list }
 		//enum identifier
 
 	st_enumerator_list,
@@ -232,18 +232,18 @@ typedef enum {
 		//identifier = constant_expression
 
 	st_declarator,
-		//pointer(opt) direct_declarator
+		//pointer(pass) direct_declarator
 
 	st_direct_declarator,
 		//identifier
 		//(declarator)
-		//direct_declarator [ constant_expression(opt) ]
+		//direct_declarator [ constant_expression(pass) ]
 		//direct_declarator ( parameter_type_list )
-		//direct_declarator ( identifier_list(opt) )
+		//direct_declarator ( identifier_list(pass) )
 
 	st_pointer,
-		//* type_qualifier_list(opt)
-		//* type_qualifier_list(opt) pointer
+		//* type_qualifier_list(pass)
+		//* type_qualifier_list(pass) pointer
 
 	st_type_qualifier_list,
 		//type_qualifier
@@ -259,7 +259,7 @@ typedef enum {
 
 	st_parameter_declaration,
 		//declaration_specifiers declarator
-		//declaration_specifiers abstract_declarator(opt)
+		//declaration_specifiers abstract_declarator(pass)
 
 	st_identifier_list,
 		//identifier
@@ -275,16 +275,16 @@ typedef enum {
 		//initializer_list , initializer
 
 	st_type_name,
-		//specifier_qualifier_list abstract_declarator(opt)
+		//specifier_qualifier_list abstract_declarator(pass)
 
 	st_abstract_declarator,
 		//pointer
-		//pointer(opt) direct_abstract_declarator
+		//pointer(pass) direct_abstract_declarator
 
 	st_direct_abstract_declarator,
 		//( abstract_declarator )
-		//direct_abstract_declarator(opt) [ constant_expression(opt) ]
-		//direct_abstract_declarator(opt) ( parameter_type_list(opt) )
+		//direct_abstract_declarator(pass) [ constant_expression(pass) ]
+		//direct_abstract_declarator(pass) ( parameter_type_list(pass) )
 
 	st_typedef_name,
 		//identifier
@@ -303,10 +303,10 @@ typedef enum {
 		//default , statement
 
 	st_expression_statement,
-		//expression(opt);
+		//expression(pass);
 
 	st_compound_statement,
-		//{ declaration_list(opt) statement_list(opt) }
+		//{ declaration_list(pass) statement_list(pass) }
 
 	st_statement_list,
 		//statement
@@ -320,13 +320,13 @@ typedef enum {
 	st_iteration_statement,
 		//while ( expression ) statement
 		//do statement while ( expression ) ;
-		//for ( expression(opt) ; expression(opt) ; expression(opt) ) statement
+		//for ( expression(pass) ; expression(pass) ; expression(pass) ) statement
 
 	st_jump_statement,
 		//goto identifier;
 		//continue;
 		//break;
-		//return expression(opt);
+		//return expression(pass);
 
 	st_expression,
 		//assignment_expression
@@ -413,7 +413,7 @@ typedef enum {
 
 	st_postfix_expression,
 		//postfix_expression [ expression ]
-		//postfix_expression ( argument_expression_list(opt) )
+		//postfix_expression ( argument_expression_list(pass) )
 		//postfix_expression . identifier
 		//postfix_expression -> identifier
 		//postfix_expression ++
diff --git a/src/cfe/tree.cpp b/src/cfe/tree.cpp
index 6dd223c..462f63b 100644
--- a/src/cfe/tree.cpp
+++ b/src/cfe/tree.cpp
@@ -34,7 +34,7 @@ static UINT g_tree_count = 1;
 
 static void * xmalloc(size_t size)
 {
-	void * p = smpool_malloc_h(size, g_pool_tree_used);
+	void * p = smpoolMalloc(size, g_pool_tree_used);
 	if (p == NULL) return 0;
 	memset(p,0,size);
 	return p;
diff --git a/src/cfe/tree.h b/src/cfe/tree.h
index adf8335..f7fddb7 100644
--- a/src/cfe/tree.h
+++ b/src/cfe/tree.h
@@ -248,13 +248,13 @@ public:
 			INT indx;
 		} u11; //record a enum constant
 		struct {
-			SYM * id; //record a id in SYM_TAB
+			SYM * id; //record a id in SymTab
 			DECL * id_decl; //record a legal declaration
 		} u12;
-		SYM * sval; //record a string in SYM_TAB
-		SYM * lab_name; //record a label name in SYM_TAB
+		SYM * sval; //record a string in SymTab
+		SYM * lab_name; //record a label name in SymTab
 		HOST_INT ival; //record a integer value
-		LABEL_INFO * lab_info; //record a label info defined in function level
+		LabelInfo * lab_info; //record a label info defined in function level
 		INT  case_value; //record a constant value of jump-case table
 		//TYPE * ty; //C standard type description
 		//USER_TYPE * uty; //user type description
diff --git a/src/cfe/treegen.cpp b/src/cfe/treegen.cpp
index e7d87d2..87578f1 100644
--- a/src/cfe/treegen.cpp
+++ b/src/cfe/treegen.cpp
@@ -38,34 +38,110 @@ static TREE * cast_exp();
 static TREE * unary_exp();
 static TREE * exp_stmt();
 static TREE * postfix_exp();
-static bool verify(TREE * t);
 
-SMEM_POOL * g_pool_general_used = NULL;
-SMEM_POOL * g_pool_st_used = NULL;
-SMEM_POOL * g_pool_tree_used = NULL;
-SYM_TAB * g_fe_sym_tab = NULL;
+SMemPool * g_pool_general_used = NULL;
+SMemPool * g_pool_st_used = NULL;
+SMemPool * g_pool_tree_used = NULL;
+SymTab * g_fe_sym_tab = NULL;
 bool g_dump_token = false;
 CHAR * g_real_token_string = NULL;
 TOKEN g_real_token = T_NUL;
-static LIST<CELL*> g_cell_list;
+static List<CELL*> g_cell_list;
 bool g_enable_C99_declaration = true;
 
 static void * xmalloc(size_t size)
 {
-	void * p = smpool_malloc_h(size, g_pool_tree_used);
+	void * p = smpoolMalloc(size, g_pool_tree_used);
 	IS_TRUE0(p);
 	memset(p, 0, size);
 	return p;
 }
 
 
+#ifdef _DEBUG_
+//Verify the TREE node legality.
+static bool verify(TREE * t)
+{
+	if (t == NULL)
+		return true;
+
+	switch (TREE_type(t)) {
+	case TR_SCOPE:
+	case TR_CALL:
+	case TR_ARRAY:
+	case TR_TYPE_NAME:
+	case TR_CVT:
+	case TR_COND:
+	case TR_LABEL:
+		break;
+	default:
+		IS_TRUE0(TREE_token(t) != T_NUL && get_token_name(TREE_token(t)));
+	}
+
+	switch (TREE_type(t)) {
+	case TR_ASSIGN:
+	case TR_ID:
+	case TR_IMM:
+	case TR_IMML:
+	case TR_FP:  //3.1415926
+	case TR_ENUM_CONST:
+	case TR_STRING:
+	case TR_LOGIC_OR: //logical or        ||
+	case TR_LOGIC_AND: //logical and      &&
+	case TR_INCLUSIVE_OR: //inclusive or  |
+	case TR_INCLUSIVE_AND: //inclusive and &
+	case TR_XOR: //exclusive or
+	case TR_EQUALITY: // == !=
+	case TR_RELATION: // < > >= <=
+	case TR_SHIFT:   // >> <<
+	case TR_ADDITIVE: // '+' '-'
+	case TR_MULTI:    // '*' '/' '%'
+	case TR_SCOPE:
+	case TR_IF:
+	case TR_DO:
+	case TR_WHILE:
+	case TR_FOR:
+	case TR_SWITCH:
+	case TR_BREAK:
+	case TR_CONTINUE:
+	case TR_RETURN:
+	case TR_GOTO:
+	case TR_LABEL:
+	case TR_CASE:
+	case TR_DEFAULT:
+	case TR_COND: //formulized log_OR_exp?exp:cond_exp
+	case TR_CVT: //type convertion
+	case TR_LDA:   // &a get address of 'a'
+	case TR_DEREF: //*p  dereferencing the pointer 'p'
+	case TR_PLUS: // +123
+	case TR_MINUS:  // -123
+	case TR_REV:  // Reverse
+	case TR_NOT:  // get non-value
+	case TR_INC:   //++a
+	case TR_DEC:   //--a
+	case TR_POST_INC: //a++  / (*a)++
+	case TR_POST_DEC: //a--
+	case TR_DMEM:   //
+	case TR_INDMEM:
+	case TR_ARRAY:
+	case TR_CALL:
+	case TR_PRAGMA:
+	case TR_SIZEOF:
+		break;
+	default: IS_TRUE(0, ("unknown tree type:%d", TREE_type(t)));
+	} //end switch
+	return true;
+}
+#endif
+
+
 /* Return NULL indicate we haven't found it in 'l_list', and
 append 'label' to tail of the list as correct,
 otherwise return 'l'.
 Add a label into outmost scope of current function */
-static LABEL_INFO * add_label(CHAR * name, INT lineno)
+static LabelInfo * add_label(CHAR * name, INT lineno)
 {
-	LABEL_INFO * li;
+	LabelInfo * li;
 	SCOPE * sc = g_cur_scope;
 	while (sc && SCOPE_level(sc) != FUNCTION_SCOPE) {
 		sc = SCOPE_parent(sc);
@@ -82,8 +158,8 @@ static LABEL_INFO * add_label(CHAR * name, INT lineno)
 		}
 	}
 
-	//Allocate different LABEL_INFO for different lines.
-	li = new_clabel(g_fe_sym_tab->add(name), g_pool_general_used);
+	//Allocate different LabelInfo for different lines.
+	li = newCustomerLabel(g_fe_sym_tab->add(name), g_pool_general_used);
 	//li = g_labtab.append_and_retrieve(li);
 	set_map_lab2lineno(li, lineno);
 	SCOPE_label_list(sc).append_tail(li);
@@ -92,9 +168,9 @@ static LABEL_INFO * add_label(CHAR * name, INT lineno)
 
 
 //Record a label reference into outmost scope of current function.
-static LABEL_INFO * add_ref_label(CHAR * name, INT lineno)
+static LabelInfo * add_ref_label(CHAR * name, INT lineno)
 {
-	LABEL_INFO * li;
+	LabelInfo * li;
 	SCOPE * sc = g_cur_scope;
 	while (sc != NULL && SCOPE_level(sc) != FUNCTION_SCOPE) {
 		sc = SCOPE_parent(sc);
@@ -105,8 +181,8 @@ static LABEL_INFO * add_ref_label(CHAR * name, INT lineno)
 		return NULL;
 	}
 
-	//Allocate different LABEL_INFO for different lines.
-	li = new_clabel(g_fe_sym_tab->add(name), g_pool_general_used);
+	//Allocate different LabelInfo for different lines.
+	li = newCustomerLabel(g_fe_sym_tab->add(name), g_pool_general_used);
 	//li = g_labtab.append_and_retrieve(li);
 	LABEL_INFO_is_used(li) = true;
 	set_map_lab2lineno(li, lineno); //ONLY for debug-info or dumping
@@ -390,7 +466,7 @@ static inline INT is_assign_op(TOKEN tok)
 }
 
 
-void set_parent(TREE * parent, TREE * child)
+void setParent(TREE * parent, TREE * child)
 {
 	if (child == NULL) { return; }
 	while (child != NULL) {
@@ -759,8 +835,8 @@ AGAIN:
 				array_root = NEWT(TR_ARRAY);
 				TREE_array_base(array_root) = t;
 				TREE_array_indx(array_root) = exp();
-				set_parent(array_root, t);
-				set_parent(array_root, TREE_array_indx(array_root));
+				setParent(array_root, t);
+				setParent(array_root, TREE_array_indx(array_root));
 				if (TREE_array_indx(array_root) == NULL) {
 					err(g_real_line_num, "array index cannot be NULL");
 					return NULL;
@@ -790,8 +866,8 @@ AGAIN:
 				err(g_real_line_num, "miss ')'");
 				return t;
 			}
-			set_parent(tp, t);
-			set_parent(tp, TREE_para_list(tp));
+			setParent(tp, t);
+			setParent(tp, TREE_para_list(tp));
 			t = tp;
 		}
 		break;
@@ -813,8 +889,8 @@ AGAIN:
 			}
 			TREE_field(mem_ref) = id();
 			match(T_ID);
-			set_parent(mem_ref, t);
-			set_parent(mem_ref, TREE_field(mem_ref));
+			setParent(mem_ref, t);
+			setParent(mem_ref, TREE_field(mem_ref));
 			t = mem_ref;
 			if (g_real_token == T_LSPAREN ||
 				g_real_token == T_LPAREN ||
@@ -832,7 +908,7 @@ AGAIN:
 			TREE * tp = NEWT(TR_POST_INC);
 			TREE_token(tp) = g_real_token;
 			TREE_inc_exp(tp) = t;
-			set_parent(tp, t);
+			setParent(tp, t);
 			t = tp;
 			if (t == NULL) {
 				err(g_real_line_num, "unary expression is needed");
@@ -859,7 +935,7 @@ AGAIN:
 			TREE * tp = NEWT(TR_POST_DEC);
 			TREE_token(tp) = g_real_token;
 			TREE_dec_exp(tp) = t;
-			set_parent(tp, t);
+			setParent(tp, t);
 			t = tp;
 			if (t == NULL) {
 				err(g_real_line_num, "unary expression is needed");
@@ -1003,21 +1079,21 @@ static TREE * unary_exp()
 		TREE_token(t) = g_real_token;
 		match(T_ASTERISK);
 		TREE_lchild(t) = cast_exp();
-		set_parent(t, TREE_lchild(t));
+		setParent(t, TREE_lchild(t));
 		break;
 	case T_BITAND:
 		t = NEWT(TR_LDA);
 		TREE_token(t) = g_real_token;
 		match(T_BITAND);
 		TREE_lchild(t) = cast_exp();
-		set_parent(t, TREE_lchild(t));
+		setParent(t, TREE_lchild(t));
 		break;
 	case T_ADDADD:
 		t = NEWT(TR_INC);
 		TREE_token(t) = g_real_token;
 		match(T_ADDADD);
 		TREE_inc_exp(t) = unary_exp();
-		set_parent(t, TREE_inc_exp(t));
+		setParent(t, TREE_inc_exp(t));
 		if (TREE_inc_exp(t) == NULL) {
 			err(g_real_line_num, "unary expression is needed");
 			goto FAILED;
@@ -1028,7 +1104,7 @@ static TREE * unary_exp()
 		TREE_token(t) = g_real_token;
 		match(T_SUBSUB);
 		TREE_dec_exp(t) = unary_exp();
-		set_parent(t,TREE_dec_exp(t));
+		setParent(t,TREE_dec_exp(t));
 		if (TREE_inc_exp(t) == NULL) {
 			err(g_real_line_num, "unary expression is needed");
 			goto FAILED;
@@ -1039,7 +1115,7 @@ static TREE * unary_exp()
 		TREE_token(t) = g_real_token;
 		match(T_ADD);
 		TREE_lchild(t) = cast_exp();
-		set_parent(t,TREE_lchild(t));
+		setParent(t,TREE_lchild(t));
 		if (TREE_lchild(t) == NULL) {
 			err(g_real_line_num, "cast expression is needed");
 			goto FAILED;
@@ -1050,7 +1126,7 @@ static TREE * unary_exp()
 		TREE_token(t) = g_real_token;
 		match(T_SUB);
 		TREE_lchild(t) = cast_exp();
-		set_parent(t,TREE_lchild(t));
+		setParent(t,TREE_lchild(t));
 		if (TREE_lchild(t) == NULL) {
 			err(g_real_line_num, "cast expression is needed");
 			goto FAILED;
@@ -1061,14 +1137,14 @@ static TREE * unary_exp()
 		TREE_token(t) = g_real_token;
 		match(T_SIZEOF);
 		TREE_sizeof_exp(t) = unary_or_LP_typename_RP();
-		set_parent(t, TREE_sizeof_exp(t));
+		setParent(t, TREE_sizeof_exp(t));
 		break;
 	case T_REV:
 		t = NEWT(TR_REV);
 		TREE_token(t) = g_real_token;
 		match(T_REV);
 		TREE_lchild(t) = cast_exp();
-		set_parent(t, TREE_lchild(t));
+		setParent(t, TREE_lchild(t));
 		if (TREE_lchild(t) == NULL) {
 			err(g_real_line_num, "cast expression is needed");
 			goto FAILED;
@@ -1079,7 +1155,7 @@ static TREE * unary_exp()
 		TREE_token(t) = g_real_token;
 		match(T_NOT);
 		TREE_lchild(t) = cast_exp();
-		set_parent(t,TREE_lchild(t));
+		setParent(t,TREE_lchild(t));
 		if (TREE_lchild(t) == NULL) {
 			err(g_real_line_num, "cast expression is needed");
 			goto FAILED;
@@ -1125,8 +1201,8 @@ static TREE * cast_exp()
 		t = NEWT(TR_CVT);
 		TREE_cvt_type(t) = p;
 		TREE_cast_exp(t) = cast_exp();
-		set_parent(t, TREE_cvt_type(t));
-		set_parent(t, TREE_cast_exp(t));
+		setParent(t, TREE_cvt_type(t));
+		setParent(t, TREE_cast_exp(t));
 		if (TREE_cast_exp(t) == NULL) {
 			err(g_real_line_num, "cast expression cannot be NULL");
 			goto FAILED;
@@ -1151,7 +1227,7 @@ static TREE * multiplicative_exp()
 		p = NEWT(TR_MULTI);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p,TREE_lchild(p));
+		setParent(p,TREE_lchild(p));
 			/*
 		     a*b*c  =>
 			             *
@@ -1162,7 +1238,7 @@ static TREE * multiplicative_exp()
 			*/
 		match(g_real_token);
 		TREE_rchild(p) = cast_exp();
-		set_parent(p,TREE_rchild(p));
+		setParent(p,TREE_rchild(p));
 		if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1185,7 +1261,7 @@ static TREE * additive_exp()
 		p = NEWT(TR_ADDITIVE);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p, TREE_lchild(p));
+		setParent(p, TREE_lchild(p));
 		   /*
 		     a+b-c  =>
 			             -
@@ -1196,7 +1272,7 @@ static TREE * additive_exp()
 		   */
 		match(g_real_token);
 		TREE_rchild(p) = multiplicative_exp();
-		set_parent(p, TREE_rchild(p));
+		setParent(p, TREE_rchild(p));
         if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1219,7 +1295,7 @@ static TREE * shift_exp()
 		p = NEWT(TR_SHIFT);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p,TREE_lchild(p));
+		setParent(p,TREE_lchild(p));
 		   /*
 		     a<<b<<c  =>
 			             <<
@@ -1230,7 +1306,7 @@ static TREE * shift_exp()
 		   */
 		match(g_real_token);
 		TREE_rchild(p) = additive_exp();
-		set_parent(p,TREE_rchild(p));
+		setParent(p,TREE_rchild(p));
         if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1254,7 +1330,7 @@ static TREE * relational_exp()
 		p = NEWT(TR_RELATION);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p,TREE_lchild(p));
+		setParent(p,TREE_lchild(p));
 		   /*
 		     a<b<c   =>
 			             <
@@ -1265,7 +1341,7 @@ static TREE * relational_exp()
 		   */
 		match(g_real_token);
 		TREE_rchild(p) = shift_exp();
-		set_parent(p,TREE_rchild(p));
+		setParent(p,TREE_rchild(p));
         if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1288,7 +1364,7 @@ static TREE * equality_exp()
 		p = NEWT(TR_EQUALITY);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p, TREE_lchild(p));
+		setParent(p, TREE_lchild(p));
 		   /*
 		     a==b!=c   =>
 			             !=
@@ -1299,7 +1375,7 @@ static TREE * equality_exp()
 		   */
 		match(g_real_token);
 		TREE_rchild(p) = relational_exp();
-		set_parent(p, TREE_rchild(p));
+		setParent(p, TREE_rchild(p));
 		if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1322,7 +1398,7 @@ static TREE * AND_exp()
 		p = NEWT(TR_INCLUSIVE_AND);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p, TREE_lchild(p));
+		setParent(p, TREE_lchild(p));
 		   /*
 		     a&b&c   =>  &
 			            / \
@@ -1332,7 +1408,7 @@ static TREE * AND_exp()
 		   */
 		match(T_BITAND);
 		TREE_rchild(p) = equality_exp();
-		set_parent(p,TREE_rchild(p));
+		setParent(p,TREE_rchild(p));
 		if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1355,7 +1431,7 @@ static TREE * exclusive_OR_exp()
 		p = NEWT(TR_XOR);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p,TREE_lchild(p));
+		setParent(p,TREE_lchild(p));
 		   /*
 		     a^b^c   =>  ^
 			            / \
@@ -1365,7 +1441,7 @@ static TREE * exclusive_OR_exp()
 		   */
 		match(T_XOR);
 		TREE_rchild(p) = AND_exp();
-		set_parent(p,TREE_rchild(p));
+		setParent(p,TREE_rchild(p));
 		if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1388,7 +1464,7 @@ static TREE * inclusive_OR_exp()
 		p = NEWT(TR_INCLUSIVE_OR);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p,TREE_lchild(p));
+		setParent(p,TREE_lchild(p));
 		   /*
 		     a|b|c   =>  |
 			            / \
@@ -1398,7 +1474,7 @@ static TREE * inclusive_OR_exp()
 		   */
 		match(T_BITOR);
 		TREE_rchild(p) = exclusive_OR_exp();
-		set_parent(p,TREE_rchild(p));
+		setParent(p,TREE_rchild(p));
 		if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1421,7 +1497,7 @@ static TREE * logical_AND_exp()
 		p = NEWT(TR_LOGIC_AND);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p,TREE_lchild(p));
+		setParent(p,TREE_lchild(p));
 		   /*
 		     a && b && c =>
 			               &&
@@ -1432,7 +1508,7 @@ static TREE * logical_AND_exp()
 		   */
 		match(T_AND);
 		TREE_rchild(p) = inclusive_OR_exp();
-		set_parent(p,TREE_rchild(p));
+		setParent(p,TREE_rchild(p));
 		if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1455,7 +1531,7 @@ static TREE * logical_OR_exp()
 		p = NEWT(TR_LOGIC_OR);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p,TREE_lchild(p));
+		setParent(p,TREE_lchild(p));
 		/*
 		  a||b||c  =>  ||
 		              /  \
@@ -1465,7 +1541,7 @@ static TREE * logical_OR_exp()
 		*/
 		match(T_OR);
 		TREE_rchild(p) = logical_AND_exp();
-		set_parent(p,TREE_rchild(p));
+		setParent(p,TREE_rchild(p));
     	if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "'%s': right operand cannot be NULL",
 				TOKEN_INFO_name(&g_token_info[TREE_token(p)]));
@@ -1488,17 +1564,17 @@ TREE * conditional_exp()
 		match(T_QUES_MARK);
 		TREE * p = NEWT(TR_COND);
 		TREE_det(p) = t;
-		set_parent(p,t);
+		setParent(p,t);
 		t = p;
 
 		TREE_true_part(t) = exp_list();
-		set_parent(t,TREE_true_part(t));
+		setParent(t,TREE_true_part(t));
 		if (match(T_COLON) != ST_SUCC) {
 			err(g_real_line_num, "condition expression is incomplete");
 			goto FAILED;
 		}
 		TREE_false_part(t) = exp_list();
-		set_parent(t,TREE_false_part(t));
+		setParent(t,TREE_false_part(t));
 	}
 	return t ;
 FAILED:
@@ -1515,14 +1591,14 @@ TREE * exp()
 		p = NEWT(TR_ASSIGN);
 		TREE_token(p) = g_real_token;
 		TREE_lchild(p) = t;
-		set_parent(p, TREE_lchild(p));
+		setParent(p, TREE_lchild(p));
         match(g_real_token);
 		TREE_rchild(p) = exp();
 		if (TREE_rchild(p) == NULL) {
 			err(g_real_line_num, "expression miss r-value");
 			goto FAILED;
 		}
-		set_parent(p, TREE_rchild(p));
+		setParent(p, TREE_rchild(p));
   		t = p ;
 	}
 	return t;
@@ -1595,7 +1671,7 @@ static TREE * jump_stmt()
 		match(T_RETURN);
 		if (g_real_token != T_SEMI) {
 			TREE_ret_exp(t) = exp_list();
-			set_parent(t,TREE_ret_exp(t));
+			setParent(t,TREE_ret_exp(t));
 		}
 		if (match(T_SEMI) != ST_SUCC) {
 			err(g_real_line_num, "miss ';'");
@@ -1758,7 +1834,7 @@ static TREE * do_while_stmt()
 	//do-body
 	pushst(st_DO, 0); //push down inherit properties
 	TREE_dowhile_body(t) = statement();
-	set_parent(t, TREE_dowhile_body(t));
+	setParent(t, TREE_dowhile_body(t));
 	popst();
 
 	if (match(T_WHILE) != ST_SUCC) { //while
@@ -1773,7 +1849,7 @@ static TREE * do_while_stmt()
 	}
 
 	TREE_dowhile_det(t) = exp_list();
-	set_parent(t, TREE_dowhile_det(t));
+	setParent(t, TREE_dowhile_det(t));
 	if (TREE_dowhile_det(t) == NULL) {
 		err(g_real_line_num, "while determination cannot be NULL");
 		goto FAILED;
@@ -1806,7 +1882,7 @@ static TREE * while_do_stmt()
 		goto FAILED;
 	}
 	TREE_whiledo_det(t) =  exp_list();
-	set_parent(t, TREE_whiledo_det(t));
+	setParent(t, TREE_whiledo_det(t));
 	if (TREE_whiledo_det(t) == NULL) {
 		err(g_real_line_num, "while determination cannot be NULL");
 		goto FAILED;
@@ -1819,7 +1895,7 @@ static TREE * while_do_stmt()
 	//while-body
 	pushst(st_WHILE,0); //push down inherit properties
     TREE_whiledo_body(t) = statement();
-	set_parent(t,TREE_whiledo_body(t));
+	setParent(t,TREE_whiledo_body(t));
 	popst();
 	return t;
 FAILED:
@@ -1847,7 +1923,7 @@ TREE * for_stmt()
 	if (!declaration_list()) {
 		//initializing expression
 		TREE_for_init(t) = exp_list();
-		set_parent(t, TREE_for_init(t));
+		setParent(t, TREE_for_init(t));
 
 		//EXPRESSION does not swallow the token ';'.
 		if (match(T_SEMI) != ST_SUCC) {
@@ -1857,7 +1933,7 @@ TREE * for_stmt()
 	}
 
 	TREE_for_det(t) = exp_list();
-	set_parent(t,TREE_for_det(t));
+	setParent(t,TREE_for_det(t));
 	//EXPRESSION does not swallow the token ';'.
 	if (match(T_SEMI) != ST_SUCC) {
 		err(g_real_line_num, "miss ';' before step expression");
@@ -1865,7 +1941,7 @@ TREE * for_stmt()
 	}
 
 	TREE_for_step(t) = exp_list();
-	set_parent(t, TREE_for_step(t));
+	setParent(t, TREE_for_step(t));
 	//EXPRESSION does not swallow the token ')'.
 	if (match(T_RPAREN) != ST_SUCC) {
 		err(g_real_line_num, "miss ')' after step expression");
@@ -1874,7 +1950,7 @@ TREE * for_stmt()
 
 	pushst(st_DO, 0); //push down inherit properties
 	TREE_for_body(t) = statement();
-	set_parent(t, TREE_for_body(t));
+	setParent(t, TREE_for_body(t));
 	popst();
 	if (g_enable_C99_declaration) {
 		return_to_parent_scope();
@@ -1925,7 +2001,7 @@ static TREE * if_stmt()
 	match(T_LPAREN);
 
 	TREE_if_det(t) = exp_list();
-	set_parent(t, TREE_if_det(t));
+	setParent(t, TREE_if_det(t));
 	if (TREE_if_det(t) == NULL) {
 		err(g_real_line_num, "'if' determination cannot be NULL");
 		goto FAILED;
@@ -1938,12 +2014,12 @@ static TREE * if_stmt()
 
     //true part
 	TREE_if_true_stmt(t) = statement();
-	set_parent(t,TREE_if_true_stmt(t));
+	setParent(t,TREE_if_true_stmt(t));
 
 	if (g_real_token == T_ELSE) {
 		match(T_ELSE);
 		TREE_if_false_stmt(t) = statement();
-		set_parent(t,TREE_if_false_stmt(t));
+		setParent(t,TREE_if_false_stmt(t));
 	}
 	return t;
 FAILED:
@@ -1965,7 +2041,7 @@ static TREE * switch_stmt()
 		goto FAILED;
 	}
 	TREE_switch_det(t) = exp_list();
-	set_parent(t, TREE_switch_det(t));
+	setParent(t, TREE_switch_det(t));
 	if (TREE_switch_det(t) == NULL) {
 		err(g_real_line_num, "switch determination cannot be NULL");
 		goto FAILED;
@@ -1977,7 +2053,7 @@ static TREE * switch_stmt()
 
 	pushst(st_DO,0); //push down inherit properties
 	TREE_switch_body(t) = statement();
-	set_parent(t,TREE_switch_body(t));
+	setParent(t,TREE_switch_body(t));
 	popst();
 	return t;
 FAILED:
@@ -2188,81 +2264,6 @@ static TREE * statement()
 }
 
 
-//Verify the TREE node legality.
-static bool verify(TREE * t)
-{
-	if (t == NULL)
-		return true;
-
-	switch (TREE_type(t)) {
-	case TR_SCOPE:
-	case TR_CALL:
-	case TR_ARRAY:
-	case TR_TYPE_NAME:
-	case TR_CVT:
-	case TR_COND:
-	case TR_LABEL:
-		break;
-	default:
-		IS_TRUE0(TREE_token(t) != T_NUL && get_token_name(TREE_token(t)));
-	}
-
-	switch (TREE_type(t)) {
-	case TR_ASSIGN:
-	case TR_ID:
-	case TR_IMM:
-	case TR_IMML:
-	case TR_FP:  //3.1415926
-	case TR_ENUM_CONST:
-	case TR_STRING:
-	case TR_LOGIC_OR: //logical or        ||
-	case TR_LOGIC_AND: //logical and      &&
-	case TR_INCLUSIVE_OR: //inclusive or  |
-	case TR_INCLUSIVE_AND: //inclusive and &
-	case TR_XOR: //exclusive or
-	case TR_EQUALITY: // == !=
-	case TR_RELATION: // < > >= <=
-	case TR_SHIFT:   // >> <<
-	case TR_ADDITIVE: // '+' '-'
-	case TR_MULTI:    // '*' '/' '%'
-	case TR_SCOPE:
-	case TR_IF:
-	case TR_DO:
-	case TR_WHILE:
-	case TR_FOR:
-	case TR_SWITCH:
-	case TR_BREAK:
-	case TR_CONTINUE:
-	case TR_RETURN:
-	case TR_GOTO:
-	case TR_LABEL:
-	case TR_CASE:
-	case TR_DEFAULT:
-	case TR_COND: //formulized log_OR_exp?exp:cond_exp
-	case TR_CVT: //type convertion
-	case TR_LDA:   // &a get address of 'a'
-	case TR_DEREF: //*p  dereferencing the pointer 'p'
-	case TR_PLUS: // +123
-	case TR_MINUS:  // -123
-	case TR_REV:  // Reverse
-	case TR_NOT:  // get non-value
-	case TR_INC:   //++a
-	case TR_DEC:   //--a
-	case TR_POST_INC: //a++  / (*a)++
-	case TR_POST_DEC: //a--
-	case TR_DMEM:   //
-	case TR_INDMEM:
-	case TR_ARRAY:
-	case TR_CALL:
-	case TR_PRAGMA:
-	case TR_SIZEOF:
-		break;
-	default: IS_TRUE(0, ("unknown tree type:%d", TREE_type(t)));
-	} //end switch
-	return true;
-}
-
-
 //Top level dispatch to parse DECLARATION or PLAUSE.
 static TREE * dispatch()
 {
@@ -2402,17 +2403,17 @@ static TREE * dispatch()
 void init_parser()
 {
 	init_key_word_tab();
-	g_pool_general_used = smpool_create_handle(256, MEM_COMM);
-	g_pool_tree_used = smpool_create_handle(128, MEM_COMM);
-	g_pool_st_used = smpool_create_handle(64, MEM_COMM);
+	g_pool_general_used = smpoolCreate(256, MEM_COMM);
+	g_pool_tree_used = smpoolCreate(128, MEM_COMM);
+	g_pool_st_used = smpoolCreate(64, MEM_COMM);
 }
 
 
 void fini_parser()
 {
-	smpool_free_handle(g_pool_general_used);
-	smpool_free_handle(g_pool_tree_used);
-	smpool_free_handle(g_pool_st_used);
+	smpoolDelete(g_pool_general_used);
+	smpoolDelete(g_pool_tree_used);
+	smpoolDelete(g_pool_st_used);
 	g_pool_general_used = NULL;
 	g_pool_tree_used = NULL;
 	g_pool_st_used = NULL;
diff --git a/src/cfe/treegen.h b/src/cfe/treegen.h
index 8740ac0..9091458 100644
--- a/src/cfe/treegen.h
+++ b/src/cfe/treegen.h
@@ -32,10 +32,10 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 extern CHAR * g_real_token_string;
 extern TOKEN g_real_token;
 extern bool g_enable_C99_declaration;
-extern SMEM_POOL * g_pool_general_used;
-extern SMEM_POOL * g_pool_tree_used; //front end
-extern SMEM_POOL * g_pool_st_used;
-extern SYM_TAB * g_fe_sym_tab;
+extern SMemPool * g_pool_general_used;
+extern SMemPool * g_pool_tree_used; //front end
+extern SMemPool * g_pool_st_used;
+extern SymTab * g_fe_sym_tab;
 extern bool g_dump_token;
 
 
@@ -61,7 +61,7 @@ bool look_forward_token(INT num, ...);
 
 INT match(TOKEN tok);
 
-void set_parent(TREE * parent, TREE * child);
+void setParent(TREE * parent, TREE * child);
 INT suck_tok();
 void suck_tok_to(INT placeholder, ...);
 #endif
diff --git a/src/cfe/typeck.cpp b/src/cfe/typeck.cpp
index 6638320..1a4ff61 100644
--- a/src/cfe/typeck.cpp
+++ b/src/cfe/typeck.cpp
@@ -457,7 +457,9 @@ static INT get_cvt_rank(INT des)
 		return 20;
 	} else if (IS_TYPED(des, T_SPEC_SHORT)) {
 		return 30;
-	} else if (IS_TYPED(des, T_SPEC_INT) || IS_TYPED(des, T_SPEC_ENUM)) {
+	} else if (IS_TYPED(des, T_SPEC_INT) || 
+			   IS_TYPED(des, T_SPEC_UNSIGNED) ||
+			   IS_TYPED(des, T_SPEC_ENUM)) {
 		return 40;
 	} else if (IS_TYPED(des, T_SPEC_LONG)) {
 		return 50;
@@ -490,9 +492,8 @@ static DECL * build_binary_op_type(DECL * l, DECL * r)
 	TYPE * rty = DECL_spec(r);
 	if (get_cvt_rank(TYPE_des(lty)) > get_cvt_rank(TYPE_des(rty))) {
 		return l;
-	} else {
-		return r;
 	}
+	return r;	
 }
 
 
@@ -1496,7 +1497,7 @@ static void type_trans_init()
 
 
 //DECL hash table
-class DECL_HASH : public SHASH<DECL*> {
+class DECL_HASH : public SHash<DECL*> {
 public:
    	UINT compute_hash_value(CHAR const* s) const
 	{
diff --git a/src/com/agraph.cpp b/src/com/agraph.cpp
index ae934bd..5df7fa6 100644
--- a/src/com/agraph.cpp
+++ b/src/com/agraph.cpp
@@ -35,11 +35,11 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "agraph.h"
 
 //Build matrix to describe edge-weight.
-void AGRAPH::build_adj_matrix(MATRIX<UINT> & adj_mat)
+void AGRAPH::build_adj_matrix(Matrix<UINT> & adj_mat)
 {
 	UNUSED(adj_mat);
 	IS_TRUE(0, ("Target Dependent Code"));
-	//Like: adj_mat.set(i, j, EDGE-WEIGHT);
+	//Like: adj_mat.set(i, j, Edge-WEIGHT);
 }
 
 
@@ -49,13 +49,13 @@ See <Shortest_Path-Dijkstra.txt>
 void AGRAPH::shortest_path(UINT infinite)
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
-	MATRIX<UINT> adj_mat;
+	Matrix<UINT> adj_mat;
 	build_adj_matrix(adj_mat);
 	UINT row = adj_mat.get_row_size();
 	UINT col = adj_mat.get_col_size();
 	UINT i,j,k,min,v1,v2;
 	if (m_spath_mat != NULL) { delete m_spath_mat; }
-	m_spath_mat = new MATRIX<UINT>(row, col);
+	m_spath_mat = new Matrix<UINT>(row, col);
 	m_spath_mat->set_all(infinite);
 
 	//Init path matrix
diff --git a/src/com/agraph.h b/src/com/agraph.h
index 98cbf6f..3c0c600 100644
--- a/src/com/agraph.h
+++ b/src/com/agraph.h
@@ -29,20 +29,20 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define __A_GRAPH_H_
 
 //Alogrithmic Graph.
-class AGRAPH : public GRAPH {
+class AGRAPH : public Graph {
 protected:
-	MATRIX<UINT> * m_spath_mat; //record shortest-path.
-	void build_adj_matrix(MATRIX<UINT> & adj_mat);
+	Matrix<UINT> * m_spath_mat; //record shortest-path.
+	void build_adj_matrix(Matrix<UINT> & adj_mat);
 public:
 	AGRAPH(UINT edge_hash_size = 64, UINT vex_hash_size = 64) :
-		GRAPH(edge_hash_size, vex_hash_size)
+		Graph(edge_hash_size, vex_hash_size)
 	{
 		m_edge_hash_size = edge_hash_size;
 		m_vex_hash_size = vex_hash_size;
 		m_spath_mat = NULL;
 	}
 
-	AGRAPH(AGRAPH & g) : GRAPH(g)
+	AGRAPH(AGRAPH & g) : Graph(g)
 	{
 		m_edge_hash_size = g.m_edge_hash_size;
 		m_vex_hash_size = g.m_vex_hash_size;
@@ -61,7 +61,7 @@ public:
 	{
 		if (src.m_spath_mat != NULL) {
 			if (m_spath_mat == NULL) {
-				m_spath_mat = new MATRIX<UINT>(*src.m_spath_mat);
+				m_spath_mat = new Matrix<UINT>(*src.m_spath_mat);
 			} else {
 				m_spath_mat->copy(*src.m_spath_mat);
 			}
@@ -73,7 +73,7 @@ public:
 
 	UINT count_mem() const
 	{
-		UINT count = GRAPH::count_mem();
+		UINT count = Graph::count_mem();
 		if (m_spath_mat != NULL) {
 			count += m_spath_mat->count_mem();
 		}
@@ -90,7 +90,7 @@ public:
 			delete m_spath_mat; //Delete shortest path matrix
 			m_spath_mat = NULL;
 		}
-		GRAPH::erase();
+		Graph::erase();
 	}
 };
 #endif
diff --git a/src/com/bs.cpp b/src/com/bs.cpp
index 89cc1ba..8aa6fc1 100644
--- a/src/com/bs.cpp
+++ b/src/com/bs.cpp
@@ -824,9 +824,9 @@ static BYTE const g_last_one[256] = {
 
 
 //
-//START BITSET
+//START BitSet
 //
-void * BITSET::realloc(IN void * src, size_t orgsize, size_t newsize)
+void * BitSet::realloc(IN void * src, size_t orgsize, size_t newsize)
 {
 	if (orgsize >= newsize) {
 		clean();
@@ -846,7 +846,7 @@ void * BITSET::realloc(IN void * src, size_t orgsize, size_t newsize)
 
 
 //Allocate bytes
-void BITSET::alloc(UINT size)
+void BitSet::alloc(UINT size)
 {
 	m_size = size;
 	if (m_ptr != NULL) { ::free(m_ptr);	}
@@ -861,7 +861,7 @@ void BITSET::alloc(UINT size)
 
 //Returns a new set which is the union of set1 and set2,
 //and modify set1 as result operand.
-void BITSET::bunion(BITSET const& bs)
+void BitSet::bunion(BitSet const& bs)
 {
 	IS_TRUE0(this != &bs);
 	if (bs.m_ptr == NULL) { return; }
@@ -890,7 +890,7 @@ void BITSET::bunion(BITSET const& bs)
 
 
 //Add a element which corresponding to 'elem' bit, and set this bit.
-void BITSET::bunion(UINT elem)
+void BitSet::bunion(UINT elem)
 {	
 	UINT const first_byte = DIVBPB(elem);
 	if (m_size < (first_byte+1)) {
@@ -905,7 +905,7 @@ void BITSET::bunion(UINT elem)
 /* The difference operation calculates the elements that
 distinguish one set from another.
 Remove a element which map with 'elem' bit, and clean this bit. */
-void BITSET::diff(UINT elem)
+void BitSet::diff(UINT elem)
 {
 	UINT first_byte = DIVBPB(elem);
 	if ((first_byte + 1) > m_size) {
@@ -922,7 +922,7 @@ distinguish one set from another.
 Subtracting set2 from set1
 Returns a new set which is
 	{ x : member( x, 'set1' ) & ~ member( x, 'set2' ) }. */
-void BITSET::diff(BITSET const& bs)
+void BitSet::diff(BitSet const& bs)
 {
 	IS_TRUE0(this != &bs);
 	if (m_size == 0 || bs.m_size == 0) { return; }
@@ -952,7 +952,7 @@ void BITSET::diff(BITSET const& bs)
 
 
 //Returns the a new set which is intersection of 'set1' and 'set2'.
-void BITSET::intersect(BITSET const& bs)
+void BitSet::intersect(BitSet const& bs)
 {
 	IS_TRUE0(this != &bs);
 	if (m_ptr == NULL) { return; }
@@ -972,7 +972,7 @@ void BITSET::intersect(BITSET const& bs)
 /* Reverse each bit.
 e.g: 1001 to 0110
 'last_bit_pos': start at 0, e.g:given '101', last bit pos is 2. */
-void BITSET::rev(UINT last_bit_pos)
+void BitSet::rev(UINT last_bit_pos)
 {
 	IS_TRUE(m_ptr != NULL, ("can not reverse empty set"));
 	UINT const last_byte_pos = last_bit_pos / BITS_PER_BYTE;
@@ -1000,9 +1000,9 @@ void BITSET::rev(UINT last_bit_pos)
 
 
 //Complement set of s = univers - s.
-void BITSET::complement(IN BITSET const& univers)
+void BitSet::complement(IN BitSet const& univers)
 {
-	BITSET tmp(univers);
+	BitSet tmp(univers);
 	tmp.diff(*this);
 	copy(tmp);
 }
@@ -1012,7 +1012,7 @@ void BITSET::complement(IN BITSET const& univers)
 Add up the population count of each byte in the set.  We get the
 population counts from the table above.  Great for a machine with
 effecient loadbyte instructions. */
-UINT BITSET::get_elem_count() const
+UINT BitSet::get_elem_count() const
 {
 	if (m_ptr == NULL) { return 0; }
 	UINT count = 0;
@@ -1038,7 +1038,7 @@ UINT BITSET::get_elem_count() const
 }
 
 
-bool BITSET::is_equal(BITSET const& bs) const
+bool BitSet::is_equal(BitSet const& bs) const
 {
 	IS_TRUE0(this != &bs);
 	UINT size1 = m_size , size2 = bs.m_size;
@@ -1093,7 +1093,7 @@ bool BITSET::is_equal(BITSET const& bs) const
 
 
 //Return true if this contain elem.
-bool BITSET::is_contain(UINT elem) const
+bool BitSet::is_contain(UINT elem) const
 {
 	if (m_ptr == NULL) { return false; }
 	if (elem >= (MULBPB(m_size))) {
@@ -1110,7 +1110,7 @@ bool BITSET::is_contain(UINT elem) const
 'strict': If it is false, we say the bitset contains bs;
 if it is true, the bitset must have at least one
 element that does not belong to 'bs'. */
-bool BITSET::is_contain(BITSET const& bs, bool strict) const
+bool BitSet::is_contain(BitSet const& bs, bool strict) const
 {
 	IS_TRUE0(this != &bs);
 	bool scon = false; //Set to true if 'this' strictly contained 'bs'.
@@ -1162,7 +1162,7 @@ bool BITSET::is_contain(BITSET const& bs, bool strict) const
 }
 
 
-bool BITSET::is_empty() const
+bool BitSet::is_empty() const
 {
 	if (m_ptr == NULL) { return true; }
 	UINT num_of_uint = m_size / BYTES_PER_UINT;
@@ -1181,7 +1181,7 @@ bool BITSET::is_empty() const
 }
 
 
-bool BITSET::is_intersect(BITSET const& bs) const
+bool BitSet::is_intersect(BitSet const& bs) const
 {
 	IS_TRUE0(this != &bs);
 	INT const first_bit = get_first();
@@ -1209,7 +1209,7 @@ bool BITSET::is_intersect(BITSET const& bs) const
 
 //Return true if 'this' contained in range between 'low' and 'high'.
 //'strict': 'this' strictly contained in range.
-bool BITSET::is_contained_in_range(UINT low, UINT high, bool strict) const
+bool BitSet::is_contained_in_range(UINT low, UINT high, bool strict) const
 {
 	IS_TRUE(low <= high, ("Invalid bit set"));
 	INT const set_low = get_first();
@@ -1236,7 +1236,7 @@ bool BITSET::is_contained_in_range(UINT low, UINT high, bool strict) const
 
 
 //Return true if 'this' contained range between 'low' and 'high'.
-bool BITSET::is_contain_range(UINT low, UINT high, bool strict) const
+bool BitSet::is_contain_range(UINT low, UINT high, bool strict) const
 {
 	IS_TRUE(low <= high, ("Invalid bit set"));
 	INT const set_low = get_first();
@@ -1265,7 +1265,7 @@ bool BITSET::is_contain_range(UINT low, UINT high, bool strict) const
 /* Return true if range between first_bit of 'this' and
 last_bit of 'this' overlapped with the range between
 'low' and 'high'. */
-bool BITSET::is_overlapped(UINT low, UINT high) const
+bool BitSet::is_overlapped(UINT low, UINT high) const
 {
 	IS_TRUE(low <= high, ("Invalid bit set"));
 	INT const set_low = get_first();
@@ -1315,7 +1315,7 @@ bool BITSET::is_overlapped(UINT low, UINT high) const
 
 //Return true if in the range between 'low' and 'high' has
 //any elements.
-bool BITSET::has_elem_in_range(UINT low, UINT high) const
+bool BitSet::has_elem_in_range(UINT low, UINT high) const
 {
 	IS_TRUE(low <= high, ("out of boundary"));
 	INT const first_bit = get_first();
@@ -1343,7 +1343,7 @@ bool BITSET::has_elem_in_range(UINT low, UINT high) const
 
 //Return position of first element, start from '0'.
 //Return -1 if the bitset is empty.
-INT BITSET::get_first() const
+INT BitSet::get_first() const
 {
 	if (m_size == 0) return -1;
 	UINT i = 0;
@@ -1372,7 +1372,7 @@ INT BITSET::get_first() const
 
 
 //Get bit postition of the last element.
-INT BITSET::get_last() const
+INT BitSet::get_last() const
 {
 	if (m_size == 0) return -1;
 	INT i = m_size - 1;
@@ -1405,8 +1405,8 @@ INT BITSET::get_last() const
 
 
 //Extract subset in range between 'low' and 'high'.
-BITSET * BITSET::get_subset_in_range(IN UINT low, IN UINT high,
-									 OUT BITSET & subset)
+BitSet * BitSet::get_subset_in_range(IN UINT low, IN UINT high,
+									 OUT BitSet & subset)
 {
 	IS_TRUE(low <= high, ("Invalid bit set"));
 	IS_TRUE(&subset != this, ("overlapped!"));
@@ -1537,7 +1537,7 @@ BITSET * BITSET::get_subset_in_range(IN UINT low, IN UINT high,
 
 //Return -1 if it has no other element.
 //'elem': return next one to current element.
-INT BITSET::get_next(UINT elem) const
+INT BitSet::get_next(UINT elem) const
 {
 	if (m_size == 0) return -1;
 	INT first_byte = DIVBPB(elem);
@@ -1567,7 +1567,7 @@ INT BITSET::get_next(UINT elem) const
 }
 
 
-void BITSET::clean()
+void BitSet::clean()
 {
 	if (m_ptr == NULL) return;
 	::memset(m_ptr, 0, m_size);
@@ -1575,7 +1575,7 @@ void BITSET::clean()
 
 
 //Do copy from 'src' to 'des'.
-void BITSET::copy(BITSET const& src)
+void BitSet::copy(BitSet const& src)
 {
 	IS_TRUE(this != &src, ("copy self"));
 	if (src.m_size == 0) {
@@ -1611,14 +1611,14 @@ void BITSET::copy(BITSET const& src)
 
 
 //Support concatenation assignment such as: a=b=c
-BITSET const& BITSET::operator = (BITSET const& src)
+BitSet const& BitSet::operator = (BitSet const& src)
 {
 	copy(src);
 	return *this;
 }
 
 
-void BITSET::dump(CHAR const* name, bool is_del, UINT flag, INT last_pos) const
+void BitSet::dump(CHAR const* name, bool is_del, UINT flag, INT last_pos) const
 {
 	if (name == NULL) {
 		name = "zbs.cxx";
@@ -1633,7 +1633,7 @@ void BITSET::dump(CHAR const* name, bool is_del, UINT flag, INT last_pos) const
 }
 
 
-void BITSET::dump(FILE * h, UINT flag, INT last_pos) const
+void BitSet::dump(FILE * h, UINT flag, INT last_pos) const
 {
 	if (h == NULL) { return; }
 	IS_TRUE0(last_pos < 0 || (last_pos / BITS_PER_BYTE) < (INT)m_size);
@@ -1687,17 +1687,17 @@ void BITSET::dump(FILE * h, UINT flag, INT last_pos) const
 	}
 	fflush(h);
 }
-//END BITSET
+//END BitSet
 
 
 //
-//START BITSET_MGR
+//START BitSetMgr
 //
 //'h': dump mem usage detail to file.
-UINT BITSET_MGR::count_mem(FILE * h)
+UINT BitSetMgr::count_mem(FILE * h)
 {
 	UINT count = 0;
-	C<BITSET*> * ct;
+	C<BitSet*> * ct;
 	for (m_bs_list.get_head(&ct);
 		 ct != m_bs_list.end(); ct = m_bs_list.get_next(ct)) {
 		IS_TRUE0(ct->val());
@@ -1708,11 +1708,11 @@ UINT BITSET_MGR::count_mem(FILE * h)
 	#ifdef _DEBUG_
     if (h != NULL) {
         //Dump mem usage into file.
-		LIST<UINT> lst;
-		C<BITSET*> * ct2;
+		List<UINT> lst;
+		C<BitSet*> * ct2;
 		for (m_bs_list.get_head(&ct2); 
 			 ct2 != m_bs_list.end(); ct2 = m_bs_list.get_next(ct2)) {
-			BITSET const* bs = ct2->val(); 	
+			BitSet const* bs = ct2->val(); 	
 			UINT c = bs->count_mem();
 			
 			C<UINT> * ct;
@@ -1731,7 +1731,7 @@ UINT BITSET_MGR::count_mem(FILE * h)
 		}
 		
 		UINT v = lst.get_head();
-		fprintf(h, "\n== DUMP BITSET_MGR: total %d bitsets, mem usage are:\n",
+		fprintf(h, "\n== DUMP BitSetMgr: total %d bitsets, mem usage are:\n",
 				   m_bs_list.get_elem_count());
 
 		UINT b = 0;
@@ -1754,7 +1754,7 @@ UINT BITSET_MGR::count_mem(FILE * h)
 	#endif
 	return count;
 }
-//END BITSET_MGR
+//END BitSetMgr
 
 
 
@@ -1763,8 +1763,8 @@ UINT BITSET_MGR::count_mem(FILE * h)
 //
 //Returns a new set which is the union of set1 and set2,
 //and modify 'res' as result.
-BITSET * bs_union(IN BITSET const& set1, IN BITSET const& set2,
-				  OUT BITSET & res)
+BitSet * bs_union(IN BitSet const& set1, IN BitSet const& set2,
+				  OUT BitSet & res)
 {
 	IS_TRUE(set1.m_ptr != NULL && set2.m_ptr != NULL && res.m_ptr != NULL,
 			("not yet init"));
@@ -1785,7 +1785,7 @@ BITSET * bs_union(IN BITSET const& set1, IN BITSET const& set2,
 
 //Subtracting set2 from set1
 //Returns a new set which is { x : member( x, 'set1' ) & ~ member( x, 'set2' ) }.
-BITSET * bs_diff(IN BITSET const& set1, IN BITSET const& set2, OUT BITSET & res)
+BitSet * bs_diff(IN BitSet const& set1, IN BitSet const& set2, OUT BitSet & res)
 {
 	IS_TRUE(set1.m_ptr != NULL &&
 			set2.m_ptr != NULL &&
@@ -1793,7 +1793,7 @@ BITSET * bs_diff(IN BITSET const& set1, IN BITSET const& set2, OUT BITSET & res)
 	if (&res == &set1) {
 		res.diff(set2);
 	} else if (&res == &set2) {
-		BITSET tmp(set1);
+		BitSet tmp(set1);
 		tmp.diff(set2);
 		res.copy(tmp);
 	} else {
@@ -1805,9 +1805,9 @@ BITSET * bs_diff(IN BITSET const& set1, IN BITSET const& set2, OUT BITSET & res)
 
 
 //Returns a new set which is intersection of 'set1' and 'set2'.
-BITSET * bs_intersect(IN BITSET const& set1,
-					  IN BITSET const& set2,
-					  OUT BITSET & res)
+BitSet * bs_intersect(IN BitSet const& set1,
+					  IN BitSet const& set2,
+					  OUT BitSet & res)
 {
 	IS_TRUE(set1.m_ptr != NULL &&
 			set2.m_ptr != NULL &&
@@ -1825,38 +1825,38 @@ BITSET * bs_intersect(IN BITSET const& set1,
 
 
 //
-//START SDBITSET_MGR
+//START MiscBitSetMgr
 //
 //'h': dump mem usage detail to file.
-UINT SDBITSET_MGR::count_mem(FILE * h) const
+UINT MiscBitSetMgr::count_mem(FILE * h) const
 {
 	UINT count = 0;
-	for (SC<SBITSET*> * st = m_sbitset_list.get_head(); 
+	for (SC<SBitSet*> * st = m_sbitset_list.get_head(); 
 		 st != m_sbitset_list.end(); st = m_sbitset_list.get_next(st)) {
 		IS_TRUE0(st->val());
 		count += st->val()->count_mem();
 	}
 
-	for (SC<DBITSET*> * dt = m_dbitset_list.get_head();
+	for (SC<DBitSet*> * dt = m_dbitset_list.get_head();
 		 dt != m_dbitset_list.end(); dt = m_dbitset_list.get_next(dt)) {
 		IS_TRUE0(dt->val());
 		count += dt->val()->count_mem();
 	}
 
-	//DBITSETC and SBITSETC are allocated in the pool.
-	count += smpool_get_pool_size_handle(m_sbitsetc_pool);
-	count += smpool_get_pool_size_handle(m_dbitsetc_pool);
-	count += smpool_get_pool_size_handle(ptr_pool);
+	//DBitSetCore and SBitSetCore are allocated in the pool.
+	count += smpoolGetPoolSize(m_sbitsetc_pool);
+	count += smpoolGetPoolSize(m_dbitsetc_pool);
+	count += smpoolGetPoolSize(ptr_pool);
 	count += sm.count_mem();
 
 	UNUSED(h);
 	#ifdef _DEBUG_
 	if (h != NULL) {
 		//Dump mem usage into file.
-		LIST<UINT> lst;
-		for (SC<SBITSET*> * st = m_sbitset_list.get_head();
+		List<UINT> lst;
+		for (SC<SBitSet*> * st = m_sbitset_list.get_head();
 			 st != m_sbitset_list.end(); st = m_sbitset_list.get_next(st)) {
-			SBITSET const* bs = st->val(); 
+			SBitSet const* bs = st->val(); 
 			IS_TRUE0(bs);
 
 			UINT c = bs->count_mem();
@@ -1876,7 +1876,7 @@ UINT SDBITSET_MGR::count_mem(FILE * h) const
 		}
 			 
 		UINT v = lst.get_head();
-		fprintf(h, "\n== DUMP BITSET_MGR: total %d "
+		fprintf(h, "\n== DUMP BitSetMgr: total %d "
 					"bitsets, mem usage are:\n",
 					m_sbitset_list.get_elem_count());
 		
@@ -1900,16 +1900,16 @@ UINT SDBITSET_MGR::count_mem(FILE * h) const
 	#endif
 	return count;
 }
-//END SDBITSET_MGR
+//END MiscBitSetMgr
 
 
 //
-//START SBITSETC
+//START SBitSetCore
 //
 //'free_list': free list for SC<SEG*>
 //'pool': be used to alloc SC<SEG*>
-void SBITSETC::bunion(SBITSETC const& src, SEG_MGR * sm,
-					  SC<SEG*> ** free_list, SMEM_POOL * pool)
+void SBitSetCore::bunion(SBitSetCore const& src, SegMgr * sm,
+					  SC<SEG*> ** free_list, SMemPool * pool)
 {
 	IS_TRUE(this != &src, ("operate on same set"));
 	SC<SEG*> * tgtst = segs.get_head();
@@ -1963,8 +1963,8 @@ void SBITSETC::bunion(SBITSETC const& src, SEG_MGR * sm,
 
 //'free_list': free list for SC<SEG*>
 //'pool': be used to alloc SC<SEG*>
-void SBITSETC::bunion(UINT elem, SEG_MGR * sm,
-					  SC<SEG*> ** free_list, SMEM_POOL * pool)
+void SBitSetCore::bunion(UINT elem, SegMgr * sm,
+					  SC<SEG*> ** free_list, SMemPool * pool)
 {
 	SC<SEG*> * prev_sct = NULL;
 	SC<SEG*> * sct = segs.get_head();
@@ -1998,8 +1998,8 @@ void SBITSETC::bunion(UINT elem, SEG_MGR * sm,
 }
 
 
-void SBITSETC::copy(SBITSETC const& src, SEG_MGR * sm,
-					SC<SEG*> ** free_list, SMEM_POOL * pool)
+void SBitSetCore::copy(SBitSetCore const& src, SegMgr * sm,
+					SC<SEG*> ** free_list, SMemPool * pool)
 {
 	IS_TRUE(this != &src, ("operate on same set"));
 	clean(sm, free_list);
@@ -2015,7 +2015,7 @@ void SBITSETC::copy(SBITSETC const& src, SEG_MGR * sm,
 }
 
 
-void SBITSETC::clean(SEG_MGR * sm, SC<SEG*> ** free_list)
+void SBitSetCore::clean(SegMgr * sm, SC<SEG*> ** free_list)
 {
 	for (SC<SEG*> * st = segs.get_head(); 
 		 st != segs.end(); st = segs.get_next(st)) {
@@ -2025,16 +2025,16 @@ void SBITSETC::clean(SEG_MGR * sm, SC<SEG*> ** free_list)
 		sm->free(s);
 	}
 
-	//Free the list of container of SEG* back to SEG_MGR.
+	//Free the list of container of SEG* back to SegMgr.
 	segs.clean(free_list);
 }
 
 
-void SBITSETC::destroy_seg_and_clean(SEG_MGR * sm, SC<SEG*> ** free_list)
+void SBitSetCore::destroy_seg_and_clean(SegMgr * sm, SC<SEG*> ** free_list)
 {
 	for (SC<SEG*> * st = segs.get_head(); 
 		 st != segs.end(); st = segs.get_next(st)) {
-		//Delete it here, and we are not going to give it back to SEG_MGR.
+		//Delete it here, and we are not going to give it back to SegMgr.
 		SEG * s = st->val();
 		IS_TRUE0(s);
 		
@@ -2052,7 +2052,7 @@ void SBITSETC::destroy_seg_and_clean(SEG_MGR * sm, SC<SEG*> ** free_list)
 }
 
 
-UINT SBITSETC::count_mem() const
+UINT SBitSetCore::count_mem() const
 {
 	UINT c = 0;
 	for (SC<SEG*> * st = segs.get_head(); 
@@ -2067,7 +2067,7 @@ UINT SBITSETC::count_mem() const
 }
 
 
-void SBITSETC::diff(UINT elem, SEG_MGR * sm, SC<SEG*> ** free_list)
+void SBitSetCore::diff(UINT elem, SegMgr * sm, SC<SEG*> ** free_list)
 {
 	SC<SEG*> * sct = segs.get_head();
 	SC<SEG*> * next_sct = sct;
@@ -2094,7 +2094,7 @@ void SBITSETC::diff(UINT elem, SEG_MGR * sm, SC<SEG*> ** free_list)
 
 //Difference between current bitset and 'src', current bitset
 //will be modified.
-void SBITSETC::diff(SBITSETC const& src, SEG_MGR * sm, SC<SEG*> ** free_list)
+void SBitSetCore::diff(SBitSetCore const& src, SegMgr * sm, SC<SEG*> ** free_list)
 {
 	IS_TRUE(this != &src, ("operate on same set"));
 	SC<SEG*> * tgtst = segs.get_head();
@@ -2140,7 +2140,7 @@ void SBITSETC::diff(SBITSETC const& src, SEG_MGR * sm, SC<SEG*> ** free_list)
 }
 
 
-void SBITSETC::dump2(FILE * h) const
+void SBitSetCore::dump2(FILE * h) const
 {
 	IS_TRUE0(h);
 	fprintf(h, "\n");
@@ -2153,7 +2153,7 @@ void SBITSETC::dump2(FILE * h) const
 }
 
 
-void SBITSETC::dump(FILE * h) const
+void SBitSetCore::dump(FILE * h) const
 {
 	IS_TRUE0(h);
 	for (SC<SEG*> * st = segs.get_head(); 
@@ -2176,7 +2176,7 @@ void SBITSETC::dump(FILE * h) const
 }
 
 
-UINT SBITSETC::get_elem_count() const
+UINT SBitSetCore::get_elem_count() const
 {
 	UINT c = 0;
 	for (SC<SEG*> * st = segs.get_head(); 
@@ -2189,7 +2189,7 @@ UINT SBITSETC::get_elem_count() const
 
 
 //*cur will be set to NULL if set is empty.
-INT SBITSETC::get_first(SC<SEG*> ** cur) const
+INT SBitSetCore::get_first(SC<SEG*> ** cur) const
 {
 	IS_TRUE0(cur);
 	SC<SEG*> * sc = segs.get_head();
@@ -2208,7 +2208,7 @@ INT SBITSETC::get_first(SC<SEG*> ** cur) const
 
 
 //*cur will be set to NULL if set is empty.
-INT SBITSETC::get_last(SC<SEG*> ** cur) const
+INT SBitSetCore::get_last(SC<SEG*> ** cur) const
 {
 	IS_TRUE0(cur);
 	SC<SEG*> * sc = segs.get_tail();
@@ -2227,7 +2227,7 @@ INT SBITSETC::get_last(SC<SEG*> ** cur) const
 
 
 //Note *cur must be initialized.
-INT SBITSETC::get_next(UINT elem, SC<SEG*> ** cur) const
+INT SBitSetCore::get_next(UINT elem, SC<SEG*> ** cur) const
 {
 	if (cur == NULL) {
 		for (SC<SEG*> * st = segs.get_head(); 
@@ -2280,7 +2280,7 @@ INT SBITSETC::get_next(UINT elem, SC<SEG*> ** cur) const
 }
 
 
-bool SBITSETC::is_equal(SBITSETC const& src) const
+bool SBitSetCore::is_equal(SBitSetCore const& src) const
 {
 	IS_TRUE(this != &src, ("operate on same set"));
 	SC<SEG*> * srcst = src.segs.get_head();
@@ -2307,7 +2307,7 @@ bool SBITSETC::is_equal(SBITSETC const& src) const
 }
 
 
-bool SBITSETC::is_intersect(SBITSETC const& src) const
+bool SBitSetCore::is_intersect(SBitSetCore const& src) const
 {
 	IS_TRUE(this != &src, ("operate on same set"));
 	SC<SEG*> * srcst = src.segs.get_head();
@@ -2334,7 +2334,7 @@ bool SBITSETC::is_intersect(SBITSETC const& src) const
 }
 
 
-bool SBITSETC::is_contain(UINT elem) const
+bool SBitSetCore::is_contain(UINT elem) const
 {
 	for (SC<SEG*> * st = segs.get_head(); 
 		 st != segs.end(); st = segs.get_next(st)) {
@@ -2350,7 +2350,7 @@ bool SBITSETC::is_contain(UINT elem) const
 }
 
 
-bool SBITSETC::is_empty() const
+bool SBitSetCore::is_empty() const
 {
 	SC<SEG*> * st = segs.get_head();
 	#ifdef _DEBUG_	
@@ -2364,7 +2364,7 @@ bool SBITSETC::is_empty() const
 
 //Do intersection for current bitset and 'src', current bitset
 //will be modified.
-void SBITSETC::intersect(SBITSETC const& src, SEG_MGR * sm,
+void SBitSetCore::intersect(SBitSetCore const& src, SegMgr * sm,
 						 SC<SEG*> ** free_list)
 {
 	IS_TRUE(this != &src, ("operate on same set"));
@@ -2433,14 +2433,14 @@ void SBITSETC::intersect(SBITSETC const& src, SEG_MGR * sm,
 		}
 	}
 }
-//END SBITSETC
+//END SBitSetCore
 
 
 //
-//START DBITSETC
+//START DBitSetCore
 //
 //*cur will be set to NULL if set is empty.
-INT DBITSETC::get_first(SC<SEG*> ** cur) const
+INT DBitSetCore::get_first(SC<SEG*> ** cur) const
 {
 	IS_TRUE0(cur);
 
@@ -2455,14 +2455,14 @@ INT DBITSETC::get_first(SC<SEG*> ** cur) const
 	IS_TRUE0(sc->val());
 	SEG * s = sc->val();
 	
-	//DBITSETC allow bs is empty if it is not sparse.
+	//DBitSetCore allow bs is empty if it is not sparse.
 	//IS_TRUE0(!s->bs.is_empty());
 	return s->get_start() + s->bs.get_first();
 }
 
 
 //*cur will be set to NULL if set is empty.
-INT DBITSETC::get_last(SC<SEG*> ** cur) const
+INT DBitSetCore::get_last(SC<SEG*> ** cur) const
 {
 	SC<SEG*> * sc = segs.get_tail();
 	if (sc == segs.end()) {
@@ -2477,21 +2477,21 @@ INT DBITSETC::get_last(SC<SEG*> ** cur) const
 
 	SEG * s = sc->val();
 
-	//DBITSETC allow bs is empty if it is not sparse.
+	//DBitSetCore allow bs is empty if it is not sparse.
 	//IS_TRUE0(!s->bs.is_empty());
 	return s->get_start() + s->bs.get_last();
 }
-//END DBITSETC
+//END DBitSetCore
 
 
 #ifdef _DEBUG_
 void bs_test()
 {
 	extern FILE * g_tfile;
-	SEG_MGR sm;
+	SegMgr sm;
 
-	DBITSET a(&sm);
-	DBITSET b(&sm);
+	DBitSet a(&sm);
+	DBitSet b(&sm);
 	a.set_sparse(false);
 	b.set_sparse(false);
 	a.bunion(5);
@@ -2505,7 +2505,7 @@ void bs_test()
 	a.dump(g_tfile);
 
 
-	DBITSET x(&sm, 20);
+	DBitSet x(&sm, 20);
 	x.set_sparse(false);
 	x.bunion(1999);
 	//x.bunion(1);
@@ -2536,7 +2536,7 @@ void bs_test()
 	n = x.get_next(n, &ct);
 	n = x.get_last(&ct);
 
-	DBITSET y(&sm, 20);
+	DBitSet y(&sm, 20);
 	y.set_sparse(false);
 	y.bunion(23);
 	y.bunion(1990);
@@ -2571,8 +2571,8 @@ void bs_test()
 void bs_test2()
 {
 	extern FILE * g_tfile;
-	SEG_MGR sm;
-	SBITSET a(&sm),b(&sm);
+	SegMgr sm;
+	SBitSet a(&sm),b(&sm);
 	a.bunion(8);
 	a.bunion(512);
 	a.dump2(g_tfile);
@@ -2580,7 +2580,7 @@ void bs_test2()
 	a.dump2(g_tfile);
 
 
-	SBITSET c(&sm),d(&sm);
+	SBitSet c(&sm),d(&sm);
 	c.bunion(8);
 	c.bunion(512);
 	c.dump2(g_tfile);
@@ -2588,12 +2588,12 @@ void bs_test2()
 	d.dump2(g_tfile);
 
 
-	BITSET e,f;
+	BitSet e,f;
 	e.bunion(64);
 	//int i = e.get_first();
 
 
-	SBITSET g(&sm),h(&sm);
+	SBitSet g(&sm),h(&sm);
 	g.bunion(1);
 	g.bunion(100);
 	g.bunion(600);
@@ -2609,7 +2609,7 @@ void bs_test2()
 
 #ifdef DEBUG_SEG
 extern FILE * g_tfile;
-void dump_seg(SEG_MGR & m)
+void dump_seg(SegMgr & m)
 {
 	if (g_tfile == NULL) { return; }
 	SC<SEG*> * st = NULL;
@@ -2617,8 +2617,8 @@ void dump_seg(SEG_MGR & m)
 			m.get_free_list()->get_elem_count(),
 			m.get_seg_count());
 	
-	BITSET x;
-	SLIST<SEG*> const* flst = m.get_free_list();
+	BitSet x;
+	SList<SEG*> const* flst = m.get_free_list();
 	for (flst->get_head(&st); st != flst.end(); st = flst->get_next(st)) {
 		SEG const* s = st->val();
 		fprintf(g_tfile, "%d,", s->id);
diff --git a/src/com/bs.h b/src/com/bs.h
index e52110a..34906b1 100644
--- a/src/com/bs.h
+++ b/src/com/bs.h
@@ -36,38 +36,38 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BYTES_PER_SEG	64
 #define BITS_PER_SEG	(BITS_PER_BYTE * BYTES_PER_SEG)
 
-class BITSET;
-class BITSET_MGR;
+class BitSet;
+class BitSetMgr;
 
-class BITSET
+class BitSet
 {
-	friend BITSET * bs_union(IN BITSET const& set1, IN BITSET const& set2,
-							OUT BITSET & res);
-	friend BITSET * bs_diff(IN BITSET const& set1, IN BITSET const& set2,
-							OUT BITSET & res);
-	friend BITSET * bs_intersect(IN BITSET const& set1, IN BITSET const& set2,
-							OUT BITSET & res);
+	friend BitSet * bs_union(IN BitSet const& set1, IN BitSet const& set2,
+							OUT BitSet & res);
+	friend BitSet * bs_diff(IN BitSet const& set1, IN BitSet const& set2,
+							OUT BitSet & res);
+	friend BitSet * bs_intersect(IN BitSet const& set1, IN BitSet const& set2,
+							OUT BitSet & res);
 protected:
 	UINT m_size;
 	BYTE * m_ptr;
 
 	void * realloc(IN void * src, size_t orgsize, size_t newsize);
 public:
-	BITSET(UINT init_pool_size = 1)
+	BitSet(UINT init_pool_size = 1)		
 	{
 		m_ptr = 0;
 		init(init_pool_size);
 	}
 
 	//Copy constructor
-	BITSET(BITSET const& bs)
+	BitSet(BitSet const& bs)
 	{
 		m_ptr = 0;
 		init();
 		copy(bs);
 	}
-	BITSET const& operator = (BITSET const& src);
-	~BITSET() { destroy(); }
+	BitSet const& operator = (BitSet const& src);
+	~BitSet() { destroy(); }
 
 	void init(UINT init_pool_size = 1)
 	{
@@ -88,16 +88,16 @@ public:
 	}
 
 	void alloc(UINT size);
-	void bunion(BITSET const& bs);
+	void bunion(BitSet const& bs);
 	void bunion(UINT elem);
 
-	void copy(BITSET const& src);
+	void copy(BitSet const& src);
 	void clean();
-	UINT count_mem() const { return get_byte_size() + sizeof(BITSET); }
-	void complement(IN BITSET const& univers);
+	UINT count_mem() const { return get_byte_size() + sizeof(BitSet); }
+	void complement(IN BitSet const& univers);
 
 	void diff(UINT elem);
-	void diff(BITSET const& bs);
+	void diff(BitSet const& bs);
 	void dump(CHAR const* name = NULL, bool is_del = false,
 			  UINT flag = BS_DUMP_BITSET | BS_DUMP_POS,
 			  INT last_pos = -1) const;
@@ -107,19 +107,19 @@ public:
 	UINT get_elem_count() const;
 	INT get_first() const;
 	INT get_last() const;
-	BITSET * get_subset_in_range(UINT low, UINT high, OUT BITSET & subset);
+	BitSet * get_subset_in_range(UINT low, UINT high, OUT BitSet & subset);
 	INT get_next(UINT elem) const;
 	UINT get_byte_size() const { return m_size; }
 
 	bool has_elem_in_range(UINT low, UINT high) const;
 
-	void intersect(BITSET const& bs);
-	bool is_equal(BITSET const& bs) const;
+	void intersect(BitSet const& bs);
+	bool is_equal(BitSet const& bs) const;
 	bool is_contain(UINT elem) const;
-	bool is_contain(BITSET const& bs, bool strict = false) const;
+	bool is_contain(BitSet const& bs, bool strict = false) const;
 	bool is_contained_in_range(UINT low, UINT high, bool strict) const;
 	bool is_contain_range(UINT low, UINT high, bool strict) const;
-	bool is_intersect(BITSET const& bs) const;
+	bool is_intersect(BitSet const& bs) const;
 	bool is_overlapped(UINT low, UINT high) const;
 	bool is_empty() const;
 
@@ -127,35 +127,35 @@ public:
 };
 
 
-class BITSET_MGR
+class BitSetMgr
 {
 protected:
-	SMEM_POOL * m_pool;
-	LIST<BITSET*> m_bs_list;
-	LIST<BITSET*> m_free_list;
+	SMemPool * m_pool;
+	List<BitSet*> m_bs_list;
+	List<BitSet*> m_free_list;
 
 	inline void * xmalloc(size_t size)
 	{
-		IS_TRUE(m_pool, ("LIST not yet initialized."));
-		void * p = smpool_malloc_h_const_size(size, m_pool);
+		IS_TRUE(m_pool, ("List not yet initialized."));
+		void * p = smpoolMallocConstSize(size, m_pool);
 		IS_TRUE(p, ("malloc failed"));
 		memset(p, 0, size);
 		return p;
 	}
 public:
-	BITSET_MGR()
+	BitSetMgr()
 	{
 		m_pool = NULL;
 		init();
 	}
-	COPY_CONSTRUCTOR(BITSET_MGR);
-	~BITSET_MGR() { destroy(); }
+	COPY_CONSTRUCTOR(BitSetMgr);
+	~BitSetMgr() { destroy(); }
 	
 
 	inline void init()
 	{
 		if (m_pool != NULL) { return; }
-		m_pool = smpool_create_handle(sizeof(BITSET) * 4, MEM_CONST_SIZE);
+		m_pool = smpoolCreate(sizeof(BitSet) * 4, MEM_CONST_SIZE);
 		m_bs_list.init();
 		m_free_list.init();
 	}
@@ -164,36 +164,36 @@ public:
 	{
 		if (m_pool == NULL) { return; }
 
-		C<BITSET*> * ct;
+		C<BitSet*> * ct;
 		for (m_bs_list.get_head(&ct); 
 			 ct != m_bs_list.end(); ct = m_bs_list.get_next(ct)) {
-			BITSET * bs = ct->val();
+			BitSet * bs = ct->val();
 			IS_TRUE0(bs);
 			bs->destroy();
 		}
 		
 		m_bs_list.destroy();
 		m_free_list.destroy();
-		smpool_free_handle(m_pool);
+		smpoolDelete(m_pool);
 		m_pool = NULL;
 	}
 
-	BITSET * create(UINT init_sz = 0)
+	BitSet * create(UINT init_sz = 0)
 	{
 		IS_TRUE(m_pool, ("not yet init"));
-		BITSET * p = m_free_list.remove_head();
+		BitSet * p = m_free_list.remove_head();
 		if (p == NULL) {
-			p = (BITSET*)xmalloc(sizeof(BITSET));
+			p = (BitSet*)xmalloc(sizeof(BitSet));
 			p->init(init_sz);
 			m_bs_list.append_head(p);
 		}
 		return p;
 	}
 
-	inline BITSET * copy(BITSET const& bs)
+	inline BitSet * copy(BitSet const& bs)
 	{
 		IS_TRUE(m_pool, ("not yet init"));
-		BITSET * p = create();
+		BitSet * p = create();
 		p->copy(bs);
 		return p;
 	}
@@ -206,15 +206,15 @@ public:
 	}
 	UINT count_mem(FILE * h = NULL);
 
-	inline void free(IN BITSET * bs) //free bs for next use.
+	inline void free(IN BitSet * bs) //free bs for next use.
 	{
 		if (bs == NULL) { return; }
 		
 		#ifdef _DEBUG_
-		C<BITSET*> * ct;
+		C<BitSet*> * ct;
 		for (m_free_list.get_head(&ct); 
 			 ct != m_free_list.end(); ct = m_free_list.get_next(ct)) {
-			BITSET * x = ct->val(); 	
+			BitSet * x = ct->val(); 	
 			IS_TRUE(x && x != bs, ("Already have been freed."));
 		}
 		#endif
@@ -225,235 +225,166 @@ public:
 
 
 //
-//START BVEC
+//START BSVec
 //
-template <class T> class BVEC : public SVECTOR<T> {
+//This class represents a Vector that supply the
+//operations like BitSet. You can iterate the element
+//in the Vector via get_first and get_next.
+template <class T> class BSVec : public Vector<T> {
 protected:
-	BITSET m_bs; //Record position set by 'set()'
+	BitSet m_bs; //Record position set by 'set()'
 public:
-	BVEC();
-	BVEC(INT size);
-	~BVEC();
-	void init();
-	void destroy();
-	inline void copy(LIST<T> & list);
-	inline void clone(BVEC<T> & vec);
-	UINT count_mem() const;
-	inline void clean();
-	inline void set(UINT i, T elem);
-	inline T & operator[](INT i);
-
-	//Get the first index number and return the element.
-	inline T get_first(OUT INT * idx);
-	inline INT get_first() const; //Get first number of index of element.
-
-	//Get next index number and return the next element at the same time.
-	inline T get_next(INT * curidx);
-	inline INT get_next(UINT curidx) const; //Get next index number.
-	inline UINT get_elem_count() const; //Get number of elements in vector.
-	inline BITSET * get_bs();
-
-	//Clear bit of position 'i', and set new value 't' for the position.
-	inline void remove(UINT i, T t = (T)0);
-	void dump(CHAR const* name = NULL, bool is_del = false) const
-	{ m_bs.dump(name, is_del); }
-	void dump(FILE * h) const
-	{ m_bs.dump(h); }
-};
-
-
-template <class T>
-BVEC<T>::BVEC()
-{
-	init();
-}
-
-
-template <class T>
-BVEC<T>::BVEC(INT size)
-{
-	init();
-	SVECTOR<T>::grow(size);
-}
-
-
-template <class T>
-BVEC<T>::~BVEC()
-{
-	destroy();
-}
-
-
-template <class T>
-void BVEC<T>::init()
-{
-	if (SVECTOR<T>::m_is_init) return;
-	SVECTOR<T>::init();
-	m_bs.init();
-}
-
+	BSVec() { init(); }
+	BSVec(INT size)
+	{
+		init();
+		Vector<T>::grow(size);
+	}		
+	~BSVec() { destroy(); }
 
-template <class T>
-void BVEC<T>::destroy()
-{
-	if (!SVECTOR<T>::m_is_init) return;
-	m_bs.destroy();
-	SVECTOR<T>::destroy();
-}
+	void init()
+	{
+		if (Vector<T>::m_is_init) return;
+		Vector<T>::init();
+		m_bs.init();
+	}
 
+	void destroy()
+	{
+		if (!Vector<T>::m_is_init) return;
+		m_bs.destroy();
+		Vector<T>::destroy();
+	}
 
-template <class T>
-void BVEC<T>::copy(LIST<T> & list)
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	INT count = 0;
+	//Copy element from list.
+	inline void copy(List<T> & list)
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		INT count = 0;
+		
+		set(list.get_elem_count()-1, 0); //Alloc memory right away.
 	
-	set(list.get_elem_count()-1, 0); //Alloc memory right away.
-
-	C<T> * ct;
-	for (list.get_head(&ct); ct != list.end(); list.get_next(&ct), count++) {
-		T elem = ct->val();
-		set(count, elem);
+		C<T> * ct;
+		for (list.get_head(&ct); 
+			 ct != list.end(); list.get_next(&ct), count++) {
+			T elem = ct->val();
+			set(count, elem);
+		}
 	}
-}
-
-
-template <class T>
-void BVEC<T>::clone(BVEC<T> & vec)
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	SVECTOR<T>::copy(vec);
-	m_bs.copy(vec.m_bs);
-}
-
-
-template <class T>
-void BVEC<T>::clean()
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	SVECTOR<T>::clean();
-	m_bs.clean();
-}
-
-
-template <class T>
-UINT BVEC<T>::count_mem() const
-{
-	return m_bs.count_mem() + SVECTOR<T>::count_mem();
-}
-
-
-template <class T>
-void BVEC<T>::set(UINT i, T elem)
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	SVECTOR<T>::set(i, elem);
-	m_bs.bunion(i);
-}
-
-
-/*
-Overloaded [] for non-const array reference return.
-Create an lvalue, equal to 'set()'
-*/
-template <class T>
-T & BVEC<T>::operator[](INT i)
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	if (i >= SVECTOR<T>::m_size) {
-		set(i, (T)0);
+	
+	inline void copy(BSVec<T> & vec)
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		Vector<T>::copy(vec);
+		m_bs.copy(vec.m_bs);
+	}
+	
+	UINT count_mem() const { return m_bs.count_mem() + Vector<T>::count_mem(); }
+	inline void clean()
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		Vector<T>::clean();
+		m_bs.clean();
 	}
-	return SVECTOR<T>::m_vec[i];
-}
-
-
-template <class T>
-INT BVEC<T>::get_first() const
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	return m_bs.get_first();
-}
-
-
-template <class T>
-T BVEC<T>::get_first(OUT INT * idx)
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	INT i = m_bs.get_first();
-	if (idx) { *idx = i; }
-	return SVECTOR<T>::get(i);
-}
-
 
-//Return next element related to current 'idx'.
-template <class T>
-T BVEC<T>::get_next(OUT INT * curidx)
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	*curidx = m_bs.get_next(*curidx);
-	return SVECTOR<T>::get(*curidx);
-}
+	//Overloaded [] for non-const array reference return.
+	//Create an lvalue, equal to 'set()'
+	inline T & operator[](INT i)
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		if (i >= Vector<T>::m_size) {
+			set(i, (T)0);
+		}
+		return Vector<T>::m_vec[i];
+	}
 
+	//Get the first index number and return the element.
+	inline T get_first(OUT INT * idx)
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		INT i = m_bs.get_first();
+		if (idx) { *idx = i; }
+		return Vector<T>::get(i);
+	}
 
-template <class T>
-INT BVEC<T>::get_next(UINT curidx) const
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	return m_bs.get_next(curidx);
-}
+	//Get first number of index of element.
+	inline INT get_first() const	
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		return m_bs.get_first();
+	}
 
+	//Get next index number and return the next element at the same time.
+	//Return next element related to current 'idx'.
+	inline T get_next(INT * curidx)	
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		*curidx = m_bs.get_next(*curidx);
+		return Vector<T>::get(*curidx);
+	}
 
-//Get number of elements in vector.
-template <class T>
-UINT BVEC<T>::get_elem_count() const
-{
-	IS_TRUE(SVECTOR<T>::m_is_init, ("VECTOR not yet initialized."));
-	return m_bs.get_elem_count();
-}
+	//Get next index number.
+	inline INT get_next(UINT curidx) const
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		return m_bs.get_next(curidx);
+	}
 
+	//Get number of elements in vector.	
+	inline UINT get_elem_count() const
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		return m_bs.get_elem_count();
+	}
+	
+	inline BitSet * get_bs() { return &m_bs; }
 
-/*
-Clear bit of position 'i', and set new value 't' for the position.
-Default placeholder of clear bit is NULL.
-*/
-template <class T>
-void BVEC<T>::remove(UINT i, T t)
-{
-	m_bs.diff(i);
-	SVECTOR<T>::set(i, t);
-}
+	inline void set(UINT i, T elem) 	
+	{
+		IS_TRUE(Vector<T>::m_is_init, ("VECTOR not yet initialized."));
+		Vector<T>::set(i, elem);
+		m_bs.bunion(i);
+	}
+	
+	//Clear bit of position 'i', and set new value 't' for the position.
+	//Default placeholder of clear bit is NULL.
+	inline void remove(UINT i, T t = (T)0)
+	{
+		m_bs.diff(i);
+		Vector<T>::set(i, t);
+	}
 
+	void dump(CHAR const* name = NULL, bool is_del = false) const
+	{ m_bs.dump(name, is_del); }
 
-template <class T>
-BITSET * BVEC<T>::get_bs()
-{
-	return &m_bs;
-}
-//END BVEC
+	void dump(FILE * h) const
+	{ m_bs.dump(h); }
+};
+//END BSVec
 
 
 //
-//START BVEC_MGR
+//START BSVecMgr
 //
-template <class T> class BVEC_MGR {
+template <class T> class BSVecMgr {
 protected:
-	SLIST<BVEC<T>*> m_bs_list;
-	SLIST<BVEC<T>*> m_free_list;
-	SMEM_POOL * m_pool;
+	SList<BSVec<T>*> m_bs_list;
+	SList<BSVec<T>*> m_free_list;
+	SMemPool * m_pool;
 
 public:
-	BVEC_MGR()
+	BSVecMgr()
 	{
 		m_pool = NULL;
 		init();
 	}
-	COPY_CONSTRUCTOR(BVEC_MGR);
-	~BVEC_MGR(){ destroy(); }
+	COPY_CONSTRUCTOR(BSVecMgr);
+	~BSVecMgr(){ destroy(); }
 
 	inline void init()
 	{
 		if (m_pool != NULL) { return; }
-		m_pool = smpool_create_handle(sizeof(SC<BVEC<T>*>) * 2, MEM_CONST_SIZE);
+		m_pool = smpoolCreate(sizeof(SC<BSVec<T>*>) * 2, MEM_CONST_SIZE);
 		m_bs_list.set_pool(m_pool);
 		m_free_list.set_pool(m_pool);
 	}
@@ -462,15 +393,15 @@ public:
 	{
 		if (m_pool == NULL) { return; }
 
-		for (SC<BVEC<T>*> * ct = m_bs_list.get_head(); 
+		for (SC<BSVec<T>*> * ct = m_bs_list.get_head(); 
 			 ct != m_bs_list.end(); ct = m_bs_list.get_next(ct)) {
-			BVEC<T> * bs = ct->val();
+			BSVec<T> * bs = ct->val();
 			IS_TRUE0(bs);
 			
 			bs->destroy();
 		}
 		
-		smpool_free_handle(m_pool);
+		smpoolDelete(m_pool);
 		m_pool = NULL;
 	}
 	
@@ -479,8 +410,8 @@ public:
 		if (h == NULL) { return; }		
 	 
 		//Dump mem usage into file.
-		LIST<UINT> lst;
-		for (BVEC<T> const* bs = m_bs_list.get_head();
+		List<UINT> lst;
+		for (BSVec<T> const* bs = m_bs_list.get_head();
 			 bs != m_bs_list.end(); bs = m_bs_list.get_next()) {
 			UINT c = bs->count_mem();
 			C<UINT> * ct;
@@ -498,7 +429,7 @@ public:
 			}
 		}
 		UINT v = lst.get_head();
-		fprintf(h, "\n== DUMP BITSET_MGR: total %d "
+		fprintf(h, "\n== DUMP BitSetMgr: total %d "
 				   "bitsets, mem usage are:\n",
 				   m_bs_list.get_elem_count());
 		UINT b = 0;
@@ -519,14 +450,14 @@ public:
 		fflush(h);
 	}
 	
-	BVEC<T> * create()
+	BSVec<T> * create()
 	{
 		IS_TRUE(m_pool, ("not yet init"));
 		
-		BVEC<T> * p = m_free_list.remove_head();
+		BSVec<T> * p = m_free_list.remove_head();
 		if (p == NULL) {
-			p = (BVEC<T>*)::malloc(sizeof(BVEC<T>));
-			::memset(p, 0, sizeof(BVEC<T>));
+			p = (BSVec<T>*)::malloc(sizeof(BSVec<T>));
+			::memset(p, 0, sizeof(BSVec<T>));
 			p->init();
 			m_bs_list.append_head(p);
 		}
@@ -542,10 +473,10 @@ public:
 	
 	UINT count_mem()
 	{
-		UINT count = smpool_get_pool_size_handle(m_pool);
-		for (SC<BVEC<T>*> * ct = m_bs_list.get_head(); 
+		UINT count = smpoolGetPoolSize(m_pool);
+		for (SC<BSVec<T>*> * ct = m_bs_list.get_head(); 
 			 ct != m_bs_list.end(); ct = m_bs_list.get_next(ct)) {
-			BVEC<T> * bs = ct->val();
+			BSVec<T> * bs = ct->val();
 			IS_TRUE0(bs);
 
 			count += bs->count_mem();
@@ -553,7 +484,7 @@ public:
 		return count;
 	}
 	
-	inline void free(IN BVEC<T> * bs) //free bs for next use.
+	inline void free(IN BSVec<T> * bs) //free bs for next use.
 	{
 		if (bs == NULL) return;
 		bs->clean();
@@ -564,7 +495,7 @@ public:
 
 
 //
-//Sparse BITSET
+//Sparse BitSet
 //
 
 //#define DEBUG_SEG
@@ -575,7 +506,7 @@ public:
 	int id;
 	#endif
 	UINT start;
-	BITSET bs;
+	BitSet bs;
 
 	SEG()
 	{
@@ -623,25 +554,25 @@ public:
 
 //Segment Manager.
 //This class is responsible to allocate and destroy SEG object.
-class SEG_MGR {
+class SegMgr {
 #ifdef _DEBUG_
 public:
 	UINT seg_count;
 #endif
-	SLIST<SEG*> m_free_list;
+	SList<SEG*> m_free_list;
 public:
-	SEG_MGR()
+	SegMgr()
 	{
 		#ifdef _DEBUG_
 		seg_count = 0;
 		#endif
-		SMEM_POOL * p = smpool_create_handle(sizeof(SC<SEG*>) * 4,
+		SMemPool * p = smpoolCreate(sizeof(SC<SEG*>) * 4,
 											 MEM_CONST_SIZE);
 		m_free_list.set_pool(p);
 	}
-	COPY_CONSTRUCTOR(SEG_MGR);
+	COPY_CONSTRUCTOR(SegMgr);
 
-	~SEG_MGR()
+	~SegMgr()
 	{
 		#ifdef _DEBUG_
 		UINT n = m_free_list.get_elem_count();
@@ -658,7 +589,7 @@ public:
 			 
 		IS_TRUE(m_free_list.get_pool(), ("miss pool"));
 		
-		smpool_free_handle(m_free_list.get_pool());
+		smpoolDelete(m_free_list.get_pool());
 	}
 
 	inline void free(SEG * s)
@@ -707,44 +638,44 @@ public:
 	void dec_seg_count() { seg_count--; }
 	#endif
 
-	SLIST<SEG*> const* get_free_list() const { return &m_free_list; }
+	SList<SEG*> const* get_free_list() const { return &m_free_list; }
 };
 
 
-class SDBITSET_MGR;
+class MiscBitSetMgr;
 
 
-//Sparse BITSET Core
-class SBITSETC {
+//Sparse BitSet Core
+class SBitSetCore {
 protected:
-	SLISTC2<SEG*> segs;
+	SList2<SEG*> segs;
 
 	void * realloc(IN void * src, size_t orgsize, size_t newsize);
 public:
-	SBITSETC() {}
-	COPY_CONSTRUCTOR(SBITSETC);
-	~SBITSETC() { /*should call clean() before destruction.*/ }
-
-	void bunion(SBITSETC const& src, SEG_MGR * sm,
-				SC<SEG*> ** free_list, SMEM_POOL * pool);
-
-	void bunion(UINT elem, SEG_MGR * sm,
-				SC<SEG*> ** free_list, SMEM_POOL * pool);
-	inline void bunion(UINT elem, SDBITSET_MGR & m);
-	inline void bunion(SBITSETC const& src, SDBITSET_MGR &m);
-
-	inline void clean(SDBITSET_MGR & m);
-	void clean(SEG_MGR * sm, SC<SEG*> ** free_list);
-	void copy(SBITSETC const& src, SEG_MGR * sm,
-			  SC<SEG*> ** free_list, SMEM_POOL * pool);
-	inline void copy(SBITSETC const& src, SDBITSET_MGR & m);
+	SBitSetCore() {}
+	COPY_CONSTRUCTOR(SBitSetCore);
+	~SBitSetCore() { /*should call clean() before destruction.*/ }
+
+	void bunion(SBitSetCore const& src, SegMgr * sm,
+				SC<SEG*> ** free_list, SMemPool * pool);
+
+	void bunion(UINT elem, SegMgr * sm,
+				SC<SEG*> ** free_list, SMemPool * pool);
+	inline void bunion(UINT elem, MiscBitSetMgr & m);
+	inline void bunion(SBitSetCore const& src, MiscBitSetMgr &m);
+
+	inline void clean(MiscBitSetMgr & m);
+	void clean(SegMgr * sm, SC<SEG*> ** free_list);
+	void copy(SBitSetCore const& src, SegMgr * sm,
+			  SC<SEG*> ** free_list, SMemPool * pool);
+	inline void copy(SBitSetCore const& src, MiscBitSetMgr & m);
 	UINT count_mem() const;
 
-	void destroy_seg_and_clean(SEG_MGR * sm, SC<SEG*> ** free_list);
-	void diff(UINT elem, SEG_MGR * sm, SC<SEG*> ** free_list);
-	inline void diff(UINT elem, SDBITSET_MGR & m);
-	void diff(SBITSETC const& src, SEG_MGR * sm, SC<SEG*> ** free_list);
-	inline void diff(SBITSETC const& src, SDBITSET_MGR & m);
+	void destroy_seg_and_clean(SegMgr * sm, SC<SEG*> ** free_list);
+	void diff(UINT elem, SegMgr * sm, SC<SEG*> ** free_list);
+	inline void diff(UINT elem, MiscBitSetMgr & m);
+	void diff(SBitSetCore const& src, SegMgr * sm, SC<SEG*> ** free_list);
+	inline void diff(SBitSetCore const& src, MiscBitSetMgr & m);
 	void dump(FILE * h) const;
 	void dump2(FILE * h) const;
 
@@ -753,37 +684,37 @@ public:
 	INT get_last(SC<SEG*> ** cur) const;
 	INT get_next(UINT elem, SC<SEG*> ** cur) const;
 	
-	void intersect(SBITSETC const& src, SEG_MGR * sm, SC<SEG*> ** free_list);
-	inline void intersect(SBITSETC const& src, SDBITSET_MGR & m);
-	bool is_equal(SBITSETC const& src) const;
+	void intersect(SBitSetCore const& src, SegMgr * sm, SC<SEG*> ** free_list);
+	inline void intersect(SBitSetCore const& src, MiscBitSetMgr & m);
+	bool is_equal(SBitSetCore const& src) const;
 	bool is_contain(UINT elem) const;
-	bool is_intersect(SBITSETC const& src) const;
+	bool is_intersect(SBitSetCore const& src) const;
 	bool is_empty() const;
 };
 
 
 
-//Sparse BITSET
-class SBITSET : public SBITSETC {
+//Sparse BitSet
+class SBitSet : public SBitSetCore {
 protected:
-	SMEM_POOL * m_pool;
+	SMemPool * m_pool;
 	SC<SEG*> * m_flst; //free list
-	SEG_MGR * m_sm;
+	SegMgr * m_sm;
 public:
-	SBITSET(SEG_MGR * sm, UINT sz = sizeof(SC<SEG*>))
+	SBitSet(SegMgr * sm, UINT sz = sizeof(SC<SEG*>))
 	{ 
 		m_pool = NULL;
 		init(sm, sz); 
 	}
-	COPY_CONSTRUCTOR(SBITSET);
-	~SBITSET() { destroy(); }
+	COPY_CONSTRUCTOR(SBitSet);
+	~SBitSet() { destroy(); }
 	
-	void init(SEG_MGR * sm, UINT sz = sizeof(SC<SEG*>))
+	void init(SegMgr * sm, UINT sz = sizeof(SC<SEG*>))
 	{
-		IS_TRUE(sm, ("need SEG_MGR"));
+		IS_TRUE(sm, ("need SegMgr"));
 		IS_TRUE(sz % sizeof(SC<SEG*>) == 0, ("pool size must be mulitple."));
 		IS_TRUE(m_pool == NULL, ("already initialized"));
-		m_pool = smpool_create_handle(sz, MEM_CONST_SIZE);
+		m_pool = smpoolCreate(sz, MEM_CONST_SIZE);
 		m_sm = sm;
 		m_flst = NULL;
 	}
@@ -801,25 +732,25 @@ public:
 		
 		//Unnecessary call clean(), since free pool will free all
 		//SC<SEG*> object.
-		//SBITSETC::clean(m_sm, &m_flst);
-		smpool_free_handle(m_pool);
+		//SBitSetCore::clean(m_sm, &m_flst);
+		smpoolDelete(m_pool);
 		m_pool = NULL;
 	}
 	
-	void bunion(SBITSET const& src)
-	{ SBITSETC::bunion(src, m_sm, &m_flst, m_pool);	}
+	void bunion(SBitSet const& src)
+	{ SBitSetCore::bunion(src, m_sm, &m_flst, m_pool);	}
 
 	void bunion(UINT elem)
-	{ SBITSETC::bunion(elem, m_sm, &m_flst, m_pool); }
+	{ SBitSetCore::bunion(elem, m_sm, &m_flst, m_pool); }
 
-	void copy(SBITSET const& src)
+	void copy(SBitSet const& src)
 	{
 		//Do NOT change current m_sm.
-		SBITSETC::copy(src, m_sm, &m_flst, m_pool);
+		SBitSetCore::copy(src, m_sm, &m_flst, m_pool);
 	}
 
 	void clean()
-	{ SBITSETC::clean(m_sm, &m_flst); }
+	{ SBitSetCore::clean(m_sm, &m_flst); }
 
 	UINT count_mem() const
 	{
@@ -832,34 +763,36 @@ public:
 		c += sizeof(m_pool);
 		c += sizeof(m_sm);
 		c += segs.count_mem();
-		c += smpool_get_pool_size_handle(m_pool);
+		c += smpoolGetPoolSize(m_pool);
 		return c;
 	}
 
 	void diff(UINT elem)
-	{ SBITSETC::diff(elem, m_sm, &m_flst); }
+	{ SBitSetCore::diff(elem, m_sm, &m_flst); }
 
 	//Difference between current bitset and 'src', current bitset
 	//will be modified.
-	void diff(SBITSET const& src)
-	{ SBITSETC::diff(src, m_sm, &m_flst); }
+	void diff(SBitSet const& src)
+	{ SBitSetCore::diff(src, m_sm, &m_flst); }
 
 	//Do intersection for current bitset and 'src', current bitset
 	//will be modified.
-	void intersect(SBITSET const& src)
-	{ SBITSETC::intersect(src, m_sm, &m_flst); }
+	void intersect(SBitSet const& src)
+	{ SBitSetCore::intersect(src, m_sm, &m_flst); }
 };
 
 
 //
-//START DBITSETC, Dual BITSET Core
+//START DBitSetCore, Dual BitSet Core
 //
-class DBITSETC : public SBITSETC {
+//This class represent a BitSet which can be switched between sparse and
+//dense bitset.
+class DBitSetCore : public SBitSetCore {
 protected:
 	UINT m_is_sparse:1; //true if bitset is sparse.
 
-	//Only read BITSET.
-	BITSET const* read_bs() const
+	//Only read BitSet.
+	BitSet const* read_bs() const
 	{
 		IS_TRUE(!m_is_sparse, ("only used by dense bitset"));
 		SC<SEG*> * sc = segs.get_head();
@@ -870,8 +803,8 @@ protected:
 		return &sc->val()->bs;
 	}
 
-	//Get BITSET, alloc BITSET if it not exist.
-	BITSET * alloc_bs(SEG_MGR * sm, SC<SEG*> ** flst, SMEM_POOL * pool)
+	//Get BitSet, alloc BitSet if it not exist.
+	BitSet * alloc_bs(SegMgr * sm, SC<SEG*> ** flst, SMemPool * pool)
 	{
 		IS_TRUE(!m_is_sparse, ("only used by dense bitset"));
 		SC<SEG*> * sc = segs.get_head();
@@ -884,8 +817,8 @@ protected:
 		return &sc->val()->bs;
 	}
 
-	//Get BITSET and modify BITSET, do not alloc.
-	BITSET * get_bs()
+	//Get BitSet and modify BitSet, do not alloc.
+	BitSet * get_bs()
 	{
 		IS_TRUE(!m_is_sparse, ("only used by dense bitset"));
 		SC<SEG*> * sc = segs.get_head();
@@ -896,125 +829,125 @@ protected:
 		return &sc->val()->bs;
 	}
 public:
-	DBITSETC() { m_is_sparse = true; }
-	COPY_CONSTRUCTOR(DBITSETC);
-	~DBITSETC() {}
+	DBitSetCore() { m_is_sparse = true; }
+	COPY_CONSTRUCTOR(DBitSetCore);
+	~DBitSetCore() {}
 
-	void bunion(DBITSETC const& src, SEG_MGR * sm, SC<SEG*> ** free_list,
-				SMEM_POOL * pool)
+	void bunion(DBitSetCore const& src, SegMgr * sm, SC<SEG*> ** free_list,
+				SMemPool * pool)
 	{
 		IS_TRUE(this != &src, ("operate on same set"));
 		IS_TRUE(m_is_sparse == src.m_is_sparse, ("diff set type"));
 		if (m_is_sparse) {
-			SBITSETC::bunion(src, sm, free_list, pool);
+			SBitSetCore::bunion(src, sm, free_list, pool);
 		} else {
-			BITSET const* srcbs = src.read_bs();
+			BitSet const* srcbs = src.read_bs();
 			if (srcbs == NULL) { return; }
-			BITSET * tgtbs = alloc_bs(sm, free_list, pool);
+			BitSet * tgtbs = alloc_bs(sm, free_list, pool);
 			tgtbs->bunion(*srcbs);
 		}
 	}
-	inline void bunion(DBITSETC const& src, SDBITSET_MGR & m);
+	inline void bunion(DBitSetCore const& src, MiscBitSetMgr & m);
 
-	void bunion(UINT elem, SEG_MGR * sm, SC<SEG*> ** free_list,
-				SMEM_POOL * pool)
+	void bunion(UINT elem, SegMgr * sm, SC<SEG*> ** free_list,
+				SMemPool * pool)
 	{
 		if (m_is_sparse) {
-			SBITSETC::bunion(elem, sm, free_list, pool);
+			SBitSetCore::bunion(elem, sm, free_list, pool);
 		} else {
-			BITSET * tgtbs = alloc_bs(sm, free_list, pool);
+			BitSet * tgtbs = alloc_bs(sm, free_list, pool);
 			tgtbs->bunion(elem);
 		}
 	}
-	inline void bunion(UINT elem, SDBITSET_MGR & m);
+	inline void bunion(UINT elem, MiscBitSetMgr & m);
 
-	void copy(DBITSETC const& src, SEG_MGR * sm, SC<SEG*> ** free_list,
-			  SMEM_POOL * pool)
+	void copy(DBitSetCore const& src, SegMgr * sm, SC<SEG*> ** free_list,
+			  SMemPool * pool)
 	{
 		IS_TRUE(this != &src, ("operate on same set"));
 		IS_TRUE(m_is_sparse == src.m_is_sparse, ("diff set type"));
 		if (m_is_sparse) {
-			SBITSETC::copy(src, sm, free_list, pool);
+			SBitSetCore::copy(src, sm, free_list, pool);
 		} else {
-			BITSET const* srcbs = src.read_bs();
+			BitSet const* srcbs = src.read_bs();
 			if (srcbs == NULL) {
 				clean(sm, free_list);
 				return;
 			}
-			BITSET * tgtbs = alloc_bs(sm, free_list, pool);
+			BitSet * tgtbs = alloc_bs(sm, free_list, pool);
 			tgtbs->copy(*srcbs);
 		}
 	}
-	inline void copy(DBITSETC const& src, SDBITSET_MGR & m);
+	inline void copy(DBitSetCore const& src, MiscBitSetMgr & m);
 
-	UINT count_mem() const { return SBITSETC::count_mem() + 1; }
+	UINT count_mem() const { return SBitSetCore::count_mem() + 1; }
 
-	void diff(UINT elem, SEG_MGR * sm, SC<SEG*> ** free_list)
+	void diff(UINT elem, SegMgr * sm, SC<SEG*> ** free_list)
 	{
 		if (m_is_sparse) {
-			SBITSETC::diff(elem, sm, free_list);
+			SBitSetCore::diff(elem, sm, free_list);
 		} else {
-			BITSET * tgtbs = get_bs();
+			BitSet * tgtbs = get_bs();
 			if (tgtbs == NULL) { return; }
 			tgtbs->diff(elem);
 		}
 	}
-	inline void diff(UINT elem, SDBITSET_MGR & m);
+	inline void diff(UINT elem, MiscBitSetMgr & m);
 
-	void diff(DBITSETC const& src, SEG_MGR * sm, SC<SEG*> ** free_list)
+	void diff(DBitSetCore const& src, SegMgr * sm, SC<SEG*> ** free_list)
 	{
 		IS_TRUE(this != &src, ("operate on same set"));
 		IS_TRUE(m_is_sparse == src.m_is_sparse, ("diff set type"));
 		if (m_is_sparse) {
-			SBITSETC::diff(src, sm, free_list);
+			SBitSetCore::diff(src, sm, free_list);
 		} else {
-			BITSET const* srcbs = src.read_bs();
+			BitSet const* srcbs = src.read_bs();
 			if (srcbs == NULL) { return; }
-			BITSET * tgtbs = get_bs();
+			BitSet * tgtbs = get_bs();
 			if (tgtbs == NULL) { return; }
 			tgtbs->diff(*srcbs);
 		}
 	}
-	inline void diff(DBITSETC const& src, SDBITSET_MGR & m);
+	inline void diff(DBitSetCore const& src, MiscBitSetMgr & m);
 
-	void intersect(DBITSETC const& src, SEG_MGR * sm, SC<SEG*> ** free_list)
+	void intersect(DBitSetCore const& src, SegMgr * sm, SC<SEG*> ** free_list)
 	{
 		IS_TRUE(this != &src, ("operate on same set"));
 		IS_TRUE(m_is_sparse == src.m_is_sparse, ("diff set type"));
 		if (m_is_sparse) {
-			SBITSETC::intersect(src, sm, free_list);
+			SBitSetCore::intersect(src, sm, free_list);
 		} else {
-			BITSET const* srcbs = src.read_bs();
+			BitSet const* srcbs = src.read_bs();
 			if (srcbs == NULL) {
 				clean(sm, free_list);
 				return;
 			}
-			BITSET * tgtbs = get_bs();
+			BitSet * tgtbs = get_bs();
 			if (tgtbs == NULL) { return; }
 			tgtbs->intersect(*srcbs);
 		}
 	}
-	inline void intersect(DBITSETC const& src, SDBITSET_MGR & m);
+	inline void intersect(DBitSetCore const& src, MiscBitSetMgr & m);
 
 	bool is_contain(UINT elem) const
 	{
 		if (m_is_sparse) {
-			return SBITSETC::is_contain(elem);
+			return SBitSetCore::is_contain(elem);
 		}
-		BITSET const* tgtbs = read_bs();
+		BitSet const* tgtbs = read_bs();
 		if (tgtbs == NULL) { return false; }
 		return tgtbs->is_contain(elem);
 	}
 
-	bool is_equal(DBITSETC const& src) const
+	bool is_equal(DBitSetCore const& src) const
 	{
 		IS_TRUE(this != &src, ("operate on same set"));
 		IS_TRUE(m_is_sparse == src.m_is_sparse, ("diff set type"));
 		if (m_is_sparse) {
-			return SBITSETC::is_equal(src);
+			return SBitSetCore::is_equal(src);
 		}
-		BITSET const* srcbs = src.read_bs();
-		BITSET const* tgtbs = read_bs();
+		BitSet const* srcbs = src.read_bs();
+		BitSet const* tgtbs = read_bs();
 		if (srcbs == NULL) {
 			if (tgtbs == NULL) { return true; }
 			if (tgtbs->is_empty()) { return true; }
@@ -1036,25 +969,27 @@ public:
 
 
 //
-//START DBITSET, Dual BITSET
+//START DBitSet, Dual BitSet
 //
-class DBITSET : public DBITSETC {
+//This class represent a BitSet which can be switched between sparse and
+//dense bitset.
+class DBitSet : public DBitSetCore {
 protected:
-	SMEM_POOL * m_pool;
+	SMemPool * m_pool;
 	SC<SEG*> * m_flst;
-	SEG_MGR * m_sm;
+	SegMgr * m_sm;
 public:
-	DBITSET(SEG_MGR * sm, UINT sz = sizeof(SC<SEG*>))
+	DBitSet(SegMgr * sm, UINT sz = sizeof(SC<SEG*>))
 	{
-		IS_TRUE(sm, ("need SEG_MGR"));
+		IS_TRUE(sm, ("need SegMgr"));
 		IS_TRUE(sz % sizeof(SC<SEG*>) == 0, ("pool size must be mulitple."));
 		m_is_sparse = true;
-		m_pool = smpool_create_handle(sz, MEM_CONST_SIZE);
+		m_pool = smpoolCreate(sz, MEM_CONST_SIZE);
 		m_sm = sm;
 		m_flst = NULL;
 	}
-	COPY_CONSTRUCTOR(DBITSET);
-	~DBITSET()
+	COPY_CONSTRUCTOR(DBitSet);
+	~DBitSet()
 	{
 		for (SC<SEG*> * st = segs.get_head(); 
 			 st != segs.end(); st = segs.get_next(st)) {
@@ -1066,101 +1001,103 @@ public:
 
 		//Unnecessary call clean(), since free pool will free all
 		//SC<SEG*> object.
-		//DBITSETC::clean(m_sm, &m_flst);
-		smpool_free_handle(m_pool);
+		//DBitSetCore::clean(m_sm, &m_flst);
+		smpoolDelete(m_pool);
 	}
 
-	void bunion(DBITSET const& src)
-	{ DBITSETC::bunion(src, m_sm, &m_flst, m_pool);	}
+	void bunion(DBitSet const& src)
+	{ DBitSetCore::bunion(src, m_sm, &m_flst, m_pool);	}
 
 	void bunion(UINT elem)
-	{ DBITSETC::bunion(elem, m_sm, &m_flst, m_pool);	}
+	{ DBitSetCore::bunion(elem, m_sm, &m_flst, m_pool);	}
 
-	void copy(DBITSET const& src)
-	{ DBITSETC::copy(src, m_sm, &m_flst, m_pool); }
+	void copy(DBitSet const& src)
+	{ DBitSetCore::copy(src, m_sm, &m_flst, m_pool); }
 
 	UINT count_mem() const
 	{
 		UINT count = sizeof(m_pool);
 		count += sizeof(m_flst);
 		count += sizeof(m_sm);
-		count += smpool_get_pool_size_handle(m_pool);
-		count += DBITSETC::count_mem();
+		count += smpoolGetPoolSize(m_pool);
+		count += DBitSetCore::count_mem();
 		return count;
 	}
 
 	void clean()
-	{ DBITSETC::clean(m_sm, &m_flst); }
+	{ DBitSetCore::clean(m_sm, &m_flst); }
 
 	void diff(UINT elem)
-	{ DBITSETC::diff(elem, m_sm, &m_flst); }
+	{ DBitSetCore::diff(elem, m_sm, &m_flst); }
 
-	void diff(DBITSET const& src)
-	{ DBITSETC::diff(src, m_sm, &m_flst); }
+	void diff(DBitSet const& src)
+	{ DBitSetCore::diff(src, m_sm, &m_flst); }
 
-	void intersect(DBITSET const& src)
-	{ DBITSETC::intersect(src, m_sm, &m_flst); }
+	void intersect(DBitSet const& src)
+	{ DBitSetCore::intersect(src, m_sm, &m_flst); }
 };
 
 
-#define SDBITSET_MGR_sc_free_list(sbs)		((sbs)->scflst)
-class SDBITSET_MGR
+//This class represent a BitSet Manager that is response for creating
+//and destory dense bitset, sparse bitset and dual bitset.
+#define MiscBitSetMgr_sc_free_list(sbs)		((sbs)->scflst)
+class MiscBitSetMgr
 {
 protected:
-	SLIST<SBITSET*> m_sbitset_list;
-	SLIST<DBITSET*> m_dbitset_list;
-	SLIST<DBITSETC*> m_dbitsetc_list;
-	SLIST<SBITSETC*> m_free_sbitsetc_list;	
-	SLIST<SBITSET*> m_free_sbitset_list;
-	SLIST<DBITSET*> m_free_dbitset_list;
-	SLIST<DBITSETC*> m_free_dbitsetc_list;
+	SList<SBitSet*> m_sbitset_list;
+	SList<DBitSet*> m_dbitset_list;
+	SList<DBitSetCore*> m_dbitsetc_list;
+	SList<SBitSetCore*> m_free_sbitsetc_list;	
+	SList<SBitSet*> m_free_sbitset_list;
+	SList<DBitSet*> m_free_dbitset_list;
+	SList<DBitSetCore*> m_free_dbitsetc_list;
 	
-	SMEM_POOL * m_sbitsetc_pool;
-	SMEM_POOL * m_dbitsetc_pool;
+	SMemPool * m_sbitsetc_pool;
+	SMemPool * m_dbitsetc_pool;
 	
 protected:
-	SBITSETC * xmalloc_sbitsetc()
+	SBitSetCore * xmalloc_sbitsetc()
 	{
 		IS_TRUE(m_sbitsetc_pool, ("not yet initialized."));
-		SBITSETC * p = (SBITSETC*)smpool_malloc_h_const_size(sizeof(SBITSETC), 
+		SBitSetCore * p = (SBitSetCore*)smpoolMallocConstSize(sizeof(SBitSetCore), 
 															m_sbitsetc_pool);
 		IS_TRUE(p, ("malloc failed"));
-		memset(p, 0, sizeof(SBITSETC));
+		memset(p, 0, sizeof(SBitSetCore));
 		return p;
 	}
 
-	DBITSETC * xmalloc_dbitsetc()
+	DBitSetCore * xmalloc_dbitsetc()
 	{
 		IS_TRUE(m_dbitsetc_pool, ("not yet initialized."));
-		DBITSETC * p = (DBITSETC*)smpool_malloc_h_const_size(sizeof(DBITSETC), 
+		DBitSetCore * p = (DBitSetCore*)smpoolMallocConstSize(sizeof(DBitSetCore), 
 															m_dbitsetc_pool);
 		IS_TRUE(p, ("malloc failed"));
-		memset(p, 0, sizeof(DBITSETC));
+		memset(p, 0, sizeof(DBitSetCore));
 		return p;
 	}
 public:
 	//SEG manager.
-	SEG_MGR sm;
+	SegMgr sm;
 
 	//Free list of SC<SEG*> container. It will be allocated in ptr_pool.
 	SC<SEG*> * scflst; 
 	
-	SMEM_POOL * ptr_pool; //only used to allocate SC<SEG*>.
+	SMemPool * ptr_pool; //only used to allocate SC<SEG*>.
 
 public:
-	SDBITSET_MGR() { ptr_pool = NULL; init(); }
-	COPY_CONSTRUCTOR(SDBITSET_MGR);
-	~SDBITSET_MGR() { destroy(); }
+	MiscBitSetMgr() { ptr_pool = NULL; init(); }
+	COPY_CONSTRUCTOR(MiscBitSetMgr);
+	~MiscBitSetMgr() { destroy(); }
 
 	void init()
 	{
 		if (ptr_pool != NULL) { return; }
 
-		ptr_pool = smpool_create_handle(sizeof(SC<SEG*>) * 10,
+		ptr_pool = smpoolCreate(sizeof(SC<SEG*>) * 10,
 										MEM_CONST_SIZE);
-		m_sbitsetc_pool = smpool_create_handle(sizeof(SBITSETC) * 10,
+		m_sbitsetc_pool = smpoolCreate(sizeof(SBitSetCore) * 10,
 										 MEM_CONST_SIZE);
-		m_dbitsetc_pool = smpool_create_handle(sizeof(DBITSETC) * 10,
+		m_dbitsetc_pool = smpoolCreate(sizeof(DBitSetCore) * 10,
 										 MEM_CONST_SIZE);
 		
 		m_sbitset_list.set_pool(ptr_pool);
@@ -1179,31 +1116,31 @@ public:
 	{
 		if (ptr_pool == NULL) { return; }
 
-		for (SC<SBITSET*> * st = m_sbitset_list.get_head();
+		for (SC<SBitSet*> * st = m_sbitset_list.get_head();
 			 st != m_sbitset_list.end(); st = m_sbitset_list.get_next(st)) {
-			SBITSET * s = st->val();
+			SBitSet * s = st->val();
 			IS_TRUE0(s);
 			delete s;
 		}
 		
-		for (SC<DBITSET*> * dt = m_dbitset_list.get_head();
+		for (SC<DBitSet*> * dt = m_dbitset_list.get_head();
 			 dt != m_dbitset_list.end(); dt = m_dbitset_list.get_next(dt)) {
-			DBITSET * d = dt->val(); 
+			DBitSet * d = dt->val(); 
 			IS_TRUE0(d);
 			delete d;
 		}
 		
-		//All DBITSETC and SBITSETC are allocated in the pool.
+		//All DBitSetCore and SBitSetCore are allocated in the pool.
 		//It is not necessary to destroy it specially.
-		//SC<DBITSETC*> * dct;
-		//for (DBITSETC * d = m_dbitsetc_list.get_head(&dct);
+		//SC<DBitSetCore*> * dct;
+		//for (DBitSetCore * d = m_dbitsetc_list.get_head(&dct);
 		//	 d != NULL; d = m_dbitsetc_list.get_next(&dct)) {
 		//	delete d;
 		//}
 
-		smpool_free_handle(m_sbitsetc_pool);
-		smpool_free_handle(m_dbitsetc_pool);
-		smpool_free_handle(ptr_pool);
+		smpoolDelete(m_sbitsetc_pool);
+		smpoolDelete(m_dbitsetc_pool);
+		smpoolDelete(ptr_pool);
 		
 		ptr_pool = NULL;
 		m_sbitsetc_pool = NULL;
@@ -1211,38 +1148,38 @@ public:
 		scflst = NULL;
 	}
 	
-	inline SBITSET * create_sbitset()
+	inline SBitSet * create_sbitset()
 	{
-		SBITSET * p = m_free_sbitset_list.remove_head();
+		SBitSet * p = m_free_sbitset_list.remove_head();
 		if (p == NULL) {
-			p = new SBITSET(&sm);
+			p = new SBitSet(&sm);
 			m_sbitset_list.append_head(p);
 		}
 		return p;
 	}
 
-	inline SBITSETC * create_sbitsetc()
+	inline SBitSetCore * create_sbitsetc()
 	{
-		SBITSETC * p = m_free_sbitsetc_list.remove_head();
+		SBitSetCore * p = m_free_sbitsetc_list.remove_head();
 		if (p == NULL) {
 			p = xmalloc_sbitsetc();
 		}
 		return p;
 	}
 
-	inline DBITSET * create_dbitset()
+	inline DBitSet * create_dbitset()
 	{
-		DBITSET * p = m_free_dbitset_list.remove_head();
+		DBitSet * p = m_free_dbitset_list.remove_head();
 		if (p == NULL) {
-			p = new DBITSET(&sm);
+			p = new DBitSet(&sm);
 			m_dbitset_list.append_head(p);
 		}
 		return p;
 	}
 
-	inline DBITSETC * create_dbitsetc()
+	inline DBitSetCore * create_dbitsetc()
 	{
-		DBITSETC * p = m_free_dbitsetc_list.remove_head();
+		DBitSetCore * p = m_free_dbitsetc_list.remove_head();
 		if (p == NULL) {
 			p = xmalloc_dbitsetc();
 			p->set_sparse(true);
@@ -1257,7 +1194,7 @@ public:
 	UINT count_mem(FILE * h = NULL) const;
 
 	//free bs for next use.
-	inline void free_sbitset(SBITSET * bs)
+	inline void free_sbitset(SBitSet * bs)
 	{
 		if (bs == NULL) return;
 		bs->clean();
@@ -1265,7 +1202,7 @@ public:
 	}
 
 	//free bs for next use.
-	inline void free_sbitsetc(SBITSETC * bs)
+	inline void free_sbitsetc(SBitSetCore * bs)
 	{
 		if (bs == NULL) return;
 		bs->clean(*this);
@@ -1273,7 +1210,7 @@ public:
 	}
 
 	//free bs for next use.
-	inline void free_dbitset(DBITSET * bs)
+	inline void free_dbitset(DBitSet * bs)
 	{
 		if (bs == NULL) return;
 		bs->clean();
@@ -1281,7 +1218,7 @@ public:
 	}
 
 	//free bs for next use.
-	inline void free_dbitsetc(DBITSETC * bs)
+	inline void free_dbitsetc(DBitSetCore * bs)
 	{
 		if (bs == NULL) return;
 		bs->clean(&sm, &scflst);
@@ -1289,8 +1226,8 @@ public:
 	}
 
 	//This function destroy SEG objects and free containers back to
-	//SDBITSET_MGR for next use.
-	inline void destroy_seg_and_freedc(DBITSETC * bs)
+	//MiscBitSetMgr for next use.
+	inline void destroy_seg_and_freedc(DBitSetCore * bs)
 	{
 		if (bs == NULL) { return; }
 		bs->destroy_seg_and_clean(&sm, &scflst);
@@ -1299,107 +1236,107 @@ public:
 		m_free_dbitsetc_list.append_head(bs);
 	}
 
-	//Get SEG_MGR.
-	inline SEG_MGR * get_seg_mgr() { return &sm; }
+	//Get SegMgr.
+	inline SegMgr * get_seg_mgr() { return &sm; }
 };
-//END SDBITSET_MGR
+//END MiscBitSetMgr
 
 
 
 //
-//START SBITSETC
+//START SBitSetCore
 //
-void SBITSETC::bunion(UINT elem, SDBITSET_MGR & m)
+void SBitSetCore::bunion(UINT elem, MiscBitSetMgr & m)
 {
 	bunion(elem, &m.sm, &m.scflst, m.ptr_pool);
 }
 
 
-void SBITSETC::bunion(SBITSETC const& src, SDBITSET_MGR &m)
+void SBitSetCore::bunion(SBitSetCore const& src, MiscBitSetMgr &m)
 {
 	bunion(src, &m.sm, &m.scflst, m.ptr_pool);
 }
 
 
-void SBITSETC::copy(SBITSETC const& src, SDBITSET_MGR & m)
+void SBitSetCore::copy(SBitSetCore const& src, MiscBitSetMgr & m)
 {
 	copy(src, &m.sm, &m.scflst, m.ptr_pool);
 }
 
 
-void SBITSETC::clean(SDBITSET_MGR & m)
+void SBitSetCore::clean(MiscBitSetMgr & m)
 {
 	clean(&m.sm, &m.scflst);
 }
 
 
-void SBITSETC::diff(UINT elem, SDBITSET_MGR & m)
+void SBitSetCore::diff(UINT elem, MiscBitSetMgr & m)
 {
 	diff(elem, &m.sm, &m.scflst);
 }
 
 
-void SBITSETC::diff(SBITSETC const& src, SDBITSET_MGR & m)
+void SBitSetCore::diff(SBitSetCore const& src, MiscBitSetMgr & m)
 {
 	diff(src, &m.sm, &m.scflst);
 }
 
 
-void SBITSETC::intersect(SBITSETC const& src, SDBITSET_MGR & m)
+void SBitSetCore::intersect(SBitSetCore const& src, MiscBitSetMgr & m)
 {
 	intersect(src, &m.sm, &m.scflst);
 }
-//END SBITSETC
+//END SBitSetCore
 
 
 //
-//START DBITSETC
+//START DBitSetCore
 //
-void DBITSETC::bunion(DBITSETC const& src, SDBITSET_MGR & m)
+void DBitSetCore::bunion(DBitSetCore const& src, MiscBitSetMgr & m)
 {
 	bunion(src, &m.sm, &m.scflst, m.ptr_pool);
 }
 
 
-void DBITSETC::bunion(UINT elem, SDBITSET_MGR & m)
+void DBitSetCore::bunion(UINT elem, MiscBitSetMgr & m)
 {
 	bunion(elem, &m.sm, &m.scflst, m.ptr_pool);
 }
 
 
-void DBITSETC::copy(DBITSETC const& src, SDBITSET_MGR & m)
+void DBitSetCore::copy(DBitSetCore const& src, MiscBitSetMgr & m)
 {
 	copy(src, &m.sm, &m.scflst, m.ptr_pool);
 }
 
 
-void DBITSETC::diff(UINT elem, SDBITSET_MGR & m)
+void DBitSetCore::diff(UINT elem, MiscBitSetMgr & m)
 {
 	diff(elem, &m.sm, &m.scflst);
 }
 
 
-void DBITSETC::diff(DBITSETC const& src, SDBITSET_MGR & m)
+void DBitSetCore::diff(DBitSetCore const& src, MiscBitSetMgr & m)
 {
 	diff(src, &m.sm, &m.scflst);
 }
 
 
-void DBITSETC::intersect(DBITSETC const& src, SDBITSET_MGR & m)
+void DBitSetCore::intersect(DBitSetCore const& src, MiscBitSetMgr & m)
 {
 	intersect(src, &m.sm, &m.scflst);
 }
-//END DBITSETC
+//END DBitSetCore
 
 extern BYTE const g_bit_count[];
-extern inline BITSET * bs_create(BITSET_MGR & bs_mgr)
+extern inline BitSet * bs_create(BitSetMgr & bs_mgr)
 {
 	return bs_mgr.create();
 }
-extern BITSET * bs_union(IN BITSET const& set1, IN BITSET const& set2,
-						OUT BITSET & res);
-extern BITSET * bs_diff(IN BITSET const& set1, IN BITSET const& set2,
-						OUT BITSET & res);
-extern BITSET * bs_intersect(IN BITSET const& set1, IN BITSET const& set2,
-						OUT BITSET & res);
+extern BitSet * bs_union(IN BitSet const& set1, IN BitSet const& set2,
+						OUT BitSet & res);
+extern BitSet * bs_diff(IN BitSet const& set1, IN BitSet const& set2,
+						OUT BitSet & res);
+extern BitSet * bs_intersect(IN BitSet const& set1, IN BitSet const& set2,
+						OUT BitSet & res);
 #endif
diff --git a/src/com/comf.cpp b/src/com/comf.cpp
index cf529f4..06d61e2 100644
--- a/src/com/comf.cpp
+++ b/src/com/comf.cpp
@@ -245,7 +245,7 @@ INT slcm(INT x, INT y)
 }
 
 
-INT gcdm(UINT num, SVECTOR<INT, 8> const& a)
+INT gcdm(UINT num, Vector<INT, 8> const& a)
 {
 	if (num == 0) {
 		return 0;
@@ -529,8 +529,8 @@ UCHAR * xltoa(LONG v, OUT UCHAR * buf)
 
 static void _prim(INT m, INT n, OUT INT * buf, UINT i)
 {
-	if(m > n){
-		while(m % n != 0) n++;
+	if (m > n) {
+		while (m % n != 0) { n++; }
 		m = m / n; //Factorize 'm' to two composite-number.
 		buf[i++] = n;
 		_prim(m, n, buf, i);
@@ -549,22 +549,26 @@ void prim(INT m, OUT INT * buf)
 		sign = true;
 		m = -m;
 	}
+	
 	_prim(m, 2, buf, 0);
+	
 	if (sign) {
 		buf[0] = -buf[0];
 	}
 }
 
 
-//Dumpf() for SVECTOR<TY>.
+//Dumpf() for Vector<TY>.
 void dumpf_svec(void * vec, UINT ty, CHAR const* name, bool is_del)
 {
-	if (!name) {
+	if (name == NULL) {
 		name = "matrix.tmp";
 	}
+	
 	if (is_del) {
 		unlink(name);
 	}
+	
 	static INT g_count = 0;
 	FILE * h = fopen(name, "a+");
 	IS_TRUE(h, ("%s create failed!!!", name));
@@ -574,7 +578,7 @@ void dumpf_svec(void * vec, UINT ty, CHAR const* name, bool is_del)
 	switch (ty) {
 	case D_BOOL:
 		{
-			SVECTOR<bool> *p = (SVECTOR<bool> *)vec;
+			Vector<bool> *p = (Vector<bool> *)vec;
 			for (INT i = 0; i <= p->get_last_idx(); i++) {
 				fprintf(h, "%d", (INT)p->get(i));
 				if (i != p->get_last_idx()) {
@@ -585,7 +589,7 @@ void dumpf_svec(void * vec, UINT ty, CHAR const* name, bool is_del)
 		}
 	case D_INT:
 		{
-			SVECTOR<INT> *p = (SVECTOR<INT> *)vec;
+			Vector<INT> *p = (Vector<INT> *)vec;
 			for (INT i = 0; i <= p->get_last_idx(); i++) {
 				fprintf(h, "%d", (INT)p->get(i));
 				if (i != p->get_last_idx()) {
@@ -605,14 +609,14 @@ void dumpf_svec(void * vec, UINT ty, CHAR const* name, bool is_del)
 }
 
 
-//Dumps() for SVECTOR<TY>.
+//Dumps() for Vector<TY>.
 void dumps_svec(void * vec, UINT ty)
 {
 	printf("\n");
 	switch (ty) {
 	case D_BOOL:
 		{
-			SVECTOR<bool> *p = (SVECTOR<bool> *)vec;
+			Vector<bool> *p = (Vector<bool> *)vec;
 			for (INT i = 0; i <= p->get_last_idx(); i++) {
 				printf("%d", (INT)p->get(i));
 				if (i != p->get_last_idx()) {
@@ -623,7 +627,7 @@ void dumps_svec(void * vec, UINT ty)
 		}
 	case D_INT:
 		{
-			SVECTOR<INT> *p = (SVECTOR<INT> *)vec;
+			Vector<INT> *p = (Vector<INT> *)vec;
 			for (INT i = 0; i <= p->get_last_idx(); i++) {
 				printf("%d", (INT)p->get(i));
 				if (i != p->get_last_idx()) {
@@ -693,7 +697,6 @@ UINT get_sparse_popcount(ULONGLONG v)
 //Compute the number of 1.
 UINT get_lookup_popcount(ULONGLONG v)
 {
-	IS_TRUE0((BYTE)-1 == 255);
 	BYTE * p = (BYTE*)&v;
 	return g_bit_count[p[0]] + g_bit_count[p[1]] +
 		   g_bit_count[p[2]] + g_bit_count[p[3]] +
@@ -888,7 +891,7 @@ UINT xstrlen(CHAR const* p)
 //Return true if equal.
 bool xstrcmp(CHAR const* p1, CHAR const* p2, INT n)
 {
-	while (n-- > 0 && *p1++ == *p2++);
+	while (n-- > 0 && *p1++ == *p2++) { }
 	if (n >= 0) return true;
 	return false;
 }
diff --git a/src/com/comf.h b/src/com/comf.h
index 90424ff..3f41830 100644
--- a/src/com/comf.h
+++ b/src/com/comf.h
@@ -68,7 +68,7 @@ e.g:
 e.g:
 	START_TIMER();
 	Run mypass();
-	END_TIMER_FMT(("My Pass Name%s", get_opt_name())); */
+	END_TIMER_FMT(("My Pass Name%s", get_pass_name())); */
 #define START_TIMER_FMT()  			\
 	LONG _start_time_count_ = 0;	\
 	if (g_show_comp_time) {			\
@@ -120,7 +120,7 @@ template <typename T> void dummy_use(T const&) {}
 #endif
 
 
-template <class T, UINT GROW_SIZE> class SVECTOR;
+template <class T, UINT GrowSize> class Vector;
 
 UINT arra(UINT n, UINT m); //Arrangement
 void af2i(IN CHAR * f, OUT BYTE * buf, INT buflen, bool is_double);
@@ -139,7 +139,7 @@ UINT fact(UINT n);
 INT findstr(CHAR * src, CHAR * s);
 
 INT gcdm(UINT num, ...);
-INT gcdm(UINT num, SVECTOR<INT, 8> const& a);
+INT gcdm(UINT num, Vector<INT, 8> const& a);
 
 //Compute the nearest power of 2 that not less than v.
 inline UINT get_nearest_power_of_2(UINT v)
diff --git a/src/com/flty.cpp b/src/com/flty.cpp
index 15e42f6..29d5b30 100644
--- a/src/com/flty.cpp
+++ b/src/com/flty.cpp
@@ -30,7 +30,7 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "flty.h"
 #include "math.h"
 
-bool operator == (FLTY const& a, FLTY const& b)
+bool operator == (Float const& a, Float const& b)
 {
 	PRECISION_TYPE av = a.m_f;
 	PRECISION_TYPE bv = b.m_f;
@@ -50,7 +50,7 @@ bool operator == (FLTY const& a, FLTY const& b)
 }
 
 
-bool operator < (FLTY const& a, FLTY const& b)
+bool operator < (Float const& a, Float const& b)
 {
 	if (a.m_f < b.m_f) {
 		return true;
@@ -59,7 +59,7 @@ bool operator < (FLTY const& a, FLTY const& b)
 }
 
 
-bool operator <= (FLTY const& a, FLTY const& b)
+bool operator <= (Float const& a, Float const& b)
 {
 	if (a.m_f < b.m_f || a == b) {
 		return true;
@@ -68,7 +68,7 @@ bool operator <= (FLTY const& a, FLTY const& b)
 }
 
 
-bool operator > (FLTY const& a, FLTY const& b)
+bool operator > (Float const& a, Float const& b)
 {
 	if (a.m_f > b.m_f) {
 		return true;
@@ -77,7 +77,7 @@ bool operator > (FLTY const& a, FLTY const& b)
 }
 
 
-bool operator >= (FLTY const& a, FLTY const& b)
+bool operator >= (Float const& a, Float const& b)
 {
 	if (a.m_f > b.m_f || a == b) {
 		return true;
@@ -86,37 +86,37 @@ bool operator >= (FLTY const& a, FLTY const& b)
 }
 
 
-FLTY operator * (FLTY const& a, FLTY const& b)
+Float operator * (Float const& a, Float const& b)
 {
-	//return FLTY(integralize(integralize(a.m_f) * integralize(b.m_f)));
-	return FLTY(a.m_f * b.m_f);
+	//return Float(integralize(integralize(a.m_f) * integralize(b.m_f)));
+	return Float(a.m_f * b.m_f);
 }
 
 
-FLTY operator / (FLTY const& a, FLTY const& b)
+Float operator / (Float const& a, Float const& b)
 {
-	//return FLTY(integralize(integralize(a.m_f) / integralize(b.m_f)));
-	return FLTY(a.m_f / b.m_f);
+	//return Float(integralize(integralize(a.m_f) / integralize(b.m_f)));
+	return Float(a.m_f / b.m_f);
 }
 
 
-FLTY operator + (FLTY const& a, FLTY const& b)
+Float operator + (Float const& a, Float const& b)
 {
-	//return FLTY(integralize(integralize(a.m_f) + integralize(b.m_f)));
-	return FLTY(a.m_f + b.m_f);
+	//return Float(integralize(integralize(a.m_f) + integralize(b.m_f)));
+	return Float(a.m_f + b.m_f);
 }
 
 
 //Subtration operation
-FLTY operator - (FLTY const& a, FLTY const& b)
+Float operator - (Float const& a, Float const& b)
 {
-	//return FLTY(integralize(integralize(a.m_f) - integralize(b.m_f)));
-	return FLTY(a.m_f - b.m_f);
+	//return Float(integralize(integralize(a.m_f) - integralize(b.m_f)));
+	return Float(a.m_f - b.m_f);
 }
 
 
 //Minus operation
-FLTY operator - (FLTY a)
+Float operator - (Float a)
 {
 	a.m_f = -(a.m_f);
 	return a;
@@ -124,14 +124,14 @@ FLTY operator - (FLTY a)
 
 
 //Zerolization.
-FLTY zerolinz(FLTY const& a)
+Float zerolinz(Float const& a)
 {
 	PRECISION_TYPE v = a.m_f;
 	if (v < 0) {
 		v = -v;
 	}
 	if (v <= INFINITESIMAL) {
-		return FLTY(0);
+		return Float(0);
 	}
 	return a;
 }
@@ -164,14 +164,14 @@ PRECISION_TYPE integralize(PRECISION_TYPE const& a)
 }
 
 
-CHAR * FLTY::format(CHAR * buf)
+CHAR * Float::format(CHAR * buf)
 {
 	sprintf(buf, "%f", m_f);
 	return buf;
 }
 
 
-bool FLTY::is_int()
+bool Float::is_int()
 {
 	PRECISION_TYPE av = m_f;
 	if (av < 0) {
diff --git a/src/com/flty.h b/src/com/flty.h
index f7ff7bb..bd2309e 100644
--- a/src/com/flty.h
+++ b/src/com/flty.h
@@ -36,40 +36,40 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #define PRECISION_TYPE	double
 #define INFINITESIMAL 0.00000000000000001
-class FLTY {
-	friend FLTY zerolinz(FLTY const& a);
-	friend bool operator == (FLTY const& a, FLTY const& b);
-	friend bool operator != (FLTY const& a, FLTY const& b);
-	friend bool operator < (FLTY const& a, FLTY const& b);
-	friend bool operator <= (FLTY const& a, FLTY const& b);
-	friend bool operator > (FLTY const& a, FLTY const& b);
-	friend bool operator >= (FLTY const& a, FLTY const& b);
-	friend FLTY operator * (FLTY const& a, FLTY const& b);
-	friend FLTY operator / (FLTY const& a, FLTY const& b);
-	friend FLTY operator + (FLTY const& a, FLTY const& b);
-	friend FLTY operator - (FLTY const& a, FLTY const& b);
-	friend FLTY operator - (FLTY a);
+class Float {
+	friend Float zerolinz(Float const& a);
+	friend bool operator == (Float const& a, Float const& b);
+	friend bool operator != (Float const& a, Float const& b);
+	friend bool operator < (Float const& a, Float const& b);
+	friend bool operator <= (Float const& a, Float const& b);
+	friend bool operator > (Float const& a, Float const& b);
+	friend bool operator >= (Float const& a, Float const& b);
+	friend Float operator * (Float const& a, Float const& b);
+	friend Float operator / (Float const& a, Float const& b);
+	friend Float operator + (Float const& a, Float const& b);
+	friend Float operator - (Float const& a, Float const& b);
+	friend Float operator - (Float a);
 protected:
 	PRECISION_TYPE m_f;
 public:
-	FLTY()
+	Float()
 	{
 		m_f = PRECISION_TYPE(0);
 	}
 
-	FLTY(FLTY const& f)
+	Float(Float const& f)
 	{
 		//Sometimes, r need not to initialize always.
 		//IS_TRUE(r.m_den != 0, ("denominator is 0!"));
 		m_f = f.m_f;
 	}
 
-	FLTY(PRECISION_TYPE f)
+	Float(PRECISION_TYPE f)
 	{
 		m_f = f;
 	}
 
-	FLTY & operator = (FLTY const& a)
+	Float & operator = (Float const& a)
 	{
 		m_f = a.m_f;
 		return *this;
@@ -90,18 +90,18 @@ public:
 
 
 //Exported Functions
-bool operator == (FLTY const& a, FLTY const& b);
-bool operator != (FLTY const& a, FLTY const& b);
-inline bool operator != (FLTY const& a, FLTY const& b) { return !(a == b); }
-bool operator < (FLTY const& a, FLTY const& b);
-bool operator <= (FLTY const& a, FLTY const& b);
-bool operator > (FLTY const& a, FLTY const& b);
-bool operator >= (FLTY const& a, FLTY const& b);
-FLTY operator * (FLTY const& a, FLTY const& b);
-FLTY operator / (FLTY const& a, FLTY const& b);
-FLTY operator + (FLTY const& a, FLTY const& b);
-FLTY operator - (FLTY const& a, FLTY const& b);
-FLTY operator - (FLTY a);
+bool operator == (Float const& a, Float const& b);
+bool operator != (Float const& a, Float const& b);
+inline bool operator != (Float const& a, Float const& b) { return !(a == b); }
+bool operator < (Float const& a, Float const& b);
+bool operator <= (Float const& a, Float const& b);
+bool operator > (Float const& a, Float const& b);
+bool operator >= (Float const& a, Float const& b);
+Float operator * (Float const& a, Float const& b);
+Float operator / (Float const& a, Float const& b);
+Float operator + (Float const& a, Float const& b);
+Float operator - (Float const& a, Float const& b);
+Float operator - (Float a);
 PRECISION_TYPE integralize(PRECISION_TYPE const& a);
-FLTY zerolinz(FLTY const& a);
+Float zerolinz(Float const& a);
 #endif
diff --git a/src/com/ltype.h b/src/com/ltype.h
index 9603fea..1bc3fc7 100644
--- a/src/com/ltype.h
+++ b/src/com/ltype.h
@@ -108,6 +108,8 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 	#define IS_TRUEL0(a, filename, line)
 #endif
 
+#define UNREACH()  IS_TRUE(0, ("Unreachable."))
+
 #undef MAX
 #define MAX(a,b) ((a)>(b)?(a):(b))
 
@@ -153,7 +155,7 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MAX_BUF_LEN 1024
 #define MAX_LOC_BUF_LEN 512
 
-//Misc Dumps/Dumpf of SVECTOR<T>
+//Misc Dumps/Dumpf of Vector<T>
 #define D_BOOL			1
 #define D_INT			2
 
diff --git a/src/com/rational.cpp b/src/com/rational.cpp
index 48090ca..8296b47 100644
--- a/src/com/rational.cpp
+++ b/src/com/rational.cpp
@@ -32,14 +32,14 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define REDUCE
 #define abs(x) ((x) >= 0 ? (x) : -(x))
 
-RATIONAL::RATIONAL()
+Rational::Rational()
 {
 	m_num = 0;
 	m_den = 1;
 }
 
 
-RATIONAL::RATIONAL(RATIONAL const& r)
+Rational::Rational(Rational const& r)
 {
 	//Sometimes, r need not to initialize always.
 	//IS_TRUE(r.m_den != 0, ("denominator is 0!"));
@@ -48,14 +48,14 @@ RATIONAL::RATIONAL(RATIONAL const& r)
 }
 
 
-RATIONAL::RATIONAL(INT num, INT den)
+Rational::Rational(INT num, INT den)
 {
 	IS_TRUE(den != 0, ("denominator is 0!"));
 	m_num = num,  m_den = den;
 }
 
 
-RATIONAL & RATIONAL::operator = (RATIONAL const& a)
+Rational & Rational::operator = (Rational const& a)
 {
 	IS_TRUE(a.m_den != 0, ("denominator is 0!"));
 	m_num = a.m_num;
@@ -64,7 +64,7 @@ RATIONAL & RATIONAL::operator = (RATIONAL const& a)
 }
 
 
-void RATIONAL::reduce()
+void Rational::reduce()
 {
 	if (m_num == 0) {
 		m_den = 1;
@@ -88,10 +88,10 @@ void RATIONAL::reduce()
 }
 
 
-RATIONAL RATIONAL::rabs()
+Rational Rational::rabs()
 {
 	IS_TRUE(m_den != 0, ("denominator is 0!"));
-	RATIONAL b(*this);
+	Rational b(*this);
 	if (b.m_num < 0) {
 		b.m_num = -b.m_num;
 	}
@@ -102,7 +102,7 @@ RATIONAL RATIONAL::rabs()
 }
 
 
-FRAC_TYPE RATIONAL::_gcd(FRAC_TYPE x, FRAC_TYPE y)
+FRAC_TYPE Rational::_gcd(FRAC_TYPE x, FRAC_TYPE y)
 {
 	FRAC_TYPE t;
 	if (x < 0) { x = -x; }
@@ -119,7 +119,7 @@ FRAC_TYPE RATIONAL::_gcd(FRAC_TYPE x, FRAC_TYPE y)
 }
 
 
-CHAR * RATIONAL::format(CHAR * buf)
+CHAR * Rational::format(CHAR * buf)
 {
 	if (m_den == 1) {
 		sprintf(buf, "%d", m_num);
@@ -217,7 +217,7 @@ static inline void appro(LONGLONG & num, LONGLONG & den)
 }
 
 
-bool operator < (RATIONAL const& a, RATIONAL const& b)
+bool operator < (Rational const& a, Rational const& b)
 {
 	IS_TRUE(a.m_den != 0 && b.m_den != 0, ("denominator is 0!"));
 	if ((LONGLONG)a.m_num * (LONGLONG)b.m_den <
@@ -228,7 +228,7 @@ bool operator < (RATIONAL const& a, RATIONAL const& b)
 }
 
 
-bool operator <= (RATIONAL const& a, RATIONAL const& b)
+bool operator <= (Rational const& a, Rational const& b)
 {
 	IS_TRUE(a.m_den != 0 && b.m_den != 0, ("denominator is 0!"));
 	if (((LONGLONG)(a.m_num) * (LONGLONG)(b.m_den)) <=
@@ -239,7 +239,7 @@ bool operator <= (RATIONAL const& a, RATIONAL const& b)
 }
 
 
-bool operator > (RATIONAL const& a, RATIONAL const& b)
+bool operator > (Rational const& a, Rational const& b)
 {
 	IS_TRUE(a.m_den != 0 && b.m_den != 0, ("denominator is 0!"));
 	if (((LONGLONG)(a.m_num) * (LONGLONG)(b.m_den)) >
@@ -250,7 +250,7 @@ bool operator > (RATIONAL const& a, RATIONAL const& b)
 }
 
 
-bool operator >= (RATIONAL const& a, RATIONAL const& b)
+bool operator >= (Rational const& a, Rational const& b)
 {
 	IS_TRUE(a.m_den != 0 && b.m_den != 0, ("denominator is 0!"));
 	if (((LONGLONG)(a.m_num) * (LONGLONG)(b.m_den)) >=
@@ -261,11 +261,11 @@ bool operator >= (RATIONAL const& a, RATIONAL const& b)
 }
 
 
-RATIONAL operator * (RATIONAL const& a, RATIONAL const& b)
+Rational operator * (Rational const& a, Rational const& b)
 {
 	IS_TRUE(a.m_den != 0 && b.m_den != 0, ("denominator is 0!"));
 	LONGLONG rnum = (LONGLONG)(a.m_num) * (LONGLONG)(b.m_num);
-	RATIONAL rat;
+	Rational rat;
 	if (rnum == 0) {
 		rat.m_num = 0;
 		rat.m_den = 1;
@@ -300,7 +300,7 @@ RATIONAL operator * (RATIONAL const& a, RATIONAL const& b)
 }
 
 
-RATIONAL operator / (RATIONAL const& a, RATIONAL const& b)
+Rational operator / (Rational const& a, Rational const& b)
 {
 	FRAC_TYPE anum = a.m_num;
 	FRAC_TYPE aden = a.m_den;
@@ -310,7 +310,7 @@ RATIONAL operator / (RATIONAL const& a, RATIONAL const& b)
 	IS_TRUE(aden != 0 && bden != 0, ("denominator is 0"));
 	IS_TRUE(bnum != 0, ("'a' divided by 0"));
 
-	RATIONAL rat;
+	Rational rat;
 	if (anum == 0) { rat.m_num = 0; rat.m_den = 1; return rat; }
 	if (anum == aden) {
 		if (bnum < 0) {
@@ -351,10 +351,10 @@ RATIONAL operator / (RATIONAL const& a, RATIONAL const& b)
 }
 
 
-RATIONAL operator + (RATIONAL const& a, RATIONAL const& b)
+Rational operator + (Rational const& a, Rational const& b)
 {
 	IS_TRUE(a.m_den != 0 && b.m_den != 0, ("denominator is 0!"));
-	RATIONAL rat;
+	Rational rat;
 	LONGLONG rnum = (LONGLONG)(a.m_num) * (LONGLONG)(b.m_den) +
 					(LONGLONG)(a.m_den) * (LONGLONG)(b.m_num);
 	if (rnum == 0) {
diff --git a/src/com/rational.h b/src/com/rational.h
index 016022e..dfd2426 100644
--- a/src/com/rational.h
+++ b/src/com/rational.h
@@ -30,32 +30,32 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define __RATIONAL_H__
 
 #define FRAC_TYPE INT
-class RATIONAL {
-	friend bool operator != (RATIONAL const& a, RATIONAL const& b);
-	friend bool operator == (RATIONAL const& a, RATIONAL const& b);
-	friend bool operator < (RATIONAL const& a, RATIONAL const& b);
-	friend bool operator <= (RATIONAL const& a, RATIONAL const& b);
-	friend bool operator > (RATIONAL const& a, RATIONAL const& b);
-	friend bool operator >= (RATIONAL const& a, RATIONAL const& b);
-	friend RATIONAL operator * (RATIONAL const& a, RATIONAL const& b);
-	friend RATIONAL operator / (RATIONAL const& a, RATIONAL const& b);
-	friend RATIONAL operator + (RATIONAL const& a, RATIONAL const& b);
-	friend RATIONAL operator - (RATIONAL const& a, RATIONAL const& b);
-	friend RATIONAL operator - (RATIONAL const& a);
+class Rational {
+	friend bool operator != (Rational const& a, Rational const& b);
+	friend bool operator == (Rational const& a, Rational const& b);
+	friend bool operator < (Rational const& a, Rational const& b);
+	friend bool operator <= (Rational const& a, Rational const& b);
+	friend bool operator > (Rational const& a, Rational const& b);
+	friend bool operator >= (Rational const& a, Rational const& b);
+	friend Rational operator * (Rational const& a, Rational const& b);
+	friend Rational operator / (Rational const& a, Rational const& b);
+	friend Rational operator + (Rational const& a, Rational const& b);
+	friend Rational operator - (Rational const& a, Rational const& b);
+	friend Rational operator - (Rational const& a);
 
 	FRAC_TYPE m_num;
 	FRAC_TYPE m_den;
 
 	FRAC_TYPE _gcd(FRAC_TYPE x, FRAC_TYPE y);
 public:
-	RATIONAL();
-	RATIONAL(RATIONAL const& r);
-	RATIONAL(INT num, INT den = 1);
-	RATIONAL & operator = (RATIONAL const& a);
+	Rational();
+	Rational(Rational const& r);
+	Rational(INT num, INT den = 1);
+	Rational & operator = (Rational const& a);
 	inline INT typecast2int() { return m_num / m_den; }
 	inline bool is_int() { return m_den == 1; }
 	void reduce();
-	RATIONAL rabs();
+	Rational rabs();
 	FRAC_TYPE num() const {return m_num;}
 	FRAC_TYPE& num() {return m_num;}
 	FRAC_TYPE den() const {return m_den;}
@@ -70,27 +70,27 @@ public:
 
 
 //Exported Functions
-inline bool operator == (RATIONAL const& a, RATIONAL const& b)
+inline bool operator == (Rational const& a, Rational const& b)
 { return (a.m_num == b.m_num && a.m_den == b.m_den); }
-inline bool operator != (RATIONAL const& a, RATIONAL const& b)
+inline bool operator != (Rational const& a, Rational const& b)
 { return (a.m_num != b.m_num || a.m_den != b.m_den); }
-bool operator == (RATIONAL const& a, RATIONAL const& b);
-bool operator != (RATIONAL const& a, RATIONAL const& b);
-bool operator < (RATIONAL const& a, RATIONAL const& b);
-bool operator <= (RATIONAL const& a, RATIONAL const& b);
-bool operator > (RATIONAL const& a, RATIONAL const& b);
-bool operator >= (RATIONAL const& a, RATIONAL const& b);
-RATIONAL operator * (RATIONAL const& a, RATIONAL const& b);
-RATIONAL operator / (RATIONAL const& a, RATIONAL const& b);
-RATIONAL operator + (RATIONAL const& a, RATIONAL const& b);
-RATIONAL operator - (RATIONAL const& a, RATIONAL const& b);
-RATIONAL operator - (RATIONAL const& a);
+bool operator == (Rational const& a, Rational const& b);
+bool operator != (Rational const& a, Rational const& b);
+bool operator < (Rational const& a, Rational const& b);
+bool operator <= (Rational const& a, Rational const& b);
+bool operator > (Rational const& a, Rational const& b);
+bool operator >= (Rational const& a, Rational const& b);
+Rational operator * (Rational const& a, Rational const& b);
+Rational operator / (Rational const& a, Rational const& b);
+Rational operator + (Rational const& a, Rational const& b);
+Rational operator - (Rational const& a, Rational const& b);
+Rational operator - (Rational const& a);
 //Subtraction
-inline RATIONAL operator - (RATIONAL const& a, RATIONAL const& b) { return a + (-b); }
+inline Rational operator - (Rational const& a, Rational const& b) { return a + (-b); }
 //Minus
-inline RATIONAL operator - (RATIONAL const& a)
+inline Rational operator - (Rational const& a)
 {
-	RATIONAL b = a;
+	Rational b = a;
 	b.m_num = -b.m_num;
 	return b;
 }
diff --git a/src/com/sgraph.cpp b/src/com/sgraph.cpp
index 17deff0..06f84b0 100644
--- a/src/com/sgraph.cpp
+++ b/src/com/sgraph.cpp
@@ -36,22 +36,22 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define ALWAYS_VERTEX_UNIQUE
 
 //
-//START EDGE_HASH
+//START EdgeHash
 //
-EDGE * EDGE_HASH::create(OBJTY v)
+Edge * EdgeHash::create(OBJTY v)
 {
-	EDGE * t = (EDGE*)v;
-	VERTEX * from = m_g->get_vertex(VERTEX_id(EDGE_from(t)));
-	VERTEX * to = m_g->get_vertex(VERTEX_id(EDGE_to(t)));
+	Edge * t = (Edge*)v;
+	Vertex * from = m_g->get_vertex(VERTEX_id(EDGE_from(t)));
+	Vertex * to = m_g->get_vertex(VERTEX_id(EDGE_to(t)));
 	IS_TRUE0(from && to);
-	t = m_g->new_edge_impl(from, to);
+	t = m_g->newEdgeImpl(from, to);
 	return t;
 }
-//END EDGE_HASH
+//END EdgeHash
 
 
 //DONT CALL Constructor directly.
-GRAPH::GRAPH(UINT edge_hash_size, UINT vex_hash_size) :
+Graph::Graph(UINT edge_hash_size, UINT vex_hash_size) :
 	m_edges(edge_hash_size), m_vertices(vex_hash_size)
 {
 	m_edge_hash_size = edge_hash_size;
@@ -61,7 +61,7 @@ GRAPH::GRAPH(UINT edge_hash_size, UINT vex_hash_size) :
 }
 
 
-GRAPH::GRAPH(GRAPH const& g) :
+Graph::Graph(Graph const& g) :
 	m_edges(g.m_edge_hash_size), m_vertices(g.m_vex_hash_size)
 {
 	m_edge_hash_size = g.m_edge_hash_size;
@@ -72,17 +72,17 @@ GRAPH::GRAPH(GRAPH const& g) :
 }
 
 
-void GRAPH::init()
+void Graph::init()
 {
 	if (m_ec_pool != NULL) { return; }
 
-	m_ec_pool = smpool_create_handle(sizeof(EDGE_C), MEM_CONST_SIZE);
+	m_ec_pool = smpoolCreate(sizeof(EdgeC), MEM_CONST_SIZE);
 	IS_TRUE(m_ec_pool, ("create mem pool failed"));
 
-	m_vertex_pool = smpool_create_handle(sizeof(VERTEX) * 4, MEM_CONST_SIZE);
+	m_vertex_pool = smpoolCreate(sizeof(Vertex) * 4, MEM_CONST_SIZE);
 	IS_TRUE(m_vertex_pool, ("create mem pool failed"));
 
-	m_edge_pool = smpool_create_handle(sizeof(EDGE) * 4, MEM_CONST_SIZE);
+	m_edge_pool = smpoolCreate(sizeof(Edge) * 4, MEM_CONST_SIZE);
 	IS_TRUE(m_edge_pool, ("create mem pool failed"));
 
 	//If m_edges already initialized, this call will do nothing.
@@ -100,7 +100,7 @@ void GRAPH::init()
 'vertex_hash_sz': new vertex table size to be resized.
 'edge_hash_sz': new edge table size to be resized.
 NOTE: mem pool should have been initialized. */
-void GRAPH::resize(UINT vertex_hash_sz, UINT edge_hash_sz)
+void Graph::resize(UINT vertex_hash_sz, UINT edge_hash_sz)
 {
 	IS_TRUE0(m_ec_pool);
 	IS_TRUE(m_vertices.get_elem_count() == 0, ("graph is not empty"));
@@ -120,7 +120,7 @@ void GRAPH::resize(UINT vertex_hash_sz, UINT edge_hash_sz)
 }
 
 
-UINT GRAPH::count_mem() const
+UINT Graph::count_mem() const
 {
 	UINT count = 0;
 	count += sizeof(BYTE);
@@ -131,9 +131,9 @@ UINT GRAPH::count_mem() const
 	count += m_e_free_list.count_mem();
 	count += m_el_free_list.count_mem();
 	count += m_v_free_list.count_mem();
-	count += smpool_get_pool_size_handle(m_ec_pool);
-	count += smpool_get_pool_size_handle(m_vertex_pool);
-	count += smpool_get_pool_size_handle(m_edge_pool);
+	count += smpoolGetPoolSize(m_ec_pool);
+	count += smpoolGetPoolSize(m_vertex_pool);
+	count += smpoolGetPoolSize(m_edge_pool);
 	if (m_dense_vertex != NULL) {
 		count += m_dense_vertex->count_mem();
 	}
@@ -141,7 +141,7 @@ UINT GRAPH::count_mem() const
 }
 
 
-void GRAPH::destroy()
+void Graph::destroy()
 {
 	if (m_ec_pool == NULL) return;
 	m_edges.destroy();
@@ -154,13 +154,13 @@ void GRAPH::destroy()
 	m_el_free_list.clean(); //edge-list free list
 	m_v_free_list.clean(); //vertex free list
 
-	smpool_free_handle(m_ec_pool);
+	smpoolDelete(m_ec_pool);
 	m_ec_pool = NULL;
 
-	smpool_free_handle(m_vertex_pool);
+	smpoolDelete(m_vertex_pool);
 	m_vertex_pool = NULL;
 
-	smpool_free_handle(m_edge_pool);
+	smpoolDelete(m_edge_pool);
 	m_edge_pool = NULL;
 
 	if (m_dense_vertex != NULL) {
@@ -172,20 +172,20 @@ void GRAPH::destroy()
 
 //Erasing graph, include all nodes and edges,
 //except for mempool, freelist.
-void GRAPH::erase()
+void Graph::erase()
 {
 	IS_TRUE(m_ec_pool != NULL, ("Graph must be initialized before clone."));
 	//Collect edge, vertex data structure into free-list
 	//for allocation on demand.
 	INT c;
-	for (VERTEX * v = m_vertices.get_first(c);
+	for (Vertex * v = m_vertices.get_first(c);
 		 v != NULL; v = m_vertices.get_next(c)) {
-		 remove_vertex(v);
+		 removeVertex(v);
 	}
 	#ifdef _DEBUG_
 	if (m_dense_vertex != NULL) {
 		for (INT i = 0; i <= m_dense_vertex->get_last_idx(); i++) {
-			//Should be removed in remove_vertex().
+			//Should be removed in removeVertex().
 			IS_TRUE0(m_dense_vertex->get((UINT)i) == NULL);
 		}
 	}
@@ -196,20 +196,20 @@ void GRAPH::erase()
 /* Sort vertice by rporder, and update rpo of vertex.
 Record sorted vertex into vlst in incremental order of rpo.
 NOTE: rpo start at 1, and 0 means undefined. */
-void GRAPH::compute_rpo_norec(VERTEX * root, OUT LIST<VERTEX const*> & vlst)
+void Graph::computeRpoNoRecursive(Vertex * root, OUT List<Vertex const*> & vlst)
 {
 	IS_TRUE0(root && is_graph_entry(root));
-	BITSET is_visited;
-	SSTACK<VERTEX*> stk;
+	BitSet is_visited;
+	Stack<Vertex*> stk;
 	stk.push(root);
-	VERTEX * v;
+	Vertex * v;
 	UINT order = get_vertex_num();
 	while ((v = stk.get_top()) != NULL) {
 		is_visited.bunion(VERTEX_id(v));
-		EDGE_C * el = VERTEX_out_list(v);
+		EdgeC * el = VERTEX_out_list(v);
 		bool find = false; //find unvisited kid.
 		while (el != NULL) {
-			VERTEX * succ = EDGE_to(EC_edge(el));
+			Vertex * succ = EDGE_to(EC_edge(el));
 			if (!is_visited.is_contain(VERTEX_id(succ))) {
 				stk.push(succ);
 				find = true;
@@ -227,7 +227,7 @@ void GRAPH::compute_rpo_norec(VERTEX * root, OUT LIST<VERTEX const*> & vlst)
 }
 
 
-bool GRAPH::clone(GRAPH const& src)
+bool Graph::clone(Graph const& src)
 {
 	erase();
 	m_is_unique = src.m_is_unique;
@@ -235,23 +235,23 @@ bool GRAPH::clone(GRAPH const& src)
 
 	//Clone vertices
 	INT c;
-	for (VERTEX * srcv = src.get_first_vertex(c);
+	for (Vertex * srcv = src.get_first_vertex(c);
 		 srcv != NULL; srcv = src.get_next_vertex(c)) {
-		VERTEX * v = add_vertex(VERTEX_id(srcv));
+		Vertex * v = addVertex(VERTEX_id(srcv));
 
 		/*
 		Calls inherited class method.
 		Vertex info of memory should allocated by inherited class method
 		*/
 		if (VERTEX_info(srcv) != NULL) {
-			VERTEX_info(v) = clone_vertex_info(srcv);
+			VERTEX_info(v) = cloneVertexInfo(srcv);
 		}
 	}
 
 	//Clone edges
-	for (EDGE * srce = src.get_first_edge(c);
+	for (Edge * srce = src.get_first_edge(c);
 		 srce != NULL; srce = src.get_next_edge(c)) {
-		EDGE * e = add_edge(VERTEX_id(EDGE_from(srce)),
+		Edge * e = addEdge(VERTEX_id(EDGE_from(srce)),
 							VERTEX_id(EDGE_to(srce)));
 
 		/*
@@ -259,7 +259,7 @@ bool GRAPH::clone(GRAPH const& src)
 		Edge info of memory should allocated by inherited class method
 		*/
 		if (EDGE_info(srce) != NULL) {
-			EDGE_info(e) = clone_edge_info(srce);
+			EDGE_info(e) = cloneEdgeInfo(srce);
 		}
 	}
 	return true;
@@ -267,18 +267,18 @@ bool GRAPH::clone(GRAPH const& src)
 
 
 //NOTE: Do NOT use 0 as vertex id.
-VERTEX * GRAPH::new_vertex(UINT vid)
+Vertex * Graph::newVertex(UINT vid)
 {
 	IS_TRUE(m_vertex_pool, ("not yet initialized."));
 	IS_TRUE(vid != 0, ("Do not use 0 as vertex id"));
 
-	VERTEX * vex = NULL;
+	Vertex * vex = NULL;
 
 	#ifndef ALWAYS_VERTEX_UNIQUE
 	if (m_is_unique)
 	#endif
 	{
-		VERTEX * v = m_vertices.find((OBJTY)(size_t)vid);
+		Vertex * v = m_vertices.find((OBJTY)(size_t)vid);
 		if (v != NULL) {
 			return v;
 		}
@@ -286,7 +286,7 @@ VERTEX * GRAPH::new_vertex(UINT vid)
 
 	vex = m_v_free_list.get_free_elem();
 	if (vex == NULL) {
-		vex = new_vertex();
+		vex = newVertex();
 	}
 	VERTEX_id(vex) = vid;
 
@@ -298,12 +298,12 @@ VERTEX * GRAPH::new_vertex(UINT vid)
 }
 
 
-EDGE * GRAPH::new_edge(VERTEX * from, VERTEX * to)
+Edge * Graph::newEdge(Vertex * from, Vertex * to)
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	if (from == NULL || to == NULL) return NULL;
-	EDGE teste;
-	VERTEX testfrom, testto;
+	Edge teste;
+	Vertex testfrom, testto;
 	if (m_is_unique) {
 		VERTEX_id(&testfrom) = VERTEX_id(from);
 		VERTEX_id(&testto) = VERTEX_id(to);
@@ -313,7 +313,7 @@ EDGE * GRAPH::new_edge(VERTEX * from, VERTEX * to)
 			return m_edges.append((OBJTY)&teste, NULL);
 		}
 
-		EDGE * e = NULL;
+		Edge * e = NULL;
 		if (m_edges.find(&teste, &e)) {
 			IS_TRUE0(e);
 			return e;
@@ -324,38 +324,38 @@ EDGE * GRAPH::new_edge(VERTEX * from, VERTEX * to)
 		EDGE_to(&teste) = &testfrom;
 		return m_edges.append((OBJTY)&teste, NULL);
 	}
-	return m_edges.append(new_edge_impl(from, to));
+	return m_edges.append(newEdgeImpl(from, to));
 }
 
 
 //Reverse edge direction
-EDGE * GRAPH::rev_edge(EDGE * e)
+Edge * Graph::reverseEdge(Edge * e)
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	IS_TRUE(m_is_direction, ("graph is indirection"));
 	void * einfo = EDGE_info(e);
-	VERTEX * from = EDGE_from(e);
-	VERTEX * to = EDGE_to(e);
-	remove_edge(e);
-	e = add_edge(VERTEX_id(to), VERTEX_id(from));
+	Vertex * from = EDGE_from(e);
+	Vertex * to = EDGE_to(e);
+	removeEdge(e);
+	e = addEdge(VERTEX_id(to), VERTEX_id(from));
 	EDGE_info(e) = einfo;
 	return e;
 }
 
 
 //Reverse all edge direction
-void GRAPH::rev_edges()
+void Graph::reverseEdges()
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	IS_TRUE(m_is_direction, ("graph is indirection"));
-	LIST<EDGE*> list;
-	EDGE * e;
+	List<Edge*> list;
+	Edge * e;
 	INT c;
 	for (e = get_first_edge(c); e != NULL; e = get_next_edge(c)) {
 		list.append_tail(e);
 	}
 	for (e = list.get_head(); e != NULL; e = list.get_next()) {
-		rev_edge(e);
+		reverseEdge(e);
 	}
 }
 
@@ -365,14 +365,14 @@ Insert 'newv' between 'v1' and 'v2'.
 e.g: given edge v1->v2, the result is v1->newv->v2.
 Return edge v1->newv, newv->v2.
 */
-void GRAPH::insert_vertex_between(IN VERTEX * v1, IN VERTEX * v2,
-								  IN VERTEX * newv, OUT EDGE ** e1,
-								  OUT EDGE ** e2)
+void Graph::insertVertexBetween(IN Vertex * v1, IN Vertex * v2,
+								  IN Vertex * newv, OUT Edge ** e1,
+								  OUT Edge ** e2)
 {
-	EDGE * e = get_edge(v1, v2);
-	remove_edge(e);
-	EDGE * tmpe1 = add_edge(v1, newv);
-	EDGE * tmpe2 = add_edge(newv, v2);
+	Edge * e = get_edge(v1, v2);
+	removeEdge(e);
+	Edge * tmpe1 = addEdge(v1, newv);
+	Edge * tmpe2 = addEdge(newv, v2);
 	if (e1 != NULL) *e1 = tmpe1;
 	if (e2 != NULL) *e2 = tmpe2;
 }
@@ -385,26 +385,26 @@ Return edge v1->newv, newv->v2.
 
 NOTICE: newv must be node in graph.
 */
-void GRAPH::insert_vertex_between(UINT v1, UINT v2, UINT newv,
-								OUT EDGE ** e1, OUT EDGE ** e2)
+void Graph::insertVertexBetween(UINT v1, UINT v2, UINT newv,
+								OUT Edge ** e1, OUT Edge ** e2)
 {
-	VERTEX * pv1 = get_vertex(v1);
-	VERTEX * pv2 = get_vertex(v2);
-	VERTEX * pnewv = get_vertex(newv);
+	Vertex * pv1 = get_vertex(v1);
+	Vertex * pv2 = get_vertex(v2);
+	Vertex * pnewv = get_vertex(newv);
 	IS_TRUE0(pv1 != NULL && pv2 != NULL && pnewv != NULL);
-	insert_vertex_between(pv1, pv2, pnewv, e1, e2);
+	insertVertexBetween(pv1, pv2, pnewv, e1, e2);
 }
 
 
-EDGE * GRAPH::remove_edge(EDGE * e)
+Edge * Graph::removeEdge(Edge * e)
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	if (e == NULL) return NULL;
-	VERTEX * from = EDGE_from(e);
-	VERTEX * to = EDGE_to(e);
+	Vertex * from = EDGE_from(e);
+	Vertex * to = EDGE_to(e);
 
 	//remove out of out-list of 'from'
-	EDGE_C * el = VERTEX_out_list(from);
+	EdgeC * el = VERTEX_out_list(from);
 	while (el != NULL) {
 		if (EC_edge(el) == e) {	break; }
 		el = EC_next(el);
@@ -430,24 +430,24 @@ EDGE * GRAPH::remove_edge(EDGE * e)
 }
 
 
-VERTEX * GRAPH::remove_vertex(VERTEX * vex)
+Vertex * Graph::removeVertex(Vertex * vex)
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	if (vex == NULL) return NULL;
-	EDGE_C * el = VERTEX_out_list(vex);
+	EdgeC * el = VERTEX_out_list(vex);
 	//remove all out-edge
 	while (el != NULL) {
-		EDGE_C * tmp = el;
+		EdgeC * tmp = el;
 		el = EC_next(el);
-		remove_edge(EC_edge(tmp));
+		removeEdge(EC_edge(tmp));
 	}
 
 	//remove all in-edge
 	el = VERTEX_in_list(vex);
 	while (el != NULL) {
-		EDGE_C * tmp = el;
+		EdgeC * tmp = el;
 		el = EC_next(el);
-		remove_edge(EC_edge(tmp));
+		removeEdge(EC_edge(tmp));
 	}
 	vex = m_vertices.removed(vex);
 	m_v_free_list.add_free_elem(vex);
@@ -465,16 +465,16 @@ Return false if 'vid' is not on graph.
 'ni_list': record the neighbours of 'vid'.
 	Note that this function ensure each neighbours in ni_list is unique.
 */
-bool GRAPH::get_neighbor_list(OUT LIST<UINT> & ni_list, UINT vid) const
+bool Graph::get_neighbor_list(OUT List<UINT> & ni_list, UINT vid) const
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	
-	//Ensure VERTEX_HASH::find is readonly.
-	GRAPH * pthis = const_cast<GRAPH*>(this);
-	VERTEX * vex  = pthis->get_vertex(vid);
+	//Ensure VertexHash::find is readonly.
+	Graph * pthis = const_cast<Graph*>(this);
+	Vertex * vex  = pthis->get_vertex(vid);
 	if (vex == NULL) { return false; }
 
-	EDGE_C * el = VERTEX_in_list(vex);
+	EdgeC * el = VERTEX_in_list(vex);
 	while (el != NULL) {
 		UINT v = VERTEX_id(EDGE_from(EC_edge(el)));
 		if (!ni_list.find(v)) {
@@ -503,15 +503,15 @@ Return false if 'vid' is not on graph.
 	Note that this function ensure each neighbours in niset is unique.
 	Using sparse bitset is faster than list in most cases.
 */
-bool GRAPH::get_neighbor_set(OUT SBITSET & niset, UINT vid) const
+bool Graph::get_neighbor_set(OUT SBitSet & niset, UINT vid) const
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
-	//Ensure VERTEX_HASH::find is readonly.
-	GRAPH * pthis = const_cast<GRAPH*>(this);
-	VERTEX * vex  = pthis->get_vertex(vid);
+	//Ensure VertexHash::find is readonly.
+	Graph * pthis = const_cast<Graph*>(this);
+	Vertex * vex  = pthis->get_vertex(vid);
 	if (vex == NULL) { return false; }
 
-	EDGE_C * el = VERTEX_in_list(vex);
+	EdgeC * el = VERTEX_in_list(vex);
 	while (el != NULL) {
 		UINT v = VERTEX_id(EDGE_from(EC_edge(el)));
 		niset.bunion(v);
@@ -528,7 +528,7 @@ bool GRAPH::get_neighbor_set(OUT SBITSET & niset, UINT vid) const
 }
 
 
-UINT GRAPH::get_degree(VERTEX const* vex) const
+UINT Graph::get_degree(Vertex const* vex) const
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	if (vex == NULL) return 0;
@@ -536,12 +536,12 @@ UINT GRAPH::get_degree(VERTEX const* vex) const
 }
 
 
-UINT GRAPH::get_in_degree(VERTEX const* vex) const
+UINT Graph::get_in_degree(Vertex const* vex) const
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	if (vex == NULL) { return 0; }
 	UINT degree = 0;
-	EDGE_C * el = VERTEX_in_list(vex);
+	EdgeC * el = VERTEX_in_list(vex);
 	while (el != NULL) {
 		degree++;
 		el = EC_next(el);
@@ -550,13 +550,13 @@ UINT GRAPH::get_in_degree(VERTEX const* vex) const
 }
 
 
-UINT GRAPH::get_out_degree(VERTEX const* vex) const
+UINT Graph::get_out_degree(Vertex const* vex) const
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	if (vex == NULL) { return 0; }
 
 	UINT degree = 0;
-	EDGE_C * el = VERTEX_out_list(vex);
+	EdgeC * el = VERTEX_out_list(vex);
 	while (el != NULL) {
 		degree++;
 		el = EC_next(el);
@@ -565,14 +565,14 @@ UINT GRAPH::get_out_degree(VERTEX const* vex) const
 }
 
 
-EDGE * GRAPH::get_edge(VERTEX const* from, VERTEX const* to) const
+Edge * Graph::get_edge(Vertex const* from, Vertex const* to) const
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	if (from == NULL || to == NULL) { return NULL; }
 
-	EDGE_C * el = VERTEX_out_list(from);
+	EdgeC * el = VERTEX_out_list(from);
 	while (el != NULL) {
-		EDGE * e = EC_edge(el);
+		Edge * e = EC_edge(el);
 		if (EDGE_from(e) == from && EDGE_to(e) == to) {
 			return e;
 		}
@@ -584,9 +584,9 @@ EDGE * GRAPH::get_edge(VERTEX const* from, VERTEX const* to) const
 	}
 
 	if (!m_is_direction) {
-		EDGE_C * el = VERTEX_out_list(to);
+		EdgeC * el = VERTEX_out_list(to);
 		while (el != NULL) {
-			EDGE * e = EC_edge(el);
+			Edge * e = EC_edge(el);
 			if (EDGE_from(e) == to && EDGE_to(e) == from) {
 				return e;
 			}
@@ -597,34 +597,34 @@ EDGE * GRAPH::get_edge(VERTEX const* from, VERTEX const* to) const
 }
 
 
-EDGE * GRAPH::get_edge(UINT from, UINT to) const
+Edge * Graph::get_edge(UINT from, UINT to) const
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
-	VERTEX * fp = get_vertex(from);
-	VERTEX * tp = get_vertex(to);
+	Vertex * fp = get_vertex(from);
+	Vertex * tp = get_vertex(to);
 	return get_edge(fp, tp);
 }
 
 
-bool GRAPH::is_equal(GRAPH & g) const
+bool Graph::is_equal(Graph & g) const
 {
 	if (get_vertex_num() != g.get_vertex_num() ||
 		get_edge_num() != g.get_edge_num()) {
 		return false;
 	}
 
-	BITSET vs;
+	BitSet vs;
 	INT c;
-	for (VERTEX * v1 = get_first_vertex(c);
+	for (Vertex * v1 = get_first_vertex(c);
 		 v1 != NULL; v1 = get_next_vertex(c)) {
-		VERTEX * v2 = g.get_vertex(VERTEX_id(v1));
+		Vertex * v2 = g.get_vertex(VERTEX_id(v1));
 		if (v2 == NULL) {
 			return false;
 		}
 
 		vs.clean();
-		EDGE_C * el = VERTEX_out_list(v1);
-		EDGE * e = NULL;
+		EdgeC * el = VERTEX_out_list(v1);
+		Edge * e = NULL;
 		UINT v1_succ_n = 0;
 		if (el == NULL) {
 			if (VERTEX_out_list(v2) != NULL) {
@@ -658,18 +658,18 @@ bool GRAPH::is_equal(GRAPH & g) const
 
 
 //Is there exist a path connect 'from' and 'to'.
-bool GRAPH::is_reachable(VERTEX * from, VERTEX * to) const
+bool Graph::is_reachable(Vertex * from, Vertex * to) const
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	IS_TRUE(from != NULL && to != NULL, ("parameters cannot be NULL"));
-	EDGE_C * el = VERTEX_out_list(from);
-	EDGE * e = NULL;
+	EdgeC * el = VERTEX_out_list(from);
+	Edge * e = NULL;
 	if (el == NULL) { return false; }
 
 	//Walk through each succ of 'from'
 	for (e = EC_edge(el); e != NULL; el = EC_next(el),
 		 e = el ? EC_edge(el):NULL) {
-		VERTEX * succ = EDGE_to(e);
+		Vertex * succ = EDGE_to(e);
 		if (VERTEX_id(succ) == VERTEX_id(to)) {
 			return true;
 		} else {
@@ -688,24 +688,24 @@ Sort graph vertices in topological order.
 NOTE: current graph will be empty at function return.
 	If one need to keep the graph unchanged, clone graph
 	as a tmpgraph and operate on the tmpgraph.
-	e.g: GRAPH org;
+	e.g: Graph org;
 		And org must be unchanged,
-		GRAPH tmp(org);
-		tmp.sort_in_toplog_order(...)
+		Graph tmp(org);
+		tmp.sortInToplogOrder(...)
 */
-bool GRAPH::sort_in_toplog_order(OUT SVECTOR<UINT> & vex_vec, bool is_topdown)
+bool Graph::sortInToplogOrder(OUT Vector<UINT> & vex_vec, bool is_topdown)
 {
 	IS_TRUE(m_ec_pool != NULL, ("Graph still not yet initialize."));
 	if (get_vertex_num() == 0) {
 		return true;
 	}
-	LIST<VERTEX*> vlst;
+	List<Vertex*> vlst;
 	UINT pos = 0;
 	vex_vec.clean();
 	vex_vec.grow(get_vertex_num());
 	while (this->get_vertex_num() != 0) {
 		vlst.clean();
-		VERTEX * v;
+		Vertex * v;
 		INT c;
 		for (v = this->get_first_vertex(c);
 			 v != NULL; v = this->get_next_vertex(c)) {
@@ -724,7 +724,7 @@ bool GRAPH::sort_in_toplog_order(OUT SVECTOR<UINT> & vex_vec, bool is_topdown)
 		for (v = vlst.get_head(); v != NULL; v = vlst.get_next()) {
 			vex_vec.set(pos, VERTEX_id(v));
 			pos++;
-			this->remove_vertex(v);
+			this->removeVertex(v);
 		}
 	}
 	return true;
@@ -732,26 +732,26 @@ bool GRAPH::sort_in_toplog_order(OUT SVECTOR<UINT> & vex_vec, bool is_topdown)
 
 
 //Remove all edges between v1 and v2.
-void GRAPH::remove_edges_between(VERTEX * v1, VERTEX * v2)
+void Graph::removeEdgeBetween(Vertex * v1, Vertex * v2)
 {
-	EDGE_C * ec = VERTEX_out_list(v1);
+	EdgeC * ec = VERTEX_out_list(v1);
 	while (ec != NULL) {
-		EDGE_C * next = EC_next(ec);
-		EDGE * e = EC_edge(ec);
+		EdgeC * next = EC_next(ec);
+		Edge * e = EC_edge(ec);
 		if ((EDGE_from(e) == v1 && EDGE_to(e) == v2) ||
 			(EDGE_from(e) == v2 && EDGE_to(e) == v1)) {
-			remove_edge(e);
+			removeEdge(e);
 		}
 		ec = next;
 	}
 
 	ec = VERTEX_in_list(v1);
 	while (ec != NULL) {
-		EDGE_C * next = EC_next(ec);
-		EDGE * e = EC_edge(ec);
+		EdgeC * next = EC_next(ec);
+		Edge * e = EC_edge(ec);
 		if ((EDGE_from(e) == v1 && EDGE_to(e) == v2) ||
 			(EDGE_from(e) == v2 && EDGE_to(e) == v1)) {
-			remove_edge(e);
+			removeEdge(e);
 		}
 		ec = next;
 	}
@@ -781,12 +781,12 @@ Algo:
 		 If v1->v2 has been marked, we said v0->v2 is removable,
 		 and the same goes for the rest of edges.
 */
-void GRAPH::remove_transitive_edge()
+void Graph::removeTransitiveEdge()
 {
-	BITSET_MGR bs_mgr;
-	SVECTOR<UINT> vex_vec;
-	sort_in_toplog_order(vex_vec, true);
-	SVECTOR<UINT> vid2pos_in_bitset_map; //Map from VERTEX-ID to BITSET.
+	BitSetMgr bs_mgr;
+	Vector<UINT> vex_vec;
+	sortInToplogOrder(vex_vec, true);
+	Vector<UINT> vid2pos_in_bitset_map; //Map from Vertex-ID to BitSet.
 
 	//Mapping vertex id to its position in 'vex_vec'.
 	for (INT i = 0; i <= vex_vec.get_last_idx(); i++) {
@@ -794,14 +794,14 @@ void GRAPH::remove_transitive_edge()
 	}
 
 	//Associate each edges with indicator respective.
-	SVECTOR<BITSET*> edge_indicator; //container of bitset.
+	Vector<BitSet*> edge_indicator; //container of bitset.
 	INT c;
-	for (EDGE * e = m_edges.get_first(c); e != NULL; e = m_edges.get_next(c)) {
+	for (Edge * e = m_edges.get_first(c); e != NULL; e = m_edges.get_next(c)) {
 		UINT from = VERTEX_id(EDGE_from(e));
 		UINT to = VERTEX_id(EDGE_to(e));
 
 		UINT frompos = vid2pos_in_bitset_map.get(from);
-		BITSET * bs = edge_indicator.get(frompos);
+		BitSet * bs = edge_indicator.get(frompos);
 		if (bs == NULL) {
 			bs = bs_mgr.create();
 			edge_indicator.set(frompos, bs);
@@ -815,7 +815,7 @@ void GRAPH::remove_transitive_edge()
 	//Scanning vertices in topological order.
 	for (INT i = 0; i < vex_vec.get_last_idx(); i++) {
 		//Get the successor vector.
-		BITSET * bs = edge_indicator.get((UINT)i);
+		BitSet * bs = edge_indicator.get((UINT)i);
 		if (bs != NULL && bs->get_elem_count() >= 2) {
 			//Do NOT remove the first edge. Position in bitset
 			//has been sorted in topological order.
@@ -825,7 +825,7 @@ void GRAPH::remove_transitive_edge()
 				UINT kid_from_pos = vid2pos_in_bitset_map.get(kid_from_vid);
 
 				//Get bitset that 'pos_i' associated.
-				BITSET * kid_from_bs = edge_indicator.get(kid_from_pos);
+				BitSet * kid_from_bs = edge_indicator.get(kid_from_pos);
 				if (kid_from_bs != NULL) {
 					for (INT pos_j = bs->get_next((UINT)pos_i); pos_j >= 0;
 						 pos_j = bs->get_next((UINT)pos_j)) {
@@ -833,7 +833,7 @@ void GRAPH::remove_transitive_edge()
 							//The edge 'i->pos_j' is redundant.
 							UINT to_vid = vex_vec.get((UINT)pos_j);
 							UINT src_vid = vex_vec.get((UINT)i);
-							remove_edge(get_edge(src_vid, to_vid));
+							removeEdge(get_edge(src_vid, to_vid));
 							bs->diff((UINT)pos_j);
 						}
 					}
@@ -844,7 +844,7 @@ void GRAPH::remove_transitive_edge()
 }
 
 
-void GRAPH::dump_dot(CHAR const* name)
+void Graph::dump_dot(CHAR const* name)
 {
 	if (name == NULL) {
 		name = "graph.dot";
@@ -856,14 +856,14 @@ void GRAPH::dump_dot(CHAR const* name)
 	fprintf(h, "digraph G {\n");
 	//Print node
 	INT c;
-	for (VERTEX const* v = m_vertices.get_first(c);
+	for (Vertex const* v = m_vertices.get_first(c);
 		 v != NULL; v = m_vertices.get_next(c)) {
 		fprintf(h, "\nnode%d [shape = Mrecord, label=\"{BB%d}\"];",
 				VERTEX_id(v), VERTEX_id(v));
 	}
 
 	//Print edge
-	for (EDGE const* e = m_edges.get_first(c);
+	for (Edge const* e = m_edges.get_first(c);
 		 e != NULL; e = m_edges.get_next(c)) {
 		fprintf(h, "\nnode%d->node%d[label=\"%s\"]",
 					VERTEX_id(EDGE_from(e)),
@@ -875,7 +875,7 @@ void GRAPH::dump_dot(CHAR const* name)
 }
 
 
-void GRAPH::dump_vcg(CHAR const* name)
+void Graph::dump_vcg(CHAR const* name)
 {
 	IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 	if (name == NULL) {
@@ -885,7 +885,7 @@ void GRAPH::dump_vcg(CHAR const* name)
 	FILE * h = fopen(name, "a+");
 	IS_TRUE(h, ("%s create failed!!!",name));
 	fprintf(h, "graph: {"
-			  "title: \"GRAPH\"\n"
+			  "title: \"Graph\"\n"
 			  "shrink:  15\n"
 			  "stretch: 27\n"
 			  "layout_downfactor: 1\n"
@@ -921,7 +921,7 @@ void GRAPH::dump_vcg(CHAR const* name)
 
 	//Print node
 	INT c;
-	for (VERTEX const* v = m_vertices.get_first(c);
+	for (Vertex const* v = m_vertices.get_first(c);
 		 v != NULL; v = m_vertices.get_next(c)) {
 		fprintf(h, "\nnode: { title:\"%d\" label:\"%d\" "
 				"shape:circle fontname:\"courB\" color:gold}",
@@ -929,7 +929,7 @@ void GRAPH::dump_vcg(CHAR const* name)
 	}
 
 	//Print edge
-	for (EDGE const* e = m_edges.get_first(c);
+	for (Edge const* e = m_edges.get_first(c);
 		 e != NULL; e = m_edges.get_next(c)) {
 		fprintf(h, "\nedge: { sourcename:\"%d\" targetname:\"%d\" %s}",
 				VERTEX_id(EDGE_from(e)),
@@ -942,35 +942,35 @@ void GRAPH::dump_vcg(CHAR const* name)
 
 
 //
-//START DGRAPH
+//START DGraph
 //
-DGRAPH::DGRAPH(UINT edge_hash_size, UINT vex_hash_size) :
-	GRAPH(edge_hash_size, vex_hash_size)
+DGraph::DGraph(UINT edge_hash_size, UINT vex_hash_size) :
+	Graph(edge_hash_size, vex_hash_size)
 {
 	m_bs_mgr = NULL;
 }
 
 
-DGRAPH::DGRAPH(DGRAPH const& g) : GRAPH(g)
+DGraph::DGraph(DGraph const& g) : Graph(g)
 {
 	m_bs_mgr = g.m_bs_mgr;
 	if (m_bs_mgr != NULL) {
-		clone_bs(g);
+		cloneDomAndPdom(g);
 	}
 }
 
 
-bool DGRAPH::clone_bs(DGRAPH const& src)
+bool DGraph::cloneDomAndPdom(DGraph const& src)
 {
 	IS_TRUE0(m_bs_mgr != NULL);
 	INT c;
-	for (VERTEX * srcv = src.m_vertices.get_first(c);
+	for (Vertex * srcv = src.m_vertices.get_first(c);
 		 srcv != NULL; srcv = src.m_vertices.get_next(c)) {
 		UINT src_vid = VERTEX_id(srcv);
-		VERTEX * tgtv = get_vertex(src_vid);
+		Vertex * tgtv = get_vertex(src_vid);
 		IS_TRUE0(tgtv != NULL);
 
-		BITSET * set = src.get_dom_set_c(VERTEX_id(srcv));
+		BitSet * set = src.get_dom_set_c(VERTEX_id(srcv));
 		if (set != NULL) {
 			get_dom_set(tgtv)->copy(*set);
 		}
@@ -986,7 +986,7 @@ bool DGRAPH::clone_bs(DGRAPH const& src)
 }
 
 
-UINT DGRAPH::count_mem() const
+UINT DGraph::count_mem() const
 {
 	UINT count = 0;
 	count += m_dom_set.count_mem();
@@ -1003,30 +1003,30 @@ And we access them by reverse-topological order.
 'vlst': compute dominator for vertices in vlst if it
 	is not empty or else compute all graph.
 'uni': universe. */
-bool DGRAPH::compute_dom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
+bool DGraph::computeDom(List<Vertex const*> const* vlst, BitSet const* uni)
 {
-	LIST<VERTEX const*> tmpvlst;
-	LIST<VERTEX const*> * pvlst = &tmpvlst;
+	List<Vertex const*> tmpvlst;
+	List<Vertex const*> * pvlst = &tmpvlst;
 	if (vlst != NULL) {
 		//Here one must guarantee pvlst would not be modified.
-		pvlst = const_cast<LIST<VERTEX const*>*>(vlst);
+		pvlst = const_cast<List<Vertex const*>*>(vlst);
 	} else {
 		INT c;
-		for (VERTEX const* u = get_first_vertex(c);
+		for (Vertex const* u = get_first_vertex(c);
 			 u != NULL; u = get_next_vertex(c)) {
 			pvlst->append_tail(u);
 		}
 	}
 
-	BITSET const* luni = NULL;
+	BitSet const* luni = NULL;
 	if (uni != NULL) {
 		luni = uni;
 	} else {
-		BITSET * x = new BITSET();
-		C<VERTEX const*> * ct = NULL;
+		BitSet * x = new BitSet();
+		C<Vertex const*> * ct = NULL;
 		for (pvlst->get_head(&ct); 
 			 ct != pvlst->end(); ct = pvlst->get_next(ct)) {
-			VERTEX const* u = ct->val();
+			Vertex const* u = ct->val();
 			IS_TRUE0(u);
 			x->bunion(VERTEX_id(u));
 		}
@@ -1034,12 +1034,12 @@ bool DGRAPH::compute_dom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 	}
 
 	//Initialize dom-set for each BB.
-	C<VERTEX const*> * ct;
+	C<Vertex const*> * ct;
 	for (pvlst->get_head(&ct); ct != pvlst->end(); ct = pvlst->get_next(ct)) {
-		VERTEX const* v = ct->val();
+		Vertex const* v = ct->val();
 		IS_TRUE0(v);
 		if (is_graph_entry(v)) {
-			BITSET * dom = get_dom_set(v);
+			BitSet * dom = get_dom_set(v);
 			dom->clean();
 			dom->bunion(VERTEX_id(v));
 		} else {
@@ -1050,24 +1050,24 @@ bool DGRAPH::compute_dom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 	//DOM[entry] = {entry}
 	//DOM[n] = {n}  { (DOM[pred] of predecessor of 'n') }
 	bool change = true;
-	BITSET tmp;
+	BitSet tmp;
 	UINT count = 0;
 	while (change && count < 10) {
 		count++;
 		change = false;
-		C<VERTEX const*> * ct;
+		C<Vertex const*> * ct;
 		for (pvlst->get_head(&ct); 
 			 ct != pvlst->end(); ct = pvlst->get_next(ct)) {
-			VERTEX const* v = ct->val();
+			Vertex const* v = ct->val();
 			IS_TRUE0(v);
 			UINT vid = VERTEX_id(v);
 			if (is_graph_entry(v)) {
 				continue;
 			} else {
 				//Access each preds
-				EDGE_C * ec = VERTEX_in_list(v);
+				EdgeC * ec = VERTEX_in_list(v);
 				while (ec != NULL) {
-					VERTEX * pred = EDGE_from(EC_edge(ec));
+					Vertex * pred = EDGE_from(EC_edge(ec));
 					if (ec == VERTEX_in_list(v)) {
 						tmp.copy(*m_dom_set.get(VERTEX_id(pred)));
 					} else {
@@ -1077,7 +1077,7 @@ bool DGRAPH::compute_dom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 				}
 				tmp.bunion(vid);
 
-				BITSET * dom = m_dom_set.get(VERTEX_id(v));
+				BitSet * dom = m_dom_set.get(VERTEX_id(v));
 				if (!dom->is_equal(tmp)) {
 					dom->copy(tmp);
 					change = true;
@@ -1099,29 +1099,29 @@ And we access them by reverse-topological order.
 'vlst': compute dominator for vertices in vlst if it
 	is not empty or else compute all graph.
 'uni': universe. */
-bool DGRAPH::compute_dom3(LIST<VERTEX const*> const* vlst, BITSET const* uni)
+bool DGraph::computeDom3(List<Vertex const*> const* vlst, BitSet const* uni)
 {
 	UNUSED(uni);
-	LIST<VERTEX const*> tmpvlst;
-	LIST<VERTEX const*> * pvlst = &tmpvlst;
+	List<Vertex const*> tmpvlst;
+	List<Vertex const*> * pvlst = &tmpvlst;
 	if (vlst != NULL) {
 		//Here one must guarantee pvlst would not be modified.
-		pvlst = const_cast<LIST<VERTEX const*>*>(vlst);
+		pvlst = const_cast<List<Vertex const*>*>(vlst);
 	} else {
 		INT c;
-		for (VERTEX const* u = get_first_vertex(c);
+		for (Vertex const* u = get_first_vertex(c);
 			 u != NULL; u = get_next_vertex(c)) {
 			pvlst->append_tail(u);
 		}
 	}
 
 	//Initialize dom-set for each BB.
-	C<VERTEX const*> * ct;
+	C<Vertex const*> * ct;
 	for (pvlst->get_head(&ct); ct != pvlst->end(); ct = pvlst->get_next(ct)) {
-		VERTEX const* v = ct->val();
+		Vertex const* v = ct->val();
 		IS_TRUE0(v);
 		if (is_graph_entry(v)) {
-			BITSET * dom = get_dom_set(v);
+			BitSet * dom = get_dom_set(v);
 			dom->clean();
 			dom->bunion(VERTEX_id(v));
 		} else {
@@ -1132,26 +1132,26 @@ bool DGRAPH::compute_dom3(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 	//DOM[entry] = {entry}
 	//DOM[n] = {n}  { (DOM[pred] of predecessor of 'n') }
 	bool change = true;
-	BITSET tmp;
+	BitSet tmp;
 	UINT count = 0;
 	while (change && count < 10) {
 		count++;
 		change = false;
-		C<VERTEX const*> * ct;
+		C<Vertex const*> * ct;
 		for (pvlst->get_head(&ct); 
 			 ct != pvlst->end(); ct = pvlst->get_next(ct)) {
-			VERTEX const* v = ct->val();
+			Vertex const* v = ct->val();
 			IS_TRUE0(v);
 			UINT vid = VERTEX_id(v);
 			if (is_graph_entry(v)) {
 				continue;
 			} else {
 				//Access each preds
-				EDGE_C * ec = VERTEX_in_list(v);
+				EdgeC * ec = VERTEX_in_list(v);
 				UINT meet = 0;
 				while (ec != NULL) {
-					VERTEX * pred = EDGE_from(EC_edge(ec));
-					BITSET * ds = m_dom_set.get(VERTEX_id(pred));
+					Vertex * pred = EDGE_from(EC_edge(ec));
+					BitSet * ds = m_dom_set.get(VERTEX_id(pred));
 					if (ds->is_empty()) {
 						ec = EC_next(ec);
 						continue;
@@ -1169,7 +1169,7 @@ bool DGRAPH::compute_dom3(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 				if (meet == 0) { tmp.clean(); }
 				tmp.bunion(vid);
 
-				BITSET * dom = m_dom_set.get(VERTEX_id(v));
+				BitSet * dom = m_dom_set.get(VERTEX_id(v));
 				if (!dom->is_equal(tmp)) {
 					dom->copy(tmp);
 					change = true;
@@ -1188,17 +1188,17 @@ uni: universe.
 Note you should use this function carefully, it may be expensive, because that
 the function does not check if RPO is available, namely, it will always
 compute the RPO. */
-bool DGRAPH::compute_pdom_by_rpo(VERTEX * root, BITSET const* uni)
+bool DGraph::computePdomByRpo(Vertex * root, BitSet const* uni)
 {
-	LIST<VERTEX const*> vlst;
-	compute_rpo_norec(root, vlst);
+	List<Vertex const*> vlst;
+	computeRpoNoRecursive(root, vlst);
 	vlst.reverse();
 
 	bool res = false;
 	if (uni == NULL) {
-		res = compute_pdom(&vlst);
+		res = computePdom(&vlst);
 	} else {
-		res = compute_pdom(&vlst, uni);
+		res = computePdom(&vlst, uni);
 	}
 	CK_USE(res);
 	return true;
@@ -1207,17 +1207,17 @@ bool DGRAPH::compute_pdom_by_rpo(VERTEX * root, BITSET const* uni)
 
 //Vertices should have been sorted in topological order.
 //We access them by reverse-topological order.
-bool DGRAPH::compute_pdom(LIST<VERTEX const*> const* vlst)
+bool DGraph::computePdom(List<Vertex const*> const* vlst)
 {
 	IS_TRUE0(vlst);
-	BITSET uni;
-	C<VERTEX const*> * ct;
+	BitSet uni;
+	C<Vertex const*> * ct;
 	for (vlst->get_head(&ct); ct != vlst->end(); ct = vlst->get_next(ct)) {
-		VERTEX const* u = ct->val();
+		Vertex const* u = ct->val();
 		IS_TRUE0(u);
 		uni.bunion(VERTEX_id(u));
 	}
-	return compute_pdom(vlst, &uni);
+	return computePdom(vlst, &uni);
 }
 
 
@@ -1225,17 +1225,17 @@ bool DGRAPH::compute_pdom(LIST<VERTEX const*> const* vlst)
 And we access them by reverse-topological order.
 vlst: vertex list.
 uni: universe. */
-bool DGRAPH::compute_pdom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
+bool DGraph::computePdom(List<Vertex const*> const* vlst, BitSet const* uni)
 {
 	IS_TRUE0(vlst && uni);
 
 	//Initialize pdom for each bb
-	C<VERTEX const*> * ct;
+	C<Vertex const*> * ct;
 	for (vlst->get_head(&ct); ct != vlst->end(); ct = vlst->get_next(ct)) {
-		VERTEX const* v = ct->val();
+		Vertex const* v = ct->val();
 		IS_TRUE0(v);
 		if (is_graph_exit(v)) {
-			BITSET * pdom = get_pdom_set(v);
+			BitSet * pdom = get_pdom_set(v);
 			pdom->clean();
 			pdom->bunion(VERTEX_id(v));
 		} else {
@@ -1246,14 +1246,14 @@ bool DGRAPH::compute_pdom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 	//PDOM[exit] = {exit}
 	//PDOM[n] = {n} U {(PDOM[succ] of each succ of n)}
 	bool change = true;
-	BITSET tmp;
+	BitSet tmp;
 	UINT count = 0;
 	while (change && count < 10) {
 		count++;
 		change = false;
-		C<VERTEX const*> * ct;
+		C<Vertex const*> * ct;
 		for (vlst->get_head(&ct); ct != vlst->end(); ct = vlst->get_next(ct)) {
-			VERTEX const* v = ct->val();
+			Vertex const* v = ct->val();
 			IS_TRUE0(v);
 			UINT vid = VERTEX_id(v);
 			if (is_graph_exit(v)) {
@@ -1261,9 +1261,9 @@ bool DGRAPH::compute_pdom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 			} else {
 				tmp.clean();
 				//Access each succs
-				EDGE_C * ec = VERTEX_out_list(v);
+				EdgeC * ec = VERTEX_out_list(v);
 				while (ec != NULL) {
-					VERTEX * succ = EDGE_to(EC_edge(ec));
+					Vertex * succ = EDGE_to(EC_edge(ec));
 					if (ec == VERTEX_out_list(v)) {
 						tmp.copy(*m_pdom_set.get(VERTEX_id(succ)));
 					} else {
@@ -1273,7 +1273,7 @@ bool DGRAPH::compute_pdom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 				}
 				tmp.bunion(vid);
 
-				BITSET * pdom = m_pdom_set.get(VERTEX_id(v));
+				BitSet * pdom = m_pdom_set.get(VERTEX_id(v));
 				if (!pdom->is_equal(tmp)) {
 					pdom->copy(tmp);
 					change = true;
@@ -1289,20 +1289,20 @@ bool DGRAPH::compute_pdom(LIST<VERTEX const*> const* vlst, BITSET const* uni)
 
 //This function need idom to be avaiable.
 //NOTE: set does NOT include node itself.
-bool DGRAPH::compute_dom2(LIST<VERTEX const*> const& vlst)
+bool DGraph::computeDom2(List<Vertex const*> const& vlst)
 {
-	C<VERTEX const*> * ct;
-	BITSET avail;
+	C<Vertex const*> * ct;
+	BitSet avail;
 	for (vlst.get_head(&ct); ct != vlst.end(); ct = vlst.get_next(ct)) {
-		VERTEX const* v = ct->val();
+		Vertex const* v = ct->val();
 		IS_TRUE0(v);
-		BITSET * doms = get_dom_set(VERTEX_id(v));
+		BitSet * doms = get_dom_set(VERTEX_id(v));
 		doms->clean();
 		IS_TRUE0(doms);
 		for (UINT idom = get_idom(VERTEX_id(v));
 			 idom != 0; idom = get_idom(idom)) {
 			if (avail.is_contain(idom)) {
-				BITSET const* idom_doms = get_dom_set(idom);
+				BitSet const* idom_doms = get_dom_set(idom);
 				doms->copy(*idom_doms);
 				doms->bunion(idom);
 				break;
@@ -1323,7 +1323,7 @@ NOTE:
 	2. Do not use '0' as vertex id, it is used as Undefined.
 	3. Entry does not have idom.
 */
-bool DGRAPH::compute_idom2(LIST<VERTEX const*> const& vlst)
+bool DGraph::computeIdom2(List<Vertex const*> const& vlst)
 {
 	bool change = true;
 
@@ -1333,9 +1333,9 @@ bool DGRAPH::compute_idom2(LIST<VERTEX const*> const& vlst)
 	while (change) {
 		change = false;
 		//Access with topological order.
-		C<VERTEX const*> * ct;
+		C<Vertex const*> * ct;
 		for (vlst.get_head(&ct); ct != vlst.end(); ct = vlst.get_next(ct)) {
-			VERTEX const* v = ct->val();
+			Vertex const* v = ct->val();
 			IS_TRUE0(v);
 			if (is_graph_entry(v)) {
 				m_idom_set.set(VERTEX_id(v), (INT)VERTEX_id(v));
@@ -1344,10 +1344,10 @@ bool DGRAPH::compute_idom2(LIST<VERTEX const*> const& vlst)
 			}
 
 			//Access each preds
-			EDGE_C const* ec = VERTEX_in_list(v);
-			VERTEX const* idom = NULL;
+			EdgeC const* ec = VERTEX_in_list(v);
+			Vertex const* idom = NULL;
 			while (ec != NULL) {
-				VERTEX const* pred = EDGE_from(EC_edge(ec));
+				Vertex const* pred = EDGE_from(EC_edge(ec));
 				UINT pid = VERTEX_id(pred);
 
 				if (m_idom_set.get(pid) == 0) {
@@ -1361,8 +1361,8 @@ bool DGRAPH::compute_idom2(LIST<VERTEX const*> const& vlst)
 					continue;
 				}
 
-				VERTEX const* j = pred;
-				VERTEX const* k = idom;
+				Vertex const* j = pred;
+				Vertex const* k = idom;
 				while (j != k) {
 					while (VERTEX_rpo(j) > VERTEX_rpo(k)) {
 						j = get_vertex((UINT)m_idom_set.get(VERTEX_id(j)));
@@ -1406,9 +1406,9 @@ bool DGRAPH::compute_idom2(LIST<VERTEX const*> const& vlst)
 		} //end for
 	}
 
-	C<VERTEX const*> * ct;
+	C<Vertex const*> * ct;
 	for (vlst.get_head(&ct); ct != vlst.end(); ct = vlst.get_next(ct)) {
-		VERTEX const* v = ct->val();
+		Vertex const* v = ct->val();
 		IS_TRUE0(v);
 		if (is_graph_entry(v)) {
 			m_idom_set.set(VERTEX_id(v), 0);
@@ -1421,20 +1421,20 @@ bool DGRAPH::compute_idom2(LIST<VERTEX const*> const& vlst)
 
 
 //NOTE: Entry does not have idom.
-bool DGRAPH::compute_idom()
+bool DGraph::computeIdom()
 {
 	//Initialize idom-set for each BB.
 	m_idom_set.clean();
 
 	//Access with topological order.
 	INT c;
-	for (VERTEX * v = m_vertices.get_first(c);
+	for (Vertex * v = m_vertices.get_first(c);
 		 v != NULL; v = m_vertices.get_next(c)) {
 		UINT cur_id = VERTEX_id(v);
 		if (is_graph_entry(v)) {
 			continue;
 		} else if (m_dom_set.get(cur_id)->get_elem_count() >= 2) {
-			BITSET * p = m_dom_set.get(cur_id);
+			BitSet * p = m_dom_set.get(cur_id);
 			IS_TRUE(p != NULL, ("should compute dom first"));
 			if (p->get_elem_count() == 1) {
 				//There is no idom if 'dom' set only contain itself.
@@ -1481,20 +1481,20 @@ bool DGRAPH::compute_idom()
 
 
 //NOTE: Exit does not have idom.
-bool DGRAPH::compute_ipdom()
+bool DGraph::computeIpdom()
 {
 	//Initialize ipdom-set for each BB.
 	m_ipdom_set.clean();
 
 	//Processing in reverse-topological order.
 	INT c;
-	for (VERTEX const* v = m_vertices.get_last(c);
+	for (Vertex const* v = m_vertices.get_last(c);
 		 v != NULL; v = m_vertices.get_prev(c)) {
 		UINT cur_id = VERTEX_id(v);
 		if (is_graph_exit(v)) {
 			continue;
 		} else if (m_pdom_set.get(cur_id)->get_elem_count() > 1) {
-			BITSET * p = m_pdom_set.get(cur_id);
+			BitSet * p = m_pdom_set.get(cur_id);
 			IS_TRUE(p != NULL, ("should compute pdom first"));
 			if (p->get_elem_count() == 1) {
 				//There is no ipdom if 'pdom' set only contain itself.
@@ -1520,30 +1520,30 @@ bool DGRAPH::compute_ipdom()
 
 
 //'dom': output dominator tree.
-void DGRAPH::get_dom_tree(OUT GRAPH & dom)
+void DGraph::get_dom_tree(OUT Graph & dom)
 {
 	INT c;
-	for (VERTEX * v = m_vertices.get_first(c);
+	for (Vertex * v = m_vertices.get_first(c);
 		 v != NULL; v = m_vertices.get_next(c)) {
 		UINT vid = VERTEX_id(v);
-		dom.add_vertex(vid);
+		dom.addVertex(vid);
 		if (m_idom_set.get(vid) != 0) {
-			dom.add_edge((UINT)m_idom_set.get(vid), vid);
+			dom.addEdge((UINT)m_idom_set.get(vid), vid);
 		}
 	}
 }
 
 
 //'pdom': output post-dominator tree.
-void DGRAPH::get_pdom_tree(OUT GRAPH & pdom)
+void DGraph::get_pdom_tree(OUT Graph & pdom)
 {
 	INT c;
-	for (VERTEX * v = m_vertices.get_first(c);
+	for (Vertex * v = m_vertices.get_first(c);
 		 v != NULL; v = m_vertices.get_next(c)) {
 		UINT vid = VERTEX_id(v);
-		pdom.add_vertex(vid);
+		pdom.addVertex(vid);
 		if (m_ipdom_set.get(vid) != 0) { //id of bb starting at 1.
-			pdom.add_edge((UINT)m_ipdom_set.get(vid), vid);
+			pdom.addEdge((UINT)m_ipdom_set.get(vid), vid);
 		}
 	}
 }
@@ -1552,17 +1552,17 @@ void DGRAPH::get_pdom_tree(OUT GRAPH & pdom)
 /* Dump dom set, pdom set, idom, ipdom.
 'dump_dom_tree': set to be true to dump dominate
 	tree, and post dominate Tree. */
-void DGRAPH::dump_dom(FILE * h, bool dump_dom_tree)
+void DGraph::dump_dom(FILE * h, bool dump_dom_tree)
 {
 	if (h == NULL) return;
 	fprintf(h, "\n\n\n\n==---- DUMP DOM/PDOM/IDOM/IPDOM ----==");
 	INT c;
-	for (VERTEX * v = m_vertices.get_first(c);
+	for (Vertex * v = m_vertices.get_first(c);
 		 v != NULL; v = m_vertices.get_next(c)) {
 		UINT vid = VERTEX_id(v);
 		fprintf(h, "\nVERTEX(%d) dom: ", vid);
 		
-		BITSET * bs;
+		BitSet * bs;
 		if ((bs = m_dom_set.get(vid)) != NULL) {
 			for (INT id = bs->get_first(); 
 				 id != -1 ; id = bs->get_next((UINT)id)) {
@@ -1600,7 +1600,7 @@ void DGRAPH::dump_dom(FILE * h, bool dump_dom_tree)
 	fflush(h);
 
 	if (dump_dom_tree) {
-		GRAPH dom;
+		Graph dom;
 		get_dom_tree(dom);
 		dom.dump_vcg("graph_dom_tree.vcg");
 		dom.erase();
@@ -1610,16 +1610,16 @@ void DGRAPH::dump_dom(FILE * h, bool dump_dom_tree)
 }
 
 
-void DGRAPH::sort_dom_tree_in_preorder(IN VERTEX * root,
-									OUT LIST<VERTEX*> & lst)
+void DGraph::sortDomTreeInPreorder(IN Vertex * root,
+									OUT List<Vertex*> & lst)
 {
 	IS_TRUE0(root);
-	BITSET is_visited;
+	BitSet is_visited;
 	is_visited.bunion(VERTEX_id(root));
 	lst.append_tail(root);
 
-	VERTEX * v;
-	SSTACK<VERTEX*> stk;
+	Vertex * v;
+	Stack<Vertex*> stk;
 	stk.push(root);
 	while ((v = stk.pop()) != NULL) {
 		if (!is_visited.is_contain(VERTEX_id(v))) {
@@ -1630,8 +1630,8 @@ void DGRAPH::sort_dom_tree_in_preorder(IN VERTEX * root,
 		}
 
 		//Visit children.
-		EDGE_C * el = VERTEX_out_list(v);
-		VERTEX * succ;
+		EdgeC * el = VERTEX_out_list(v);
+		Vertex * succ;
 		while (el != NULL) {
 			succ = EDGE_to(EC_edge(el));
 			if (!is_visited.is_contain(VERTEX_id(succ))) {
@@ -1651,20 +1651,20 @@ void DGRAPH::sort_dom_tree_in_preorder(IN VERTEX * root,
 NOTE: BFS does NOT keep the sequence if you are going to
 access vertex in lexicographic order.
 */
-void DGRAPH::sort_in_bfs_order(SVECTOR<UINT> & order_buf, VERTEX * root,
-							   BITSET & visit)
+void DGraph::sortInBfsOrder(Vector<UINT> & order_buf, Vertex * root,
+							   BitSet & visit)
 {
-	LIST<VERTEX*> worklst;
+	List<Vertex*> worklst;
 	worklst.append_tail(root);
 	UINT order = 1;
 	while (worklst.get_elem_count() > 0) {
-		VERTEX * sv = worklst.remove_head();
+		Vertex * sv = worklst.remove_head();
 		order_buf.set(VERTEX_id(sv), order);
 		order++;
 		visit.bunion(VERTEX_id(sv));
-		EDGE_C * el = VERTEX_out_list(sv);
+		EdgeC * el = VERTEX_out_list(sv);
 		while (el != NULL) {
-			VERTEX * to = EDGE_to(EC_edge(el));
+			Vertex * to = EDGE_to(EC_edge(el));
 			if (visit.is_contain(VERTEX_id(to))) {
 				el = EC_next(el);
 				continue;
@@ -1676,21 +1676,21 @@ void DGRAPH::sort_in_bfs_order(SVECTOR<UINT> & order_buf, VERTEX * root,
 }
 
 
-void DGRAPH::sort_dom_tree_in_postorder(IN VERTEX * root,
-										OUT LIST<VERTEX*> & lst)
+void DGraph::sortDomTreeInPostrder(IN Vertex * root,
+										OUT List<Vertex*> & lst)
 {
 	IS_TRUE0(root);
-	BITSET is_visited;
+	BitSet is_visited;
 
 	//Find the leaf node.
-	VERTEX * v;
-	SSTACK<VERTEX*> stk;
+	Vertex * v;
+	Stack<Vertex*> stk;
 	stk.push(root);
 	while ((v = stk.pop()) != NULL) {
 		//Visit children first.
-		EDGE_C * el = VERTEX_out_list(v);
+		EdgeC * el = VERTEX_out_list(v);
 		bool find = false; //find unvisited kid.
-		VERTEX * succ;
+		Vertex * succ;
 		while (el != NULL) {
 			succ = EDGE_to(EC_edge(el));
 			if (!is_visited.is_contain(VERTEX_id(succ))) {
@@ -1710,39 +1710,37 @@ void DGRAPH::sort_dom_tree_in_postorder(IN VERTEX * root,
 }
 
 
-void DGRAPH::_remove_unreach_node(UINT id, BITSET & visited)
+void DGraph::_removeUnreachNode(UINT id, BitSet & visited)
 {
 	visited.bunion(id);
-	VERTEX * vex = get_vertex(id);
-	EDGE_C * el = VERTEX_out_list(vex);
+	Vertex * vex = get_vertex(id);
+	EdgeC * el = VERTEX_out_list(vex);
 	while (el != NULL) {
 		UINT succ = VERTEX_id(EDGE_to(EC_edge(el)));
 		if (!visited.is_contain(succ)) {
-			_remove_unreach_node(succ, visited);
+			_removeUnreachNode(succ, visited);
 		}
 		el = EC_next(el);
 	}
 }
 
 
-/*
-Perform DFS to seek for unreachable node.
-Return true if some nodes removed.
-*/
-bool DGRAPH::remove_unreach_node(UINT entry_id)
+//Perform DFS to seek for unreachable node.
+//Return true if some nodes removed.
+bool DGraph::removeUnreachNode(UINT entry_id)
 {
 	if (get_vertex_num() == 0) return false;
 	bool removed = false;
-	BITSET visited;
-	_remove_unreach_node(entry_id, visited);
+	BitSet visited;
+	_removeUnreachNode(entry_id, visited);
 	INT c;
-	for (VERTEX * v = get_first_vertex(c);
+	for (Vertex * v = get_first_vertex(c);
 		 v != NULL; v = get_next_vertex(c)) {
 		if (!visited.is_contain(VERTEX_id(v))) {
-			remove_vertex(v);
+			removeVertex(v);
 			removed = true;
 		}
 	}
 	return removed;
 }
-//END DGRAPH
+//END DGraph
diff --git a/src/com/sgraph.h b/src/com/sgraph.h
index c708788..174fe12 100644
--- a/src/com/sgraph.h
+++ b/src/com/sgraph.h
@@ -30,27 +30,27 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MAGIC_METHOD
 
-class VERTEX;
-class EDGE;
-class GRAPH;
+class Vertex;
+class Edge;
+class Graph;
 
 #define EDGE_next(e)		(e)->next
 #define EDGE_prev(e)		(e)->prev
 #define EDGE_from(e)		(e)->from
 #define EDGE_to(e)			(e)->to
 #define EDGE_info(e)		(e)->info
-class EDGE {
+class Edge {
 public:
-	EDGE()
+	Edge()
 	{
 		prev = next = NULL;
 		from = to = NULL;
 		info = NULL;
 	}
-	EDGE * prev; //used by FREE_LIST and EDGE_HASH
-	EDGE * next; //used by FREE_LIST and EDGE_HASH
-	VERTEX * from;
-	VERTEX * to;
+	Edge * prev; //used by FreeList and EdgeHash
+	Edge * next; //used by FreeList and EdgeHash
+	Vertex * from;
+	Vertex * to;
 	void * info;
 };
 
@@ -59,16 +59,16 @@ public:
 #define EC_next(el)		(el)->next
 #define EC_prev(el)		(el)->prev
 #define EC_edge(el)		(el)->edge
-class EDGE_C {
+class EdgeC {
 public:
-	EDGE_C()
+	EdgeC()
 	{
 		next = prev = NULL;
 		edge = NULL;
 	}
-	EDGE_C * next;
-	EDGE_C * prev;
-	EDGE * edge;
+	EdgeC * next;
+	EdgeC * prev;
+	Edge * edge;
 };
 
 
@@ -80,9 +80,9 @@ public:
 #define VERTEX_in_list(v)		(v)->in_list
 #define VERTEX_out_list(v)		(v)->out_list
 #define VERTEX_info(v)			(v)->info
-class VERTEX {
+class Vertex {
 public:
-	VERTEX()
+	Vertex()
 	{
 		prev = next = NULL;
 		in_list = out_list = NULL;
@@ -90,10 +90,10 @@ public:
 		id = 0;
 	}
 
-	VERTEX * prev; //used by FREE_LIST and HASH
-	VERTEX * next; //used by FREE_LIST and HASH
-	EDGE_C * in_list; //incoming edge list
-	EDGE_C * out_list;//outgoing edge list
+	Vertex * prev; //used by FreeList and HASH
+	Vertex * next; //used by FreeList and HASH
+	EdgeC * in_list; //incoming edge list
+	EdgeC * out_list;//outgoing edge list
 	UINT id;
 	UINT rpo;
 	void * info;
@@ -101,9 +101,9 @@ public:
 
 
 #define MAKE_VALUE(from, to) (((from)<<16)|(to))
-class EDGE_HF {
+class EdgeHashFunc {
 public:
-	UINT get_hash_value(EDGE * e, UINT bs) const
+	UINT get_hash_value(Edge * e, UINT bs) const
 	{
 		IS_TRUE0(is_power_of_2(bs));
 		return hash32bit(MAKE_VALUE(VERTEX_id(EDGE_from(e)),
@@ -111,47 +111,46 @@ public:
 	}
 
 	UINT get_hash_value(OBJTY val, UINT bs) const
-	{ return get_hash_value((EDGE*)val, bs); }
+	{ return get_hash_value((Edge*)val, bs); }
 
-	bool compare(EDGE * e1, EDGE * e2) const
+	bool compare(Edge * e1, Edge * e2) const
 	{
 		return (VERTEX_id(EDGE_from(e1)) == VERTEX_id(EDGE_from(e2))) &&
 			   (VERTEX_id(EDGE_to(e1)) == VERTEX_id(EDGE_to(e2)));
 	}
 
-	bool compare(EDGE * t1, OBJTY val) const
+	bool compare(Edge * t1, OBJTY val) const
 	{
-		EDGE * t2 = (EDGE*)val;
+		Edge * t2 = (Edge*)val;
 		return VERTEX_id(EDGE_from(t1)) == VERTEX_id(EDGE_from(t2)) &&
 			   VERTEX_id(EDGE_to(t1)) == VERTEX_id(EDGE_to(t2));
 	}
 };
 
 
-class EDGE_HASH : public SHASH<EDGE*, EDGE_HF> {
-	GRAPH * m_g;
+class EdgeHash : public SHash<Edge*, EdgeHashFunc> {
+	Graph * m_g;
 public:
-	EDGE_HASH(UINT bsize = 64) : SHASH<EDGE*, EDGE_HF>(bsize) {}
-	virtual ~EDGE_HASH() {}
+	EdgeHash(UINT bsize = 64) : SHash<Edge*, EdgeHashFunc>(bsize) {}
+	virtual ~EdgeHash() {}
 
-	void init_g(GRAPH * g) { m_g = g; }
-	void init(GRAPH * g, UINT bsize)
+	void init(Graph * g, UINT bsize)
 	{
 		m_g = g;
-		SHASH<EDGE*, EDGE_HF>::init(bsize);
+		SHash<Edge*, EdgeHashFunc>::init(bsize);
 	}
 
 	void destroy()
 	{
 		m_g = NULL;
-		SHASH<EDGE*, EDGE_HF>::destroy();
+		SHash<Edge*, EdgeHashFunc>::destroy();
 	}
 
-	virtual EDGE * create(OBJTY v);
+	virtual Edge * create(OBJTY v);
 };
 
 
-class VERTEX_HF {
+class VertexHashFunc {
 public:
 	UINT get_hash_value(OBJTY val, UINT bs) const
 	{
@@ -159,38 +158,38 @@ public:
 		return hash32bit((UINT)(size_t)val) & (bs - 1);
 	}
 
-	UINT get_hash_value(VERTEX const* vex, UINT bs) const
+	UINT get_hash_value(Vertex const* vex, UINT bs) const
 	{
 		IS_TRUE0(is_power_of_2(bs));
 		return hash32bit(VERTEX_id(vex)) & (bs - 1);
 	}
 
-	bool compare(VERTEX * v1, VERTEX * v2) const
+	bool compare(Vertex * v1, Vertex * v2) const
 	{ return (VERTEX_id(v1) == VERTEX_id(v2)); }
 
-	bool compare(VERTEX * v1, OBJTY val) const
+	bool compare(Vertex * v1, OBJTY val) const
 	{ return (VERTEX_id(v1) == (UINT)(size_t)val); }
 };
 
 
-class VERTEX_HASH : public SHASH<VERTEX*, VERTEX_HF> {
+class VertexHash : public SHash<Vertex*, VertexHashFunc> {
 protected:
-	SMEM_POOL * m_ec_pool;
+	SMemPool * m_ec_pool;
 public:
-	VERTEX_HASH(UINT bsize = 64) : SHASH<VERTEX*, VERTEX_HF>(bsize)
+	VertexHash(UINT bsize = 64) : SHash<Vertex*, VertexHashFunc>(bsize)
 	{
-		m_ec_pool = smpool_create_handle(sizeof(VERTEX) * 4, MEM_CONST_SIZE);
+		m_ec_pool = smpoolCreate(sizeof(Vertex) * 4, MEM_CONST_SIZE);
 	}
 
-	virtual ~VERTEX_HASH()
-	{ smpool_free_handle(m_ec_pool); }
+	virtual ~VertexHash()
+	{ smpoolDelete(m_ec_pool); }
 
-	virtual VERTEX * create(OBJTY v)
+	virtual Vertex * create(OBJTY v)
 	{
-		VERTEX * vex = (VERTEX*)smpool_malloc_h_const_size(sizeof(VERTEX),
-														   m_ec_pool);
+		Vertex * vex = 
+			(Vertex*)smpoolMallocConstSize(sizeof(Vertex), m_ec_pool);
 		IS_TRUE0(vex);
-		memset(vex, 0, sizeof(VERTEX));
+		memset(vex, 0, sizeof(Vertex));
 		VERTEX_id(vex) = (UINT)(size_t)v;
 		return vex;
 	}
@@ -208,9 +207,9 @@ Sometimes an edge has a third component, known as either a weight or a cost.
 NOTICE: for accelerating perform operation of each vertex, e.g
 compute dominator, please try best to add vertex with
 topological order. */
-class GRAPH {
-	friend class EDGE_HASH;
-	friend class VERTEX_HASH;
+class Graph {
+	friend class EdgeHash;
+	friend class VertexHash;
 protected:
 	//it is true if the number of edges between any two
 	//vertices are not more than one.
@@ -218,138 +217,138 @@ protected:
 	BYTE m_is_direction:1; //true if graph is direction.
 	UINT m_edge_hash_size;
 	UINT m_vex_hash_size;
-	EDGE_HASH m_edges; //record all edges.
-	VERTEX_HASH m_vertices; //record all vertices.
-	FREE_LIST<EDGE> m_e_free_list; //record freed EDGE for reuse.
-	FREE_LIST<EDGE_C> m_el_free_list; //record freed EDGE_C for reuse.
-	FREE_LIST<VERTEX> m_v_free_list; //record freed VERTEX for reuse.
-	SMEM_POOL * m_vertex_pool;
-	SMEM_POOL * m_edge_pool;
-	SMEM_POOL * m_ec_pool;
+	EdgeHash m_edges; //record all edges.
+	VertexHash m_vertices; //record all vertices.
+	FreeList<Edge> m_e_free_list; //record freed Edge for reuse.
+	FreeList<EdgeC> m_el_free_list; //record freed EdgeC for reuse.
+	FreeList<Vertex> m_v_free_list; //record freed Vertex for reuse.
+	SMemPool * m_vertex_pool;
+	SMemPool * m_edge_pool;
+	SMemPool * m_ec_pool;
 
 	//record vertex if vertex id is densen distribution.
 	//map vertex id to vertex.
-	SVECTOR<VERTEX*> * m_dense_vertex;
+	Vector<Vertex*> * m_dense_vertex;
 
 protected:
 	//Add 'e' into out-edges of 'vex'
-	inline void add_out_list(VERTEX * vex, EDGE * e)
+	inline void addOutList(Vertex * vex, Edge * e)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		if (vex == NULL || e == NULL)return;
 
-		EDGE_C * el = VERTEX_out_list(vex);
+		EdgeC * el = VERTEX_out_list(vex);
 		while (el != NULL) {
 			if (EC_edge(el) == e) return;
 			el = EC_next(el);
 		}
-		el = new_ec(e);
+		el = newEdgeC(e);
 		add_next(&VERTEX_out_list(vex), el);
 	}
 
 	//Add 'e' into in-edges of 'vex'
-	inline void add_in_list(VERTEX * vex, EDGE * e)
+	inline void addInList(Vertex * vex, Edge * e)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		if (vex == NULL || e == NULL) return;
 
-		EDGE_C * el = VERTEX_in_list(vex);
+		EdgeC * el = VERTEX_in_list(vex);
 		while (el != NULL) {
 			if (EC_edge(el) == e) return;
 			el = EC_next(el);
 		}
-		el = new_ec(e);
+		el = newEdgeC(e);
 		add_next(&VERTEX_in_list(vex), el);
 	}
 
-	virtual void * clone_edge_info(EDGE*)
+	virtual void * cloneEdgeInfo(Edge*)
 	{ IS_TRUE(0, ("should be overloaded")); return NULL; }
 
-	virtual void * clone_vertex_info(VERTEX*)
+	virtual void * cloneVertexInfo(Vertex*)
 	{ IS_TRUE(0, ("should be overloaded")); return NULL; }
 
-	inline VERTEX * new_vertex()
+	inline Vertex * newVertex()
 	{
-		VERTEX * vex = (VERTEX*)smpool_malloc_h_const_size(sizeof(VERTEX),
+		Vertex * vex = (Vertex*)smpoolMallocConstSize(sizeof(Vertex),
 													  m_vertex_pool);
 		IS_TRUE0(vex);
-		memset(vex, 0, sizeof(VERTEX));
+		memset(vex, 0, sizeof(Vertex));
 		return vex;
 	}
 
-	inline EDGE * new_edge(UINT from, UINT to)
+	inline Edge * newEdge(UINT from, UINT to)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
-		VERTEX * fp = add_vertex(from);
-		VERTEX * tp = add_vertex(to);
-		return new_edge(fp, tp);
+		Vertex * fp = addVertex(from);
+		Vertex * tp = addVertex(to);
+		return newEdge(fp, tp);
 	}
-	EDGE * new_edge(VERTEX * from, VERTEX * to);
-	VERTEX * new_vertex(UINT vid);
+	Edge * newEdge(Vertex * from, Vertex * to);
+	Vertex * newVertex(UINT vid);
 
-	inline EDGE * new_edge_impl(VERTEX * from, VERTEX * to)
+	inline Edge * newEdgeImpl(Vertex * from, Vertex * to)
 	{
-		EDGE * e = m_e_free_list.get_free_elem();
+		Edge * e = m_e_free_list.get_free_elem();
 		if (e == NULL) {
-			e = (EDGE*)smpool_malloc_h_const_size(sizeof(EDGE), m_edge_pool);
-			memset(e, 0, sizeof(EDGE));
+			e = (Edge*)smpoolMallocConstSize(sizeof(Edge), m_edge_pool);
+			memset(e, 0, sizeof(Edge));
 		}
 		EDGE_from(e) = from;
 		EDGE_to(e) = to;
-		add_in_list(to, e);
-		add_out_list(from, e);
+		addInList(to, e);
+		addOutList(from, e);
 		return e;
 	}
 
-	inline EDGE_C * new_ec(EDGE * e)
+	inline EdgeC * newEdgeC(Edge * e)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		if (e == NULL) { return NULL; }
 
-		EDGE_C * el = m_el_free_list.get_free_elem();
+		EdgeC * el = m_el_free_list.get_free_elem();
 		if (el == NULL) {
-			el = (EDGE_C*)smpool_malloc_h_const_size(sizeof(EDGE_C),
+			el = (EdgeC*)smpoolMallocConstSize(sizeof(EdgeC),
 													 m_ec_pool);
-			memset(el, 0, sizeof(EDGE_C));
+			memset(el, 0, sizeof(EdgeC));
 		}
 		EC_edge(el) = e;
 		return el;
 	}
 public:
-	GRAPH(UINT edge_hash_size = 64, UINT vex_hash_size = 64);
-	GRAPH(GRAPH const& g);
-	GRAPH const& operator = (GRAPH const&);
+	Graph(UINT edge_hash_size = 64, UINT vex_hash_size = 64);
+	Graph(Graph const& g);
+	Graph const& operator = (Graph const&);
 
-	virtual ~GRAPH() { destroy(); }
+	virtual ~Graph() { destroy(); }
 	void init();
 	void destroy();
-	inline EDGE * add_edge(UINT from, UINT to)
+	inline Edge * addEdge(UINT from, UINT to)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
-		return new_edge(from, to);
+		return newEdge(from, to);
 	}
-	inline EDGE * add_edge(VERTEX * from, VERTEX * to)
+	inline Edge * addEdge(Vertex * from, Vertex * to)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
-		return new_edge(from, to);
+		return newEdge(from, to);
 	}
-	inline VERTEX * add_vertex(UINT vid)
+	inline Vertex * addVertex(UINT vid)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
-		return m_vertices.append(new_vertex(vid));
+		return m_vertices.append(newVertex(vid));
 	}
 
-	void compute_rpo_norec(IN OUT VERTEX * root, OUT LIST<VERTEX const*> & vlst);
-	bool clone(GRAPH const& src);
+	void computeRpoNoRecursive(IN OUT Vertex * root, OUT List<Vertex const*> & vlst);
+	bool clone(Graph const& src);
 	UINT count_mem() const;
 
 	void dump_dot(CHAR const* name = NULL);
 	void dump_vcg(CHAR const* name = NULL);
 	
 	//Return true if 'succ' is successor of 'v'.
-	bool is_succ(VERTEX * v, VERTEX * succ) const
+	bool is_succ(Vertex * v, Vertex * succ) const
 	{
-		EDGE_C * e = VERTEX_out_list(v);
+		EdgeC * e = VERTEX_out_list(v);
 		while (e != NULL) {
 			if (EDGE_to(EC_edge(e)) == succ) {
 				return true;
@@ -360,9 +359,9 @@ public:
 	}
 	
 	//Return true if 'pred' is predecessor of 'v'.
-	bool is_pred(VERTEX * v, VERTEX * pred) const
+	bool is_pred(Vertex * v, Vertex * pred) const
 	{
-		EDGE_C * e = VERTEX_in_list(v);
+		EdgeC * e = VERTEX_in_list(v);
 		while (e != NULL) {
 			if (EDGE_from(EC_edge(e)) == pred) {
 				return true;
@@ -372,7 +371,7 @@ public:
 		return false;
 	}	
 
-	bool is_equal(GRAPH & g) const;
+	bool is_equal(Graph & g) const;
 	bool is_unique() const { return m_is_unique; }
 	bool is_direction() const { return m_is_direction; }
 
@@ -382,31 +381,31 @@ public:
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		return is_reachable(get_vertex(from), get_vertex(to));
 	}
-	bool is_reachable(VERTEX * from, VERTEX * to) const;
-	void insert_vertex_between(IN VERTEX * v1, IN VERTEX * v2,
-							   IN VERTEX * newv, OUT EDGE ** e1 = NULL,
-							   OUT EDGE ** e2 = NULL);
-	void insert_vertex_between(UINT v1, UINT v2, UINT newv,
-							   OUT EDGE ** e1 = NULL, OUT EDGE ** e2 = NULL);
-	bool is_graph_entry(VERTEX const* v) const
+	bool is_reachable(Vertex * from, Vertex * to) const;
+	void insertVertexBetween(IN Vertex * v1, IN Vertex * v2,
+							   IN Vertex * newv, OUT Edge ** e1 = NULL,
+							   OUT Edge ** e2 = NULL);
+	void insertVertexBetween(UINT v1, UINT v2, UINT newv,
+							   OUT Edge ** e1 = NULL, OUT Edge ** e2 = NULL);
+	bool is_graph_entry(Vertex const* v) const
 	{ return VERTEX_in_list(v) == NULL;	}
 
 	//Return true if vertex is exit node of graph.
-	bool is_graph_exit(VERTEX const* v) const
+	bool is_graph_exit(Vertex const* v) const
 	{ return VERTEX_out_list(v) == NULL; }
 
 	void erase();
 
-	bool get_neighbor_list(IN OUT LIST<UINT> & ni_list, UINT vid) const;
-	bool get_neighbor_set(OUT SBITSET & niset, UINT vid) const;
+	bool get_neighbor_list(IN OUT List<UINT> & ni_list, UINT vid) const;
+	bool get_neighbor_set(OUT SBitSet & niset, UINT vid) const;
 	inline UINT get_degree(UINT vid) const
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		return get_degree(get_vertex(vid));
 	}
-	UINT get_degree(VERTEX const* vex) const;
-	UINT get_in_degree(VERTEX const* vex) const;
-	UINT get_out_degree(VERTEX const* vex) const;
+	UINT get_degree(Vertex const* vex) const;
+	UINT get_in_degree(Vertex const* vex) const;
+	UINT get_out_degree(Vertex const* vex) const;
 	inline UINT get_vertex_num() const
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
@@ -417,51 +416,51 @@ public:
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		return m_edges.get_elem_count();
 	}
-	inline VERTEX * get_vertex(UINT vid) const
+	inline Vertex * get_vertex(UINT vid) const
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		if (m_dense_vertex != NULL) {
 			return m_dense_vertex->get(vid);
 		}
-		return (VERTEX*)m_vertices.find((OBJTY)(size_t)vid);
+		return (Vertex*)m_vertices.find((OBJTY)(size_t)vid);
 	}
-	EDGE * get_edge(UINT from, UINT to) const;
-	EDGE * get_edge(VERTEX const* from, VERTEX const* to) const;
-	inline EDGE * get_first_edge(INT & cur) const
+	Edge * get_edge(UINT from, UINT to) const;
+	Edge * get_edge(Vertex const* from, Vertex const* to) const;
+	inline Edge * get_first_edge(INT & cur) const
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		return m_edges.get_first(cur);
 	}
-	inline EDGE * get_next_edge(INT & cur) const
+	inline Edge * get_next_edge(INT & cur) const
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		return m_edges.get_next(cur);
 	}
-	inline VERTEX * get_first_vertex(INT & cur) const
+	inline Vertex * get_first_vertex(INT & cur) const
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		return m_vertices.get_first(cur);
 	}
-	inline VERTEX * get_next_vertex(INT & cur) const
+	inline Vertex * get_next_vertex(INT & cur) const
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
 		return m_vertices.get_next(cur);
 	}
 
 	void resize(UINT vertex_hash_sz, UINT edge_hash_sz);
-	EDGE * rev_edge(EDGE * e); //Reverse edge direction.(e.g: a->b => b->a)
-	void rev_edges(); //Reverse all edges.
-	EDGE * remove_edge(EDGE * e);
-	void remove_edges_between(VERTEX * v1, VERTEX * v2);
-	VERTEX * remove_vertex(VERTEX * vex);
-	inline VERTEX * remove_vertex(UINT vid)
+	Edge * reverseEdge(Edge * e); //Reverse edge direction.(e.g: a->b => b->a)
+	void reverseEdges(); //Reverse all edges.
+	Edge * removeEdge(Edge * e);
+	void removeEdgeBetween(Vertex * v1, Vertex * v2);
+	Vertex * removeVertex(Vertex * vex);
+	inline Vertex * removeVertex(UINT vid)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
-		return remove_vertex(get_vertex(vid));
+		return removeVertex(get_vertex(vid));
 	}
-	void remove_transitive_edge();
+	void removeTransitiveEdge();
 
-	bool sort_in_toplog_order(OUT SVECTOR<UINT> & vex_vec, bool is_topdown);
+	bool sortInToplogOrder(OUT Vector<UINT> & vex_vec, bool is_topdown);
 	void set_unique(bool is_unique)
 	{
 		IS_TRUE(m_ec_pool != NULL, ("not yet initialized."));
@@ -476,7 +475,7 @@ public:
 	{
 		if (is_dense) {
 			if (m_dense_vertex == NULL) {
-				m_dense_vertex = new SVECTOR<VERTEX*>();
+				m_dense_vertex = new Vector<Vertex*>();
 			}
 			return;
 		}
@@ -488,67 +487,46 @@ public:
 };
 
 
-class ITER_DOM_TREE {
-public:
-	BITSET is_visited;
-	SSTACK<VERTEX*> stk;
-	UINT is_preorder:1;
-	UINT is_postorder:1;
-
-public:
-	ITER_DOM_TREE()
-	{
-		is_preorder = 0;
-		is_postorder = 0;
-	}
-	COPY_CONSTRUCTOR(ITER_DOM_TREE);
-
-	void clean() { is_visited.clean(); stk.clean(); }
-	void set_preorder() { is_preorder = 1; }
-	void set_postorder() { is_postorder = 1; }
-};
-
-
 //This class indicate a Dominator Tree.
-class DOM_TREE : public GRAPH {
+class DomTree : public Graph {
 public:
-	DOM_TREE()
+	DomTree()
 	{ set_dense(true); }
 };
 
 
 //
-//GRAPH with Dominator info.
+//Graph with Dominator info.
 //
-class DGRAPH : public GRAPH {
+class DGraph : public Graph {
 protected:
-	SVECTOR<BITSET*> m_dom_set; //record dominator-set of each vertex.
-	SVECTOR<BITSET*> m_pdom_set; //record post-dominator-set of each vertex.
-	SVECTOR<INT> m_idom_set; //immediate dominator.
-	SVECTOR<INT> m_ipdom_set; //immediate post dominator.
-	BITSET_MGR * m_bs_mgr;
-	void _remove_unreach_node(UINT id, BITSET & visited);
+	Vector<BitSet*> m_dom_set; //record dominator-set of each vertex.
+	Vector<BitSet*> m_pdom_set; //record post-dominator-set of each vertex.
+	Vector<INT> m_idom_set; //immediate dominator.
+	Vector<INT> m_ipdom_set; //immediate post dominator.
+	BitSetMgr * m_bs_mgr;
+	void _removeUnreachNode(UINT id, BitSet & visited);
 public:
-	DGRAPH(UINT edge_hash_size = 64, UINT vex_hash_size = 64);
-	DGRAPH(DGRAPH const& g);
-	DGRAPH const& operator = (DGRAPH const&);
+	DGraph(UINT edge_hash_size = 64, UINT vex_hash_size = 64);
+	DGraph(DGraph const& g);
+	DGraph const& operator = (DGraph const&);
 
-	inline bool clone(DGRAPH const& g)
+	inline bool clone(DGraph const& g)
 	{
 		m_bs_mgr = g.m_bs_mgr;
-		return GRAPH::clone(g);
-	}
-	bool clone_bs(DGRAPH const& src);
-	bool compute_dom3(LIST<VERTEX const*> const* vlst, BITSET const* uni);
-	bool compute_dom2(LIST<VERTEX const*> const& vlst);
-	bool compute_dom(LIST<VERTEX const*> const* vlst = NULL,
-					 BITSET const* uni = NULL);
-	bool compute_pdom_by_rpo(VERTEX * root, BITSET const* uni);
-	bool compute_pdom(LIST<VERTEX const*> const* vlst);
-	bool compute_pdom(LIST<VERTEX const*> const* vlst, BITSET const* uni);
-	bool compute_idom();
-	bool compute_idom2(LIST<VERTEX const*> const& vlst);
-	bool compute_ipdom();
+		return Graph::clone(g);
+	}
+	bool cloneDomAndPdom(DGraph const& src);
+	bool computeDom3(List<Vertex const*> const* vlst, BitSet const* uni);
+	bool computeDom2(List<Vertex const*> const& vlst);
+	bool computeDom(List<Vertex const*> const* vlst = NULL,
+					 BitSet const* uni = NULL);
+	bool computePdomByRpo(Vertex * root, BitSet const* uni);
+	bool computePdom(List<Vertex const*> const* vlst);
+	bool computePdom(List<Vertex const*> const* vlst, BitSet const* uni);
+	bool computeIdom();
+	bool computeIdom2(List<Vertex const*> const& vlst);
+	bool computeIpdom();
 	UINT count_mem() const;
 
 	void dump_dom(FILE * h, bool dump_dom_tree = true);
@@ -563,17 +541,17 @@ public:
 	//'id': vertex id.
 	inline UINT get_ipdom(UINT id) { return (UINT)m_ipdom_set.get(id); }
 
-	void get_dom_tree(OUT GRAPH & dom);
-	void get_pdom_tree(OUT GRAPH & pdom);
+	void get_dom_tree(OUT Graph & dom);
+	void get_pdom_tree(OUT Graph & pdom);
 
-	BITSET * get_dom_set_c(UINT id) const { return m_dom_set.get(id); }
+	BitSet * get_dom_set_c(UINT id) const { return m_dom_set.get(id); }
 
 	//Get vertices who dominate vertex 'id'.
 	//NOTE: set does NOT include 'v' itself.
-	inline BITSET * get_dom_set(UINT id)
+	inline BitSet * get_dom_set(UINT id)
 	{
 		IS_TRUE0(m_bs_mgr != NULL);
-		BITSET * set = m_dom_set.get(id);
+		BitSet * set = m_dom_set.get(id);
 		if (set == NULL) {
 			set = m_bs_mgr->create();
 			m_dom_set.set(id, set);
@@ -583,20 +561,20 @@ public:
 
 	//Get vertices who dominate vertex 'v'.
 	//NOTE: set does NOT include 'v' itself.
-	BITSET * get_dom_set(VERTEX const* v)
+	BitSet * get_dom_set(Vertex const* v)
 	{
 		IS_TRUE0(v != NULL);
 		return get_dom_set(VERTEX_id(v));
 	}
 
-	BITSET * get_pdom_set_c(UINT id) const { return m_pdom_set.get(id); }
+	BitSet * get_pdom_set_c(UINT id) const { return m_pdom_set.get(id); }
 
 	//Get vertices who post dominated by vertex 'id'.
 	//NOTE: set does NOT include 'v' itself.
-	inline BITSET * get_pdom_set(UINT id)
+	inline BitSet * get_pdom_set(UINT id)
 	{
 		IS_TRUE0(m_bs_mgr != NULL);
-		BITSET * set = m_pdom_set.get(id);
+		BitSet * set = m_pdom_set.get(id);
 		if (set == NULL) {
 			set = m_bs_mgr->create();
 			m_pdom_set.set(id, set);
@@ -606,27 +584,33 @@ public:
 
 	//Get vertices who post dominated by vertex 'v'.
 	//NOTE: set does NOT include 'v' itself.
-	BITSET * get_pdom_set(VERTEX const* v)
+	BitSet * get_pdom_set(Vertex const* v)
 	{
 		IS_TRUE0(v != NULL);
 		return get_pdom_set(VERTEX_id(v));
 	}
 
 	//Return true if 'v1' dominate 'v2'.
-	bool is_dom(UINT v1, UINT v2)
-	{ return get_dom_set(v2)->is_contain(v1); }
+	bool is_dom(UINT v1, UINT v2) const
+	{ 
+		IS_TRUE0(get_dom_set_c(v2));
+		return get_dom_set_c(v2)->is_contain(v1); 
+	}
 
 	//Return true if 'v1' post dominate 'v2'.
-	bool is_pdom(UINT v1, UINT v2)
-	{ return get_pdom_set(v2)->is_contain(v1); }
-
-	void sort_in_bfs_order(SVECTOR<UINT> & order_buf, VERTEX * root,
-						   BITSET & visit);
-	void sort_dom_tree_in_preorder(IN VERTEX * root,
-								   OUT LIST<VERTEX*> & lst);
-	void sort_dom_tree_in_postorder(IN VERTEX * root,
-									OUT LIST<VERTEX*> & lst);
-	void set_bs_mgr(BITSET_MGR * bs_mgr) { m_bs_mgr = bs_mgr; }
-	bool remove_unreach_node(UINT entry_id);
+	bool is_pdom(UINT v1, UINT v2) const
+	{ 
+		IS_TRUE0(get_pdom_set_c(v2));
+		return get_pdom_set_c(v2)->is_contain(v1);
+	}
+
+	void sortInBfsOrder(Vector<UINT> & order_buf, Vertex * root,
+						   BitSet & visit);
+	void sortDomTreeInPreorder(IN Vertex * root,
+								   OUT List<Vertex*> & lst);
+	void sortDomTreeInPostrder(IN Vertex * root,
+									OUT List<Vertex*> & lst);
+	void set_bs_mgr(BitSetMgr * bs_mgr) { m_bs_mgr = bs_mgr; }
+	bool removeUnreachNode(UINT entry_id);
 };
 #endif
diff --git a/src/com/smempool.cpp b/src/com/smempool.cpp
index 2dab63e..4f83130 100644
--- a/src/com/smempool.cpp
+++ b/src/com/smempool.cpp
@@ -36,19 +36,19 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define END_BOUND_BYTE 	4
 
 
-class MEMPOOL_HASH : public SHASH<SMEM_POOL*> {
+class MEMPOOL_HASH : public SHash<SMemPool*> {
 public:
 #ifdef _VC6_
-	MEMPOOL_HASH():SHASH<SMEM_POOL*>(1024){}
+	MEMPOOL_HASH():SHash<SMemPool*>(1024){}
 #else
-	MEMPOOL_HASH():SHASH<SMEM_POOL*>::SHASH(1024){}
+	MEMPOOL_HASH():SHash<SMemPool*>::SHash(1024){}
 #endif
 	~MEMPOOL_HASH(){}
 };
 
 
 static MEMPOOL_HASH * g_mem_pool_hash_tab = NULL;
-static SMEM_POOL * g_mem_pool=NULL;
+static SMemPool * g_mem_pool=NULL;
 static UINT g_mem_pool_count = 0;
 #ifdef _DEBUG_
 static UINT g_mem_pool_chunk_count = 0;
@@ -63,11 +63,11 @@ static bool g_is_pool_hashed = true;
 ULONGLONG g_stat_mem_size = 0;
 
 
-void dump_pool(SMEM_POOL * handler, FILE * h)
+void dumpPool(SMemPool * handler, FILE * h)
 {
 	if (h == NULL) { return; }
 	fprintf(h, "\n= SMP, total size:%u ",
-			(UINT)smpool_get_pool_size_handle(handler));
+			(UINT)smpoolGetPoolSize(handler));
 	while (handler != NULL) {
 		fprintf(h, "<T%u R%u>",
 				(UINT)MEMPOOL_pool_size(handler),
@@ -82,14 +82,14 @@ void dump_pool(SMEM_POOL * handler, FILE * h)
 }
 
 
-static SMEM_POOL * new_mem_pool(size_t size, MEMPOOLTYPE mpt)
+static SMemPool * new_mem_pool(size_t size, MEMPOOLTYPE mpt)
 {
-	SMEM_POOL * mp = NULL;
-	INT size_mp = sizeof(SMEM_POOL);
+	SMemPool * mp = NULL;
+	INT size_mp = sizeof(SMemPool);
 	if (size_mp % WORD_ALIGN) {
-		size_mp = (sizeof(SMEM_POOL) / WORD_ALIGN + 1 ) * WORD_ALIGN;
+		size_mp = (sizeof(SMemPool) / WORD_ALIGN + 1 ) * WORD_ALIGN;
 	}
-	mp = (SMEM_POOL*)malloc(size_mp + size + END_BOUND_BYTE);
+	mp = (SMemPool*)malloc(size_mp + size + END_BOUND_BYTE);
 	IS_TRUE(mp, ("create mem pool failed, no enough memory"));
 	memset(mp, 0, size_mp);
 	memset(((CHAR*)mp) + size_mp + size, BOUNDARY_NUM, END_BOUND_BYTE);
@@ -107,7 +107,7 @@ static SMEM_POOL * new_mem_pool(size_t size, MEMPOOLTYPE mpt)
 }
 
 
-inline static void remove_smp(SMEM_POOL * t)
+inline static void remove_smp(SMemPool * t)
 {
 	if (t == NULL) return;
 	IS_TRUE(t->prev != NULL, ("t should not be first."));
@@ -119,7 +119,7 @@ inline static void remove_smp(SMEM_POOL * t)
 }
 
 
-inline static void append_head_smp(SMEM_POOL ** head, SMEM_POOL * t)
+inline static void append_head_smp(SMemPool ** head, SMemPool * t)
 {
 	IS_TRUE(t && head, ("Mem pool internal error 1"));
 	t->prev = NULL;
@@ -128,11 +128,11 @@ inline static void append_head_smp(SMEM_POOL ** head, SMEM_POOL * t)
 }
 
 
-inline static void append_after_smp(SMEM_POOL * marker, SMEM_POOL * tlst)
+inline static void append_after_smp(SMemPool * marker, SMemPool * tlst)
 {
 	IS_TRUE(marker && tlst && marker != tlst, ("Mem pool internal error 2"));
 	if (marker->next != NULL) {
-		SMEM_POOL * last = tlst;
+		SMemPool * last = tlst;
 		while (last != NULL && last->next != NULL) {
 			last = last->next;
 		}
@@ -146,9 +146,9 @@ inline static void append_after_smp(SMEM_POOL * marker, SMEM_POOL * tlst)
 
 /*
 Hash table must be initialized if one invoked
-smpool_create_idx or smpool_malloc_h.
+smpoolCreatePoolIndex or smpoolMalloc.
 */
-void smpool_init_pool()
+void smpoolInitPool()
 {
 	if (g_is_pool_init) {
 		return;
@@ -156,7 +156,7 @@ void smpool_init_pool()
 
 	if (g_is_pool_hashed) {
 		g_mem_pool_hash_tab = new MEMPOOL_HASH();
-		SMEM_POOL * mp = g_mem_pool;
+		SMemPool * mp = g_mem_pool;
 
 		//Record pool list into hash.
 		while (mp != NULL) {
@@ -182,13 +182,13 @@ void smpool_init_pool()
 }
 
 
-void smpool_fini_pool()
+void smpoolFiniPool()
 {
 	if (g_is_pool_init && g_is_pool_hashed) {
 		IS_TRUE(g_mem_pool == NULL, ("illegal init process"));
-		SMEM_POOL * next = NULL;
+		SMemPool * next = NULL;
 		INT c;
-		for (SMEM_POOL * mp = g_mem_pool_hash_tab->get_first(c);
+		for (SMemPool * mp = g_mem_pool_hash_tab->get_first(c);
 			 mp != NULL; mp = next) {
 			next = g_mem_pool_hash_tab->get_next(c);
 			g_mem_pool_hash_tab->removed(mp);
@@ -202,11 +202,11 @@ void smpool_fini_pool()
 	}
 
 	g_is_pool_init = false;
-	SMEM_POOL * mp = g_mem_pool;
+	SMemPool * mp = g_mem_pool;
 	while (mp != NULL) {
-		SMEM_POOL * tmp = mp;
+		SMemPool * tmp = mp;
 		mp = MEMPOOL_next(mp);
-		smpool_free_idx(MEMPOOL_id(tmp));
+		smpoolDeleteViaPoolIndex(MEMPOOL_id(tmp));
 	}
 	g_mem_pool = NULL;
 	g_mem_pool_count = 0;
@@ -217,9 +217,9 @@ void smpool_fini_pool()
 NOTICE:
 Since this type of pool will NOT to be recorded
 in 'hash table of POOLs', pool index always be 0. */
-SMEM_POOL * smpool_create_handle(size_t size, MEMPOOLTYPE mpt)
+SMemPool * smpoolCreate(size_t size, MEMPOOLTYPE mpt)
 {
-	SMEM_POOL * mp = NULL;
+	SMemPool * mp = NULL;
 	if (size == 0 || mpt == MEM_NONE) { return NULL; }
 	mp = new_mem_pool(size, mpt);
 	return mp;
@@ -228,9 +228,9 @@ SMEM_POOL * smpool_create_handle(size_t size, MEMPOOLTYPE mpt)
 
 //Create new mem pool, return the pool idx.
 #define MAX_TRY 1024
-MEMPOOLIDX smpool_create_idx(size_t size, MEMPOOLTYPE mpt)
+MEMPOOLIDX smpoolCreatePoolIndex(size_t size, MEMPOOLTYPE mpt)
 {
-	SMEM_POOL * mp = NULL;
+	SMemPool * mp = NULL;
 
 	if (size <=0 || mpt == MEM_NONE)
 		return 0;
@@ -252,11 +252,11 @@ MEMPOOLIDX smpool_create_idx(size_t size, MEMPOOLTYPE mpt)
 			IS_TRUE(0, ("Not any available mempool can be created."));
 			return 0;
 		}
-		mp = smpool_create_handle(size, mpt);
+		mp = smpoolCreate(size, mpt);
 		MEMPOOL_id(mp) = idx;
 		g_mem_pool_hash_tab->append(mp);
 	} else {
-		mp = smpool_create_handle(size, mpt);
+		mp = smpoolCreate(size, mpt);
 		MEMPOOL_id(mp) = ++g_mem_pool_count;
 		if (g_mem_pool == NULL) {
 			g_mem_pool = mp;
@@ -271,16 +271,16 @@ MEMPOOLIDX smpool_create_idx(size_t size, MEMPOOLTYPE mpt)
 
 
 //Free mem pool totally.
-INT smpool_free_handle(SMEM_POOL * handler)
+INT smpoolDelete(SMemPool * handler)
 {
 	if (handler == NULL) {
 		return ST_NO_SUCH_MEMPOOL_FIND;
 	}
 
 	//Free local pool list
-	SMEM_POOL * tmp = handler;
+	SMemPool * tmp = handler;
 	while (tmp != NULL) {
-		SMEM_POOL * d_tmp = tmp;
+		SMemPool * d_tmp = tmp;
 		tmp = MEMPOOL_next(tmp);
 		free(d_tmp);
 	}
@@ -289,10 +289,10 @@ INT smpool_free_handle(SMEM_POOL * handler)
 
 
 //Free mem pool totally.
-INT smpool_free_idx(MEMPOOLIDX mpt_idx)
+INT smpoolDeleteViaPoolIndex(MEMPOOLIDX mpt_idx)
 {
 	//search the mempool which indicated with 'mpt_idx'
-	SMEM_POOL * mp = g_mem_pool;
+	SMemPool * mp = g_mem_pool;
 	if (mpt_idx == MEM_NONE) { return ST_SUCC; }
 
 	//Searching the mempool which indicated with 'mpt_idx'
@@ -338,14 +338,14 @@ INT smpool_free_idx(MEMPOOLIDX mpt_idx)
 	}
 
 	//Free local pool list
-	return smpool_free_handle(mp);
+	return smpoolDelete(mp);
 }
 
 
 /* Allocate one element from const size pool.
 User must ensure each elment in const size pool are same size.
 'elem_size': indicate the byte size of each element. */
-void * smpool_malloc_h_const_size(size_t elem_size, IN SMEM_POOL * handler)
+void * smpoolMallocConstSize(size_t elem_size, IN SMemPool * handler)
 {
 	IS_TRUE(elem_size > 0, ("elem size can not be 0"));
 	IS_TRUE(handler, ("need mempool handler"));
@@ -369,7 +369,7 @@ void * smpool_malloc_h_const_size(size_t elem_size, IN SMEM_POOL * handler)
 		return addr;
 	}
 
-	SMEM_POOL * rest = MEMPOOL_next(handler);
+	SMemPool * rest = MEMPOOL_next(handler);
 	if (rest != NULL) {
 		//Search free block in the first rest pool.
 		IS_TRUE(MEMPOOL_pool_size(rest) >= MEMPOOL_start_pos(rest),
@@ -391,7 +391,7 @@ void * smpool_malloc_h_const_size(size_t elem_size, IN SMEM_POOL * handler)
 
 	size_t grow_size = MAX(elem_size * 4, MEMPOOL_grow_size(handler) * 4);
 	MEMPOOL_grow_size(handler) = grow_size;
-	SMEM_POOL * newpool = new_mem_pool(grow_size, MEM_CONST_SIZE);
+	SMemPool * newpool = new_mem_pool(grow_size, MEM_CONST_SIZE);
 	MEMPOOL_prev(newpool) = handler;
 	MEMPOOL_next(handler) = newpool;
 	MEMPOOL_next(newpool) = rest;
@@ -409,7 +409,7 @@ void * smpool_malloc_h_const_size(size_t elem_size, IN SMEM_POOL * handler)
 
 //Query memory space from pool via handler.
 //This function will search pool list to find enough memory space to return.
-void * smpool_malloc_h(size_t size, IN SMEM_POOL * handler, size_t grow_size)
+void * smpoolMalloc(size_t size, IN SMemPool * handler, size_t grow_size)
 {
 	IS_TRUE(size > 0, ("query size can not be 0"));
 	IS_TRUE(handler, ("need mempool handler"));
@@ -420,8 +420,8 @@ void * smpool_malloc_h(size_t size, IN SMEM_POOL * handler, size_t grow_size)
 
 	//Search free block in the pool.
 	void * addr = NULL;
-	SMEM_POOL * tmp_rest = handler, * last = NULL;
-	SMEM_POOL * full_head = NULL;
+	SMemPool * tmp_rest = handler, * last = NULL;
+	SMemPool * full_head = NULL;
 	while (tmp_rest != NULL) {
     	IS_TRUE(MEMPOOL_pool_size(tmp_rest) >= MEMPOOL_start_pos(tmp_rest),
 				("exception occurs during mempool function"));
@@ -434,7 +434,7 @@ void * smpool_malloc_h(size_t size, IN SMEM_POOL * handler, size_t grow_size)
 			goto FIN;
 		}
 
-		SMEM_POOL * cur = tmp_rest;
+		SMemPool * cur = tmp_rest;
 		tmp_rest = MEMPOOL_next(tmp_rest);
 		if (s <= MIN_MARGIN && cur != handler) {
 			remove_smp(cur);
@@ -477,10 +477,10 @@ FIN:
 
 
 //Quering memory space from pool via pool index.
-void * smpool_malloc_i(size_t size, MEMPOOLIDX mpt_idx, size_t grow_size)
+void * smpoolMallocViaPoolIndex(size_t size, MEMPOOLIDX mpt_idx, size_t grow_size)
 {
 	IS_TRUE(size > 0, ("Request size can not be 0"));
-	SMEM_POOL * mp = g_mem_pool;
+	SMemPool * mp = g_mem_pool;
 
 	//Searching the mempool which indicated with 'mpt_idx'
 	if (g_is_pool_hashed && g_is_pool_init) {
@@ -499,15 +499,15 @@ void * smpool_malloc_i(size_t size, MEMPOOLIDX mpt_idx, size_t grow_size)
 		return NULL;
 	}
 
-	return smpool_malloc_h(size, mp, grow_size);
+	return smpoolMalloc(size, mp, grow_size);
 }
 
 
 //Get total pool byte-size.
-size_t smpool_get_pool_size_handle(SMEM_POOL const* handle)
+size_t smpoolGetPoolSize(SMemPool const* handle)
 {
 	if (handle == NULL) return 0;
-	SMEM_POOL const* mp = handle;
+	SMemPool const* mp = handle;
 	size_t size = 0;
 	while (mp != NULL) {
 		size += mp->mem_pool_size;
@@ -518,9 +518,9 @@ size_t smpool_get_pool_size_handle(SMEM_POOL const* handle)
 
 
 //Get total pool byte-size.
-size_t smpool_get_pool_size_idx(MEMPOOLIDX mpt_idx)
+size_t smpoolGetPoolSizeViaIndex(MEMPOOLIDX mpt_idx)
 {
-	SMEM_POOL * mp = g_mem_pool;
+	SMemPool * mp = g_mem_pool;
 
 	if (g_is_pool_hashed && g_is_pool_init) {
 		mp = g_mem_pool_hash_tab->find((OBJTY)(size_t)mpt_idx);
@@ -542,6 +542,6 @@ size_t smpool_get_pool_size_idx(MEMPOOLIDX mpt_idx)
 	Searching free mem block in the mempool
 	which 'mpt_idx' refers to.
 	*/
-	return smpool_get_pool_size_handle(mp);
+	return smpoolGetPoolSize(mp);
 }
 
diff --git a/src/com/smempool.h b/src/com/smempool.h
index 5964ce3..4f721d8 100644
--- a/src/com/smempool.h
+++ b/src/com/smempool.h
@@ -61,44 +61,47 @@ typedef enum {
 #ifdef _DEBUG_
 #define MEMPOOL_chunk_id(p)				((p)->chunk_id)
 #endif
-typedef struct _mem_pool {
+
+typedef struct _MemPool {
 	MEMPOOLTYPE pool_type;
-	struct _mem_pool * next;
-	struct _mem_pool * prev;
+	struct _MemPool * next;
+	struct _MemPool * prev;
 	MEMPOOLIDX mpt_id; //identification of mem pool
 	size_t start_pos; //represent the alloca postion of mem pool
 	size_t mem_pool_size; //represent mem pool size
 	size_t grow_size;
 	void * ppool; //start address of mem pool
+	
 	#ifdef _DEBUG_
 	ULONG chunk_id;
 	#endif
-} SMEM_POOL;
+} SMemPool;
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 //create mem pool
-MEMPOOLIDX smpool_create_idx(size_t size, MEMPOOLTYPE mpt = MEM_COMM);
-SMEM_POOL * smpool_create_handle(size_t size, MEMPOOLTYPE mpt = MEM_COMM);
+MEMPOOLIDX smpoolCreatePoolIndex(size_t size, MEMPOOLTYPE mpt = MEM_COMM);
+SMemPool * smpoolCreate(size_t size, MEMPOOLTYPE mpt = MEM_COMM);
 
 //delete mem pool
-INT smpool_free_idx(MEMPOOLIDX mpt_idx);
-INT smpool_free_handle(SMEM_POOL * handle);
+INT smpoolDeleteViaPoolIndex(MEMPOOLIDX mpt_idx);
+INT smpoolDelete(SMemPool * handle);
 
 //alloc memory from corresponding mem pool
-void * smpool_malloc_i(size_t size, MEMPOOLIDX mpt_idx, size_t grow_size = 0);
-void * smpool_malloc_h(size_t size, SMEM_POOL * handle, size_t grow_size = 0);
-void * smpool_malloc_h_const_size(size_t elem_size, IN SMEM_POOL * handler);
+void * smpoolMallocViaPoolIndex(size_t size, MEMPOOLIDX mpt_idx, 
+								size_t grow_size = 0);
+void * smpoolMalloc(size_t size, SMemPool * handle, size_t grow_size = 0);
+void * smpoolMallocConstSize(size_t elem_size, IN SMemPool * handler);
 
 //Get whole pool size with byte
-size_t smpool_get_pool_size_idx(MEMPOOLIDX mpt_idx);
-size_t smpool_get_pool_size_handle(SMEM_POOL const* handle);
-void smpool_init_pool(); //Initializing pool utilities
-void smpool_fini_pool(); //Finializing pool
+size_t smpoolGetPoolSizeViaIndex(MEMPOOLIDX mpt_idx);
+size_t smpoolGetPoolSize(SMemPool const* handle);
+void smpoolInitPool(); //Initializing pool utilities
+void smpoolFiniPool(); //Finializing pool
 
-void dump_pool(SMEM_POOL * handler, FILE * h);
+void dumpPool(SMemPool * handler, FILE * h);
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/com/sstl.h b/src/com/sstl.h
index f2cfdf6..2534257 100644
--- a/src/com/sstl.h
+++ b/src/com/sstl.h
@@ -30,7 +30,6 @@ USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define NO_BASIC_MAT_DUMP //Default option
 #define MAX_SHASH_BUCKET 97 //Default option
-//#define _SLOW_CHECK_
 
 typedef void* OBJTY;
 
@@ -42,7 +41,7 @@ For easing implementation, there must be 2 fields declared in T
 	2. T * prev
 */
 template <class T>
-inline UINT cnt_list(T * t)
+inline UINT cnt_list(T const* t)
 {
 	UINT c = 0;
 	while (t != NULL) { c++; t = t->next; }
@@ -50,6 +49,20 @@ inline UINT cnt_list(T * t)
 }
 
 
+//Return true if p is in current list.
+template <class T>
+bool in_list(T const* head, T const* p)
+{	
+	if (p == NULL) { return true; }
+	T const* t = head;
+	while (t != NULL) {
+		if (t == p) { return true; }
+		t = t->next;
+	}
+	return false;	
+}
+
+
 template <class T>
 inline T * get_last(T * t)
 {
@@ -365,7 +378,7 @@ public:
 
 
 /*
-FREE-LIST
+FREE-List
 
 T refer to basis element type.
 	e.g: Suppose variable type is 'VAR*', then T is 'VAR'.
@@ -378,22 +391,22 @@ For easing implementation, there are 2 fields should be declared in T,
 	}
 */
 template <class T>
-class FREE_LIST {
+class FreeList {
 public:
 	BOOL m_is_clean;
 	T * m_tail;
 
 public:
-	FREE_LIST()
+	FreeList()
 	{
 		m_is_clean = true;
 		m_tail = NULL;
 	}
-	COPY_CONSTRUCTOR(FREE_LIST);
-	~FREE_LIST()
+	COPY_CONSTRUCTOR(FreeList);
+	~FreeList()
 	{ m_tail = NULL; }
 
-	UINT count_mem() const { return sizeof(FREE_LIST<T>); }
+	UINT count_mem() const { return sizeof(FreeList<T>); }
 
 	//Note the element in list should be freed by user.
 	void clean()
@@ -437,7 +450,7 @@ public:
 		return t;
 	}
 };
-//END FREE_LIST
+//END FreeList
 
 
 
@@ -447,30 +460,30 @@ Dual Linked List.
 NOTICE:
 	The following operations are the key points which you should
 	pay attention to:
-	1.	If you REMOVE one element, its container will be collect by FREE-LIST.
-		So if you need a new container, please check the FREE-LIST first,
+	1.	If you REMOVE one element, its container will be collect by FREE-List.
+		So if you need a new container, please check the FREE-List first,
 		accordingly, you should first invoke 'get_free_list' which get free
 		containers out from 'm_free_list'.
   	2.	If you want to invoke APPEND, please call 'newc' first to
 		allocate a new container memory space, record your elements in
 		container, then APPEND it at list.
 */
-template <class T> class LIST {
+template <class T> class List {
 protected:
 	UINT m_elem_count;
 	C<T> * m_head;
 	C<T> * m_tail;
 
-	//It is a marker that used internally by LIST. Some function will
+	//It is a marker that used internally by List. Some function will
 	//update the variable, see comments.
 	C<T> * m_cur;
 
 	//Hold the freed containers for next request.
-	FREE_LIST<C<T> > m_free_list;
+	FreeList<C<T> > m_free_list;
 public:
-	LIST() { init(); }
-	COPY_CONSTRUCTOR(LIST);
-	~LIST() { destroy(); }
+	List() { init(); }
+	COPY_CONSTRUCTOR(List);
+	~List() { destroy(); }
 
 	void init()
 	{
@@ -527,7 +540,7 @@ public:
 		m_head = m_tail = m_cur = NULL;
 	}
 
-	void copy(IN LIST<T> & src)
+	void copy(IN List<T> & src)
 	{
 		clean();
 		T t = src.get_head();
@@ -590,7 +603,7 @@ public:
 	//This function will remove all elements in 'src' and
 	//append to tail of current list.
 	//Note 'src' will be clean.
-	void append_tail(IN OUT LIST<T> & src)
+	void append_tail(IN OUT List<T> & src)
 	{
 		if (src.m_head == NULL) { return; }
 		if (m_tail == NULL) {
@@ -618,7 +631,7 @@ public:
 	//This function copy elements in 'src' and
 	//append to tail of current list.
 	//'src' is unchanged.
-	void append_and_copy_to_tail(LIST<T> const& src)
+	void append_and_copy_to_tail(List<T> const& src)
 	{
 		C<T> * t = src.m_head;
 		if (t == NULL) { return; }
@@ -680,7 +693,7 @@ public:
 	//This function will remove all elements in 'src' and
 	//append to current list head.
 	//Note 'src' will be clean.
-	void append_head(IN OUT LIST<T> & src)
+	void append_head(IN OUT List<T> & src)
 	{
 		if (src.m_head == NULL) { return; }
 		if (m_tail == NULL) {
@@ -705,7 +718,7 @@ public:
 
 	//This function copy all elements in 'src' and
 	//append to current list head.
-	void append_and_copy_to_head(LIST<T> const& src)
+	void append_and_copy_to_head(List<T> const& src)
 	{
 		C<T> * t = src.m_tail;
 		if (t == NULL) { return; }
@@ -735,19 +748,14 @@ public:
 
 	//Return true if p is in current list.
 	bool in_list(C<T> const* p) const
-	{
-		#ifdef _SLOW_CHECK_
+	{		
 		if (p == NULL) { return true; }
 		C<T> const* t = m_head;
 		while (t != NULL) {
 			if (t == p) { return true; }
 			t = C_next(t);
 		}
-		return false;
-		#else
-		UNUSED(p);
-		return true;
-		#endif
+		return false;		
 	}
 
 	//Insert value t before marker.
@@ -799,7 +807,11 @@ public:
 	{
 		IS_TRUE0(marker && c && C_prev(c) == NULL && C_next(c) == NULL);
 		IS_TRUE0(c != marker);		
-		IS_TRUE0(m_tail && in_list(marker));
+		IS_TRUE0(m_tail);
+
+		#ifdef _SLOW_CHECK_
+		IS_TRUE0(in_list(marker));
+		#endif
 		
 		if (C_prev(marker) != NULL) {
 			C_next(C_prev(marker)) = c;
@@ -827,13 +839,16 @@ public:
 	//Insert 'src' before 'marker', and return the CONTAINER
 	//of src head and src tail.
 	//This function move all element in 'src' into current list.
-	void insert_before(IN OUT LIST<T> & src,
+	void insert_before(IN OUT List<T> & src,
 						IN C<T> * marker,
 						OUT C<T> ** list_head_ct = NULL,
 						OUT C<T> ** list_tail_ct = NULL)
 	{
 		if (src.m_head == NULL) { return; }
-		IS_TRUE0(m_head && marker && in_list(marker));
+		IS_TRUE0(m_head && marker);
+		#ifdef _SLOW_CHECK_
+		IS_TRUE0(in_list(marker));
+		#endif
 		IS_TRUE0(src.m_tail);
 
 		if (C_prev(marker) != NULL) {
@@ -864,7 +879,7 @@ public:
 
 	//Insert 'list' before 'marker', and return the CONTAINER
 	//of list head and list tail.
-	void insert_and_copy_before(IN LIST<T> const& list, T marker,
+	void insert_and_copy_before(IN List<T> const& list, T marker,
 								OUT C<T> ** list_head_ct = NULL,
 								OUT C<T> ** list_tail_ct = NULL)
 	{
@@ -875,7 +890,7 @@ public:
 
 	//Insert 'list' before 'marker', and return the CONTAINER
 	//of list head and list tail.
-	void insert_and_copy_before(IN LIST<T> const& list, IN C<T> * marker,
+	void insert_and_copy_before(IN List<T> const& list, IN C<T> * marker,
 								OUT C<T> ** list_head_ct = NULL,
 								OUT C<T> ** list_tail_ct = NULL)
 	{
@@ -944,7 +959,11 @@ public:
 		IS_TRUE0(marker && c && C_prev(c) == NULL && C_next(c) == NULL);
 		if (c == marker) { return; }
 
-		IS_TRUE0(m_head && in_list(marker));
+		IS_TRUE0(m_head);
+		#ifdef _SLOW_CHECK_
+		IS_TRUE0(in_list(marker));
+		#endif
+		
 		if (C_next(marker) != NULL) {
 			C_prev(C_next(marker)) = c;
 			C_next(c) = C_next(marker);
@@ -970,12 +989,15 @@ public:
 	//Insert 'src' after 'marker', and return the CONTAINER
 	//of src head and src tail.
 	//This function move all element in 'src' into current list.
-	void insert_after(IN OUT LIST<T> & src, IN C<T> * marker,
+	void insert_after(IN OUT List<T> & src, IN C<T> * marker,
 					OUT C<T> ** list_head_ct = NULL,
 					OUT C<T> ** list_tail_ct = NULL)
 	{
 		if (src.m_head == NULL) { return; }
-		IS_TRUE0(m_head && marker && in_list(marker));
+		IS_TRUE0(m_head && marker);		
+		#ifdef _SLOW_CHECK_
+		IS_TRUE0(in_list(marker));
+		#endif
 		IS_TRUE0(src.m_tail);
 
 		if (C_next(marker) != NULL) {
@@ -1006,7 +1028,7 @@ public:
 
 	//Insert 'list' after 'marker', and return the CONTAINER
 	//of list head and list tail.
-	void insert_and_copy_after(IN LIST<T> const& list, T marker,
+	void insert_and_copy_after(IN List<T> const& list, T marker,
 							OUT C<T> ** list_head_ct = NULL,
 							OUT C<T> ** list_tail_ct = NULL)
 	{
@@ -1017,7 +1039,7 @@ public:
 
 	//Insert 'list' after 'marker', and return the CONTAINER
 	//of head and tail of members in 'list'.
-	void insert_and_copy_after(IN LIST<T> const& list, IN C<T> * marker,
+	void insert_and_copy_after(IN List<T> const& list, IN C<T> * marker,
 							OUT C<T> ** list_head_ct = NULL,
 							OUT C<T> ** list_tail_ct = NULL)
 	{
@@ -1367,7 +1389,7 @@ public:
 
 
 
-/* Single Linked LIST Core.
+/* Single Linked List Core.
 
 Encapsulate most operations for single list.
 
@@ -1375,17 +1397,17 @@ Note the single linked list is different with dual linked list.
 the dual linked list does not use mempool to hold the container.
 Compared to dual linked list, single linked list allocate containers 
 in a const size pool. */
-template <class T> class SLISTC {
+template <class T> class SListCore {
 protected:
 	UINT m_elem_count; //list elements counter.
 	SC<T> m_head; //list head.
 
 protected:
-	SC<T> * new_sc_container(SMEM_POOL * pool)
+	SC<T> * new_sc_container(SMemPool * pool)
 	{
 		IS_TRUE(pool, ("need mem pool"));
 		IS_TRUE(MEMPOOL_type(pool) == MEM_CONST_SIZE, ("need const size pool"));
-		SC<T> * p = (SC<T>*)smpool_malloc_h_const_size(sizeof(SC<T>), pool);
+		SC<T> * p = (SC<T>*)smpoolMallocConstSize(sizeof(SC<T>), pool);
 		IS_TRUE0(p != NULL);
 		::memset(p, 0, sizeof(SC<T>));
 		return p;
@@ -1393,8 +1415,7 @@ protected:
 
 	//Check p is the element in list.
 	bool in_list(SC<T> const* p) const
-	{
-		#ifdef _SLOW_CHECK_
+	{		
 		IS_TRUE0(p);
 		if (p == &m_head) { return true; }
 		
@@ -1403,11 +1424,7 @@ protected:
 			if (t == p) { return true; }
 			t = t->next;
 		}
-		return false;
-		#else
-		UNUSED(p);
-		return true;
-		#endif
+		return false;		
 	}
 
 	SC<T> * get_one_sc(SC<T> ** free_list)
@@ -1439,7 +1456,7 @@ protected:
 		*free_list = sc;
 	}
 
-	SC<T> * newsc(SC<T> ** free_list, SMEM_POOL * pool)
+	SC<T> * newsc(SC<T> ** free_list, SMemPool * pool)
 	{
 		SC<T> * c = get_one_sc(free_list);
 		if (c == NULL) {
@@ -1448,9 +1465,9 @@ protected:
 		return c;
 	}
 public:
-	SLISTC() { init(); }
-	COPY_CONSTRUCTOR(SLISTC);
-	~SLISTC() 
+	SListCore() { init(); }
+	COPY_CONSTRUCTOR(SListCore);
+	~SListCore() 
 	{
 		//Note: Before going to the destructor, even if the containers have
 		//been allocated in memory pool, you should free all of them 
@@ -1463,7 +1480,7 @@ public:
 		m_head.next = &m_head;
 	}
 
-	SC<T> * append_head(T t, SC<T> ** free_list, SMEM_POOL * pool)
+	SC<T> * append_head(T t, SC<T> ** free_list, SMemPool * pool)
 	{
 		SC<T> * c  = newsc(free_list, pool);
 		IS_TRUE(c != NULL, ("newsc return NULL"));
@@ -1475,7 +1492,7 @@ public:
 	void append_head(IN SC<T> * c)
 	{ insert_after(c, &m_head); }	
 
-	void copy(IN SLISTC<T> & src, SC<T> ** free_list, SMEM_POOL * pool)
+	void copy(IN SListCore<T> & src, SC<T> ** free_list, SMemPool * pool)
 	{
 		clean(free_list);		
 		SC<T> * tgt_st = get_head();
@@ -1513,7 +1530,10 @@ public:
 	inline void insert_after(IN SC<T> * c, IN SC<T> * marker)
 	{
 		IS_TRUE0(marker && c && c != marker);
-		IS_TRUE0(in_list(marker));		
+		#ifdef _SLOW_CHECK_
+		IS_TRUE0(in_list(marker));
+		#endif
+		
 		c->next = marker->next;
 		marker->next = c;
 		m_elem_count++;
@@ -1523,10 +1543,12 @@ public:
 	//free_list: a list record free containers.
 	//pool: memory pool which is used to allocate container.
 	inline SC<T> * insert_after(T t, IN SC<T> * marker, 
-								SC<T> ** free_list, SMEM_POOL * pool)
+								SC<T> ** free_list, SMemPool * pool)
 	{
 		IS_TRUE0(marker);
+		#ifdef _SLOW_CHECK_
 		IS_TRUE0(in_list(marker));
+		#endif
 		
 		SC<T> * c = newsc(free_list, pool);
 		IS_TRUE(c != NULL, ("newc return NULL"));
@@ -1548,7 +1570,7 @@ public:
 	//Return the next container.
 	SC<T> * get_next(IN SC<T> * holder) const
 	{
-		IS_TRUE0(holder && in_list(holder));
+		IS_TRUE0(holder);
 		return SC_next(holder);
 	}
 
@@ -1607,8 +1629,7 @@ public:
 	{
 		IS_TRUE0(holder);		
 		IS_TRUE(m_head.next != &m_head, ("list is empty"));		
-		IS_TRUE0(prev && in_list(prev));
-		IS_TRUE0(in_list(holder));
+		IS_TRUE0(prev);
 		
 		IS_TRUE(prev->next == holder, ("not prev one"));
 		prev->next = holder->next;		
@@ -1631,16 +1652,16 @@ public:
 		return t;
 	}
 };
-//END SLISTC
+//END SListCore
 
 
-/* Single LIST
+/* Single List
 
 NOTICE:
 	The following 3 operations are the key points which you should
 	attention to:
-	1.	If you REMOVE one element, its container will be collect by FREE-LIST.
-		So if you need a new container, please check the FREE-LIST first,
+	1.	If you REMOVE one element, its container will be collect by FREE-List.
+		So if you need a new container, please check the FREE-List first,
 		accordingly, you should first invoke 'get_free_list' which get free
 		containers out from 'm_free_list'.
   	2.	If you want to invoke APPEND, please call 'newXXX' first to
@@ -1658,15 +1679,15 @@ NOTICE:
 		the dual linked list does not use mempool to hold the container.
 		Compared to dual linked list, single linked list allocate containers 
 		in a const size pool. */
-template <class T> class SLIST : public SLISTC<T> {
+template <class T> class SList : public SListCore<T> {
 protected:
-	SMEM_POOL * m_free_list_pool;
+	SMemPool * m_free_list_pool;
 	SC<T> * m_free_list; //Hold for available containers
 	
 public:
-	SLIST(SMEM_POOL * pool = NULL) { set_pool(pool); }
-	COPY_CONSTRUCTOR(SLIST);
-	~SLIST() 
+	SList(SMemPool * pool = NULL) { set_pool(pool); }
+	COPY_CONSTRUCTOR(SList);
+	~SList() 
 	{ 
 		//It seem destroy() do the same things as the parent class's destructor.
 		//So it is not necessary to double call destroy().
@@ -1676,7 +1697,7 @@ public:
 		//back to a free list to reuse them.
 	}
 
-	void set_pool(SMEM_POOL * pool)
+	void set_pool(SMemPool * pool)
 	{
 		IS_TRUE(pool == NULL ||
 				MEMPOOL_type(pool) == MEM_CONST_SIZE, ("need const size pool"));
@@ -1684,30 +1705,30 @@ public:
 		m_free_list = NULL;
 	}
 	
-	SMEM_POOL * get_pool() { return m_free_list_pool; }
+	SMemPool * get_pool() { return m_free_list_pool; }
 
 	SC<T> * append_head(T t)
 	{
 		IS_TRUE0(m_free_list_pool);
-		return SLISTC<T>::append_head(t, &m_free_list, m_free_list_pool);
+		return SListCore<T>::append_head(t, &m_free_list, m_free_list_pool);
 	}
 
-	void copy(IN SLIST<T> & src)
-	{ SLISTC<T>::copy(src, &m_free_list, m_free_list_pool); }
+	void copy(IN SList<T> & src)
+	{ SListCore<T>::copy(src, &m_free_list, m_free_list_pool); }
 
-	void clean() { SLISTC<T>::clean(&m_free_list); }
+	void clean() { SListCore<T>::clean(&m_free_list); }
 
 	UINT count_mem() const
 	{
 		//Do not count SC containers, they belong to input pool.
-		return SLISTC<T>::count_mem();
+		return SListCore<T>::count_mem();
 	}
 
 	//Insert 't' into list after the 'marker'.
 	SC<T> * insert_after(T t, IN SC<T> * marker)
 	{
 		IS_TRUE0(m_free_list_pool);
-		return SLISTC<T>::insert_after(t, marker, 
+		return SListCore<T>::insert_after(t, marker, 
 						&m_free_list, m_free_list_pool);
 	}
 
@@ -1716,7 +1737,7 @@ public:
 	bool remove(T t)
 	{
 		IS_TRUE0(m_free_list_pool);
-		return SLISTC<T>::remove(t, &m_free_list);
+		return SListCore<T>::remove(t, &m_free_list);
 	}
 
 	//Return element removed.
@@ -1724,21 +1745,21 @@ public:
 	T remove(SC<T> * prev, SC<T> * holder)
 	{
 		IS_TRUE0(m_free_list_pool);
-		return SLISTC<T>::remove(prev, holder, &m_free_list);
+		return SListCore<T>::remove(prev, holder, &m_free_list);
 	}
 
 	//Return element removed.
 	T remove_head()
 	{
 		IS_TRUE0(m_free_list_pool);
-		return SLISTC<T>::remove_head(&m_free_list);
+		return SListCore<T>::remove_head(&m_free_list);
 	}
 };
-//END SLIST
+//END SList
 
 
 
-/* The second type of Single List Core.
+/* The second type of Single List.
 
 This kind of single list has a tail pointer that allows you access
 tail element directly via get_tail(). This will be useful if you 
@@ -1750,17 +1771,17 @@ Note the single linked list is different with dual linked list.
 the dual linked list does not use mempool to hold the container.
 Compared to dual linked list, single linked list allocate containers 
 in a const size pool. */
-template <class T> class SLISTC2 {
+template <class T> class SList2 {
 protected:
 	UINT m_elem_count;
 	SC<T> * m_head;
 	SC<T> * m_tail;
 
-	SC<T> * new_sc_container(SMEM_POOL * pool)
+	SC<T> * new_sc_container(SMemPool * pool)
 	{
 		IS_TRUE(pool, ("need mem pool"));
 		IS_TRUE(MEMPOOL_type(pool) == MEM_CONST_SIZE, ("need const size pool"));
-		SC<T> * p = (SC<T>*)smpool_malloc_h_const_size(sizeof(SC<T>), pool);
+		SC<T> * p = (SC<T>*)smpoolMallocConstSize(sizeof(SC<T>), pool);
 		IS_TRUE0(p);
 		::memset(p, 0, sizeof(SC<T>));
 		return p;
@@ -1782,7 +1803,7 @@ protected:
 		*free_list = sc;
 	}
 
-	SC<T> * newsc(SC<T> ** free_list, SMEM_POOL * pool)
+	SC<T> * newsc(SC<T> ** free_list, SMemPool * pool)
 	{
 		SC<T> * c = get_one_sc(free_list);
 		if (c == NULL) {
@@ -1793,24 +1814,19 @@ protected:
 
 	//Check p is the element in list.
 	bool in_list(SC<T> const* p) const
-	{
-		#ifdef _SLOW_CHECK_
+	{		
 		if (p == NULL) { return true; }
 		SC<T> const* t = m_head;
 		while (t != NULL) {
 			if (t == p) { return true; }
 			t = t->next;
 		}
-		return false;
-		#else
-		UNUSED(p);
-		return true;
-		#endif
+		return false;		
 	}
 public:
-	SLISTC2() { init(); }
-	COPY_CONSTRUCTOR(SLISTC2);
-	~SLISTC2() 
+	SList2() { init(); }
+	COPY_CONSTRUCTOR(SList2);
+	~SList2() 
 	{
 		//Note: Before going to the destructor, even if the containers have
 		//been allocated in memory pool, you should free all of them 
@@ -1827,7 +1843,7 @@ public:
 	//Return the end of the list.
 	SC<T> const* end() const { return NULL; }
 	
-	SC<T> * append_tail(T t, SC<T> ** free_list, SMEM_POOL * pool)
+	SC<T> * append_tail(T t, SC<T> ** free_list, SMemPool * pool)
 	{
 		SC<T> * c  = newsc(free_list, pool);
 		IS_TRUE(c != NULL, ("newsc return NULL"));
@@ -1853,7 +1869,7 @@ public:
 		return;
 	}
 
-	SC<T> * append_head(T t, SC<T> ** free_list, SMEM_POOL * pool)
+	SC<T> * append_head(T t, SC<T> ** free_list, SMemPool * pool)
 	{
 		SC<T> * c = newsc(free_list, pool);
 		IS_TRUE(c != NULL, ("newsc return NULL"));
@@ -1877,7 +1893,7 @@ public:
 		return;
 	}
 
-	void copy(IN SLISTC<T> & src, SC<T> ** free_list, SMEM_POOL * pool)
+	void copy(IN SListCore<T> & src, SC<T> ** free_list, SMemPool * pool)
 	{
 		clean(free_list);
 		SC<T> * sct;
@@ -1916,7 +1932,9 @@ public:
 	inline void insert_after(IN SC<T> * c, IN SC<T> * marker)
 	{
 		IS_TRUE0(marker && c && c != marker);
-		IS_TRUE0(in_list(marker));	
+		#ifdef _SLOW_CHECK_
+		IS_TRUE0(in_list(marker));
+		#endif
 		
 		c->next = marker->next;
 		marker->next = c;
@@ -1925,10 +1943,12 @@ public:
 
 	//Insert 't' into list after the 'marker'.
 	inline SC<T> * insert_after(T t, IN SC<T> * marker, SC<T> ** free_list,
-								SMEM_POOL * pool)
+								SMemPool * pool)
 	{
 		IS_TRUE0(marker);
+		#ifdef _SLOW_CHECK_
 		IS_TRUE0(in_list(marker));
+		#endif
 		
 		SC<T> * c = newsc(free_list, pool);
 		IS_TRUE(c, ("newc return NULL"));
@@ -1949,7 +1969,7 @@ public:
 	//Return the next container.
 	SC<T> * get_next(IN SC<T> * holder) const
 	{
-		IS_TRUE0(holder && in_list(holder));
+		IS_TRUE0(holder);		
 		return SC_next(holder);
 	}
 
@@ -2004,8 +2024,10 @@ public:
 	{
 		IS_TRUE0(holder);
 		IS_TRUE(m_head != NULL, ("list is empty"));		
+		#ifdef _SLOW_CHECK_
 		IS_TRUE0(in_list(prev));
 		IS_TRUE0(in_list(holder));
+		#endif		
 		
 		if (prev == NULL) {
 			IS_TRUE0(holder == m_head);
@@ -2046,25 +2068,25 @@ public:
 		return t;
 	}
 };
-//END SLISTC2
+//END SList2
 
 
 
-/* The Extended LIST
+/* The Extended List
 
-Add a hash-mapping table upon LIST in order to speed up the process
+Add a hash-mapping table upon List in order to speed up the process
 when inserting or removing an element if a 'marker' given.
 
 NOTICE: User must define a mapping class bewteen. */
-template <class T, class MAP_T2HOLDER> class ELIST : public LIST<T> {
+template <class T, class MapTypename2Holder> class EList : public List<T> {
 protected:
-	MAP_T2HOLDER m_t2holder_map; //map 't' to its LIST HOLDER.
+	MapTypename2Holder m_typename2holder; //map typename 'T' to its list holder.
 public:
-	ELIST() {}
-	COPY_CONSTRUCTOR(ELIST);
-	virtual ~ELIST() {} //MAP_T2HOLDER has virtual function.
+	EList() {}
+	COPY_CONSTRUCTOR(EList);
+	virtual ~EList() {} //MapTypename2Holder has virtual function.
 
-	void copy(IN LIST<T> & src)
+	void copy(IN List<T> & src)
 	{
 		clean();
 		T t = src.get_head();
@@ -2076,96 +2098,98 @@ public:
 
 	void clean()
 	{
-		LIST<T>::clean();
-		m_t2holder_map.clean();
+		List<T>::clean();
+		m_typename2holder.clean();
 	}
 
 	UINT count_mem() const
 	{
-		UINT count = m_t2holder_map.count_mem();
-		count += ((LIST<T>*)this)->count_mem();
+		UINT count = m_typename2holder.count_mem();
+		count += ((List<T>*)this)->count_mem();
 		return count;
 	}
 
 	C<T> * append_tail(T t)
 	{
-		C<T> * c = LIST<T>::append_tail(t);
-		m_t2holder_map.aset(t, c);
+		C<T> * c = List<T>::append_tail(t);
+		m_typename2holder.aset(t, c);
 		return c;
 	}
 
 	C<T> * append_head(T t)
 	{
-		C<T> * c = LIST<T>::append_head(t);
-		m_t2holder_map.aset(t, c);
+		C<T> * c = List<T>::append_head(t);
+		m_typename2holder.aset(t, c);
 		return c;
 	}
 
-	void append_tail(IN LIST<T> & list)
+	void append_tail(IN List<T> & list)
 	{
 		UINT i = 0;
 		C<T> * c;
 		for (T t = list.get_head(); i < list.get_elem_count();
 			 i++, t = list.get_next()) {
-			c = LIST<T>::append_tail(t);
-			m_t2holder_map.aset(t, c);
+			c = List<T>::append_tail(t);
+			m_typename2holder.aset(t, c);
 		}
 	}
 
-	void append_head(IN LIST<T> & list)
+	void append_head(IN List<T> & list)
 	{
 		UINT i = 0;
 		C<T> * c;
 		for (T t = list.get_tail(); i < list.get_elem_count();
 			 i++, t = list.get_prev()) {
-			c = LIST<T>::append_head(t);
-			m_t2holder_map.aset(t, c);
+			c = List<T>::append_head(t);
+			m_typename2holder.aset(t, c);
 		}
 	}
 
 	T remove(T t)
 	{
-		C<T> * c = m_t2holder_map.get(t);
+		C<T> * c = m_typename2holder.get(t);
 		if (c == NULL) {
 			return T(0);
 		}
-		T tt = LIST<T>::remove(c);
-		m_t2holder_map.aset(t, NULL);
+		T tt = List<T>::remove(c);
+		m_typename2holder.aset(t, NULL);
 		return tt;
 	}
 
 	T remove(C<T> * holder)
 	{
-		IS_TRUE0(m_t2holder_map.get(C_val(holder)) == holder);
-		T t = LIST<T>::remove(holder);
-		m_t2holder_map.aset(t, NULL);
+		IS_TRUE0(m_typename2holder.get(C_val(holder)) == holder);
+		T t = List<T>::remove(holder);
+		m_typename2holder.aset(t, NULL);
 		return t;
 	}
+	
 	T remove_tail()
 	{
-		T t = LIST<T>::remove_tail();
-		m_t2holder_map.aset(t, NULL);
+		T t = List<T>::remove_tail();
+		m_typename2holder.aset(t, NULL);
 		return t;
 	}
+
 	T remove_head()
 	{
-		T t = LIST<T>::remove_head();
-		m_t2holder_map.aset(t, NULL);
+		T t = List<T>::remove_head();
+		m_typename2holder.aset(t, NULL);
 		return t;
 	}
 
 	//NOTICE: 'marker' should have been in the list.
 	C<T> * insert_before(T t, T marker)
 	{
-		C<T> * marker_holder = m_t2holder_map.get(marker);
+		C<T> * marker_holder = m_typename2holder.get(marker);
 		if (marker_holder == NULL) {
-			IS_TRUE0(LIST<T>::get_elem_count() == 0);
-			C<T> * t_holder = LIST<T>::append_head(t);
-			m_t2holder_map.aset(t, t_holder);
+			IS_TRUE0(List<T>::get_elem_count() == 0);
+			C<T> * t_holder = List<T>::append_head(t);
+			m_typename2holder.aset(t, t_holder);
 			return t_holder;
 		}
-		C<T> * t_holder = LIST<T>::insert_before(t, marker_holder);
-		m_t2holder_map.aset(t, t_holder);
+		C<T> * t_holder = List<T>::insert_before(t, marker_holder);
+		m_typename2holder.aset(t, t_holder);
 		return t_holder;
 	}
 
@@ -2173,56 +2197,56 @@ public:
 	//and marker will be modified.
 	C<T> * insert_before(T t, C<T> * marker)
 	{
-		IS_TRUE0(marker && m_t2holder_map.get(C_val(marker)) == marker);
-		C<T> * t_holder = LIST<T>::insert_before(t, marker);
-		m_t2holder_map.aset(t, t_holder);
+		IS_TRUE0(marker && m_typename2holder.get(C_val(marker)) == marker);
+		C<T> * t_holder = List<T>::insert_before(t, marker);
+		m_typename2holder.aset(t, t_holder);
 		return t_holder;
 	}
 
 	//NOTICE: 'marker' should have been in the list.
 	void insert_before(C<T> * c, C<T> * marker)
 	{
-		IS_TRUE0(c && marker && m_t2holder_map.get(C_val(marker)) == marker);
-		LIST<T>::insert_before(c, marker);
-		m_t2holder_map.aset(C_val(c), c);
+		IS_TRUE0(c && marker && m_typename2holder.get(C_val(marker)) == marker);
+		List<T>::insert_before(c, marker);
+		m_typename2holder.aset(C_val(c), c);
 	}
 
 	//NOTICE: 'marker' should have been in the list.
 	C<T> * insert_after(T t, T marker)
 	{
-		C<T> * marker_holder = m_t2holder_map.get(marker);
+		C<T> * marker_holder = m_typename2holder.get(marker);
 		if (marker_holder == NULL) {
-			IS_TRUE0(LIST<T>::get_elem_count() == 0);
-			C<T> * t_holder = LIST<T>::append_tail(t);
-			m_t2holder_map.aset(t, t_holder);
+			IS_TRUE0(List<T>::get_elem_count() == 0);
+			C<T> * t_holder = List<T>::append_tail(t);
+			m_typename2holder.aset(t, t_holder);
 			return t_holder;
 		}
-		C<T> * t_holder = LIST<T>::insert_after(t, marker_holder);
-		m_t2holder_map.aset(t, t_holder);
+		C<T> * t_holder = List<T>::insert_after(t, marker_holder);
+		m_typename2holder.aset(t, t_holder);
 		return t_holder;
 	}
 
 	//NOTICE: 'marker' should have been in the list.
 	C<T> * insert_after(T t, C<T> * marker)
 	{
-		IS_TRUE0(marker && m_t2holder_map.get(C_val(marker)) == marker);
+		IS_TRUE0(marker && m_typename2holder.get(C_val(marker)) == marker);
 		C<T> * marker_holder = marker;
-		C<T> * t_holder = LIST<T>::insert_after(t, marker_holder);
-		m_t2holder_map.aset(t, t_holder);
+		C<T> * t_holder = List<T>::insert_after(t, marker_holder);
+		m_typename2holder.aset(t, t_holder);
 		return t_holder;
 	}
 
 	//NOTICE: 'marker' should have been in the list.
 	void insert_after(C<T> * c, C<T> * marker)
 	{
-		IS_TRUE0(c && marker && m_t2holder_map.get(C_val(marker)) == marker);
-		LIST<T>::insert_after(c, marker);
-		m_t2holder_map.aset(C_val(c), c);
+		IS_TRUE0(c && marker && m_typename2holder.get(C_val(marker)) == marker);
+		List<T>::insert_after(c, marker);
+		m_typename2holder.aset(C_val(c), c);
 	}
 
-	bool find(T t, C<T> ** holder = NULL)
+	bool find(T t, C<T> ** holder = NULL) const
 	{
-		C<T> * c = m_t2holder_map.get(t);
+		C<T> * c = m_typename2holder.get(t);
 		if (c == NULL) {
 			return false;
 		}
@@ -2232,88 +2256,88 @@ public:
 		return true;
 	}
 
-	MAP_T2HOLDER * get_holder_map() { return &m_t2holder_map; }
+	MapTypename2Holder * get_holder_map() const { return &m_typename2holder; }
 
-	T get_cur() //Do NOT update 'm_cur'
-	{ return LIST<T>::get_cur(); }
+	T get_cur() const //Do NOT update 'm_cur'
+	{ return List<T>::get_cur(); }
 
-	T get_cur(IN OUT C<T> ** holder) //Do NOT update 'm_cur'
-	{ return LIST<T>::get_cur(holder); }
+	T get_cur(IN OUT C<T> ** holder) const //Do NOT update 'm_cur'
+	{ return List<T>::get_cur(holder); }
 
 	T get_next() //Update 'm_cur'
-	{ return LIST<T>::get_next(); }
+	{ return List<T>::get_next(); }
 	
 	T get_prev() //Update 'm_cur'
-	{ return LIST<T>::get_prev(); }
+	{ return List<T>::get_prev(); }
 	
-	T get_next(IN OUT C<T> ** holder) //Do NOT update 'm_cur'
-	{ return LIST<T>::get_next(holder); }
+	T get_next(IN OUT C<T> ** holder) const //Do NOT update 'm_cur'
+	{ return List<T>::get_next(holder); }
 
-	C<T> * get_next(IN C<T> * holder) //Do NOT update 'm_cur'
-	{ return LIST<T>::get_next(holder); }
+	C<T> * get_next(IN C<T> * holder) const //Do NOT update 'm_cur'
+	{ return List<T>::get_next(holder); }
 	
-	T get_prev(IN OUT C<T> ** holder) //Do NOT update 'm_cur'
-	{ return LIST<T>::get_prev(holder); }
+	T get_prev(IN OUT C<T> ** holder) const //Do NOT update 'm_cur'
+	{ return List<T>::get_prev(holder); }
 
-	C<T> * get_prev(IN C<T> * holder) //Do NOT update 'm_cur'
-	{ return LIST<T>::get_prev(holder); }
+	C<T> * get_prev(IN C<T> * holder) const //Do NOT update 'm_cur'
+	{ return List<T>::get_prev(holder); }
 	
-	T get_next(T marker) //not update 'm_cur'
+	T get_next(T marker) const //not update 'm_cur'
 	{
 		C<T> * holder;
 		find(marker, &holder);
-		IS_TRUE0(holder  != NULL);
-		return LIST<T>::get_next(&holder);
+		IS_TRUE0(holder != NULL);
+		return List<T>::get_next(&holder);
 	}
 	
-	T get_prev(T marker) //not update 'm_cur'
+	T get_prev(T marker) const //not update 'm_cur'
 	{
 		C<T> * holder;
 		find(marker, &holder);
-		IS_TRUE0(holder  != NULL);
-		return LIST<T>::get_prev(&holder);
+		IS_TRUE0(holder != NULL);
+		return List<T>::get_prev(&holder);
 	}
 
 	//Return the container of 'newt'.
 	C<T> * replace(T oldt, T newt)
 	{
-		C<T> * old_holder = m_t2holder_map.get(oldt);
+		C<T> * old_holder = m_typename2holder.get(oldt);
 		IS_TRUE(old_holder != NULL, ("old elem not exist"));
 
 		//add new one
-		C<T> * new_holder = LIST<T>::insert_before(newt, old_holder);
-		m_t2holder_map.aset(newt, new_holder);
+		C<T> * new_holder = List<T>::insert_before(newt, old_holder);
+		m_typename2holder.aset(newt, new_holder);
 
 		//remove old one
-		m_t2holder_map.aset(oldt, NULL);
-		LIST<T>::remove(old_holder);
+		m_typename2holder.aset(oldt, NULL);
+		List<T>::remove(old_holder);
 		return new_holder;
 	}
 };
-//END ELIST
+//END EList
 
 
 
 //STACK
-template <class T> class SSTACK : public LIST<T> {
+template <class T> class Stack : public List<T> {
 public:
-	SSTACK() {}
-	COPY_CONSTRUCTOR(SSTACK);
+	Stack() {}
+	COPY_CONSTRUCTOR(Stack);
 
-	void push(T t) { LIST<T>::append_tail(t); }
-	T pop() { return LIST<T>::remove_tail(); }
+	void push(T t) { List<T>::append_tail(t); }
+	T pop() { return List<T>::remove_tail(); }
 
-	T get_bottom() { return LIST<T>::get_head(); }
-	T get_top() { return LIST<T>::get_tail(); }
-	T get_top_nth(INT n) { return LIST<T>::get_tail_nth(n); }
-	T get_bottom_nth(INT n) { return LIST<T>::get_head_nth(n); }
+	T get_bottom() { return List<T>::get_head(); }
+	T get_top() { return List<T>::get_tail(); }
+	T get_top_nth(INT n) { return List<T>::get_tail_nth(n); }
+	T get_bottom_nth(INT n) { return List<T>::get_head_nth(n); }
 };
-//END SSTACK
+//END Stack
 
 
 
 /*
-SVECTOR
+Vector
 
 T refer to element type.
 NOTE: zero is reserved and regard it as the default NULL when we
@@ -2321,7 +2345,7 @@ determine whether an element is exist.
 The vector grow dynamic.
 */
 #define SVEC_init(s)		((s)->m_is_init)
-template <class T, UINT GROW_SIZE = 8> class SVECTOR {
+template <class T, UINT GrowSize = 8> class Vector {
 protected:
 	UINT m_elem_num:31; //The number of element in vector.
 	
@@ -2332,22 +2356,22 @@ protected:
 public:
 	T * m_vec;
 
-	SVECTOR()
+	Vector()
 	{
 		SVEC_init(this) = false;
 		init();
 	}
 	
-	explicit SVECTOR(INT size)
+	explicit Vector(INT size)
 	{
 		SVEC_init(this) = false;
 		init();
 		grow(size);
 	}
 	
-	SVECTOR(SVECTOR const& vec) { copy(vec); }
-	SVECTOR const& operator = (SVECTOR const&);	
-	~SVECTOR() { destroy();	}
+	Vector(Vector const& vec) { copy(vec); }
+	Vector const& operator = (Vector const&);	
+	~Vector() { destroy();	}
 
 	void add(T t)
 	{
@@ -2432,10 +2456,10 @@ public:
 
 	/* Copy each elements of 'list' into vector.
 	NOTE: The default termination factor is '0'.
-		While we traversing elements of LIST one by one, or from head to
+		While we traversing elements of List one by one, or from head to
 		tail or on opposition way, one can copy list into vector first and
 		iterating the vector instead of travering list. */
-	void copy(LIST<T> & list)
+	void copy(List<T> & list)
 	{
 		INT count = 0;
 		set(list.get_elem_count() - 1, 0); //Alloc memory right away.
@@ -2445,7 +2469,7 @@ public:
 		}
 	}
 
-	void copy(SVECTOR const& vec)
+	void copy(Vector const& vec)
 	{
 		IS_TRUE0(vec.m_elem_num > 0 ||
 				 (vec.m_elem_num == 0 && vec.m_last_idx == -1));
@@ -2472,7 +2496,7 @@ public:
 	}
 
 	inline UINT count_mem() const
-	{ return m_elem_num * sizeof(T) + sizeof(SVECTOR<T>); }
+	{ return m_elem_num * sizeof(T) + sizeof(Vector<T>); }
 
 	//Place elem to vector according to index. 
 	//Growing vector if 'index' is greater than m_elem_num.
@@ -2497,7 +2521,7 @@ public:
 	{
 		IS_TRUE(is_init(), ("VECTOR not yet initialized."));
 		IS_TRUE(m_last_idx < (INT)m_elem_num,
-				("Last index ran over SVECTOR's size."));
+				("Last index ran over Vector's size."));
 		return m_last_idx;
 	}	
 
@@ -2527,59 +2551,59 @@ public:
 		m_elem_num = size;
 	}
 };
-//END SVECTOR
+//END Vector
 
 
 
-/* The extented class to SVECTOR.
-This class maintains an index which call Free Index of SVECTOR.
+/* The extented class to Vector.
+This class maintains an index which call Free Index of Vector.
 User can use the Free Index to get to know which slot of vector
 is T(0).
 
-e.g: assume SVECTOR<INT> has 6 elements, {0, 3, 4, 0, 5, 0}.
+e.g: assume Vector<INT> has 6 elements, {0, 3, 4, 0, 5, 0}.
 Three of them are 0, where T(0) served as default NULL and these 
 elements indicate free slot. 
 In the case, the first free index is 0, the second is 3, and the 
 third is 5. */
-template <class T, UINT GROW_SIZE = 8> 
-class SVECTOR_WITH_FREEIDX : public SVECTOR<T, GROW_SIZE> {
+template <class T, UINT GrowSize = 8> 
+class SVectorWithFreeIndex : public Vector<T, GrowSize> {
 protected:
-	//Always refers to free space to SVECTOR,
+	//Always refers to free space to Vector,
 	//and the first free space position is '0'
 	UINT m_free_idx;
 public:
-	SVECTOR_WITH_FREEIDX()
+	SVectorWithFreeIndex()
 	{
 		SVEC_init(this) = false;
 		init();
 	}
-	COPY_CONSTRUCTOR(SVECTOR_WITH_FREEIDX);
+	COPY_CONSTRUCTOR(SVectorWithFreeIndex);
 	inline void init()
 	{
-		SVECTOR<T, GROW_SIZE>::init();
+		Vector<T, GrowSize>::init();
 		m_free_idx = 0;
 	}
 	
 	inline void init(UINT size)
 	{
-		SVECTOR<T, GROW_SIZE>::init(size);
+		Vector<T, GrowSize>::init(size);
 		m_free_idx = 0;
 	}
 
-	void copy(SVECTOR_WITH_FREEIDX const& vec)
+	void copy(SVectorWithFreeIndex const& vec)
 	{
-		SVECTOR<T, GROW_SIZE>::copy(vec);
+		Vector<T, GrowSize>::copy(vec);
 		m_free_idx = vec.m_free_idx;
 	}
 
 	//Clean to zero(default) till 'last_idx'.
 	void clean()
 	{		
-		SVECTOR<T, GROW_SIZE>::clean();
+		Vector<T, GrowSize>::clean();
 		m_free_idx = 0;
 	}
 
-	/* Return index of free-slot into SVECTOR, and allocate memory 
+	/* Return index of free-slot into Vector, and allocate memory 
 	if there are not any free-slots.
 
 	v: default NULL value.
@@ -2589,14 +2613,14 @@ public:
 		value of that slot is equal to v. */
 	UINT get_free_idx(T v = T(0))
 	{
-		IS_TRUE((SVECTOR<T, GROW_SIZE>::is_init()), 
+		IS_TRUE((Vector<T, GrowSize>::is_init()), 
 				("VECTOR not yet initialized."));
-		if (SVECTOR<T, GROW_SIZE>::m_elem_num == 0) {
+		if (Vector<T, GrowSize>::m_elem_num == 0) {
 			//VECTOR is empty.
-			IS_TRUE((SVECTOR<T, GROW_SIZE>::m_last_idx < 0 && 
-					 SVECTOR<T, GROW_SIZE>::m_vec == NULL),
-					("exception occur in SVECTOR"));
-			grow(GROW_SIZE);
+			IS_TRUE((Vector<T, GrowSize>::m_last_idx < 0 && 
+					 Vector<T, GrowSize>::m_vec == NULL),
+					("exception occur in Vector"));
+			grow(GrowSize);
 
 			//Free space is started at position '0',
 			//so next free space is position '1'.
@@ -2607,26 +2631,25 @@ public:
 		//VECTOR is not empty.
 		UINT ret = m_free_idx;
 
-		//Seaching in second-half SVECTOR to find the next free idx.
-		for (UINT i = m_free_idx + 1; 
-			 i < (INT)SVECTOR<T, GROW_SIZE>::m_elem_num; i++) {
-			if (v == SVECTOR<T, GROW_SIZE>::m_vec[i]) {
+		//Seaching in second-half Vector to find the next free idx.
+		for (UINT i = m_free_idx + 1; i < Vector<T, GrowSize>::m_elem_num; i++) {
+			if (v == Vector<T, GrowSize>::m_vec[i]) {
 				m_free_idx = i;
 				return ret;
 			}
 		}
 
-		//Seaching in first-half SVECTOR to find the next free idx.
+		//Seaching in first-half Vector to find the next free idx.
 		for (UINT i = 0; i < m_free_idx; i++) {
-			if (v == SVECTOR<T, GROW_SIZE>::m_vec[i]) {
+			if (v == Vector<T, GrowSize>::m_vec[i]) {
 				m_free_idx = i;
 				return ret;
 			}
 		}
 
-		m_free_idx = SVECTOR<T, GROW_SIZE>::m_elem_num;
+		m_free_idx = Vector<T, GrowSize>::m_elem_num;
 			
-		grow(SVECTOR<T, GROW_SIZE>::m_elem_num * 2);
+		grow(Vector<T, GrowSize>::m_elem_num * 2);
 			
 		return ret;
 	}
@@ -2635,10 +2658,10 @@ public:
 	Reallocate memory if necessory. */
 	void grow(UINT size)
 	{
-		if (SVECTOR<T, GROW_SIZE>::m_elem_num == 0) {
+		if (Vector<T, GrowSize>::m_elem_num == 0) {
 			m_free_idx = 0;
 		}
-		SVECTOR<T, GROW_SIZE>::grow(size);
+		Vector<T, GrowSize>::grow(size);
 	}
 };
 
@@ -2651,8 +2674,8 @@ T: refer to element type.
 NOTE: Zero is treated as the default NULL when we
 determine the element existence.
 */
-#define SSVEC_elem_num(s)		((s)->s1.m_elem_num)
-template <class T, UINT GROW_SIZE> class SSVEC {
+#define SVEC_elem_num(s)		((s)->s1.m_elem_num)
+template <class T, UINT GrowSize> class SimpleVec {
 protected:
 	struct {
 		UINT m_elem_num:31;	//The number of element in vector.
@@ -2661,24 +2684,24 @@ protected:
 public:
 	T * m_vec;
 
-	SSVEC()
+	SimpleVec()
 	{
 		s1.m_is_init = false;
 		init();
 	}
-	explicit SSVEC(INT size)
+	explicit SimpleVec(INT size)
 	{
 		s1.m_is_init = false;
 		init(size);
 	}
-	SSVEC(SSVEC const& src) { copy(src); }
-	SSVEC const& operator = (SSVEC const&);
-	~SSVEC() { destroy(); }
+	SimpleVec(SimpleVec const& src) { copy(src); }
+	SimpleVec const& operator = (SimpleVec const&);
+	~SimpleVec() { destroy(); }
 
 	inline void init()
 	{
 		if (s1.m_is_init) { return; }
-		SSVEC_elem_num(this) = 0;
+		SVEC_elem_num(this) = 0;
 		m_vec = NULL;
 		s1.m_is_init = true;
 	}
@@ -2690,14 +2713,14 @@ public:
 		m_vec = (T*)::malloc(sizeof(T) * size);
 		IS_TRUE0(m_vec);
 		::memset(m_vec, 0, sizeof(T) * size);
-		SSVEC_elem_num(this) = size;
+		SVEC_elem_num(this) = size;
 		s1.m_is_init = true;
 	}
 
 	inline void destroy()
 	{
 		if (!s1.m_is_init) { return; }
-		SSVEC_elem_num(this) = 0;
+		SVEC_elem_num(this) = 0;
 		if (m_vec != NULL) {
 			::free(m_vec);
 			m_vec = NULL;
@@ -2717,16 +2740,16 @@ public:
 	T get(UINT i) const
 	{
 		IS_TRUE(s1.m_is_init, ("VECTOR not yet initialized."));
-		if (i >= SSVEC_elem_num(this)) { return T(0); }
+		if (i >= SVEC_elem_num(this)) { return T(0); }
 		return m_vec[i];
 	}
 
 	T * get_vec() { return m_vec; }
 
-	void copy(SSVEC const& vec)
+	void copy(SimpleVec const& vec)
 	{
-		UINT n = SSVEC_elem_num(&vec);
-		if (SSVEC_elem_num(this) < n) {
+		UINT n = SVEC_elem_num(&vec);
+		if (SVEC_elem_num(this) < n) {
 			destroy();
 			init(n);
 		}
@@ -2739,17 +2762,17 @@ public:
 	void clean()
 	{
 		IS_TRUE(s1.m_is_init, ("VECTOR not yet initialized."));
-		memset(m_vec, 0, sizeof(T) * SSVEC_elem_num(this));
+		memset(m_vec, 0, sizeof(T) * SVEC_elem_num(this));
 	}
 
 	inline UINT count_mem() const
-	{ return SSVEC_elem_num(this) + sizeof(SVECTOR<T>); }
+	{ return SVEC_elem_num(this) + sizeof(Vector<T>); }
 
 	//Return NULL if 'i' is illegal, otherwise return 'elem'.
 	void set(UINT i, T elem)
 	{
 		IS_TRUE(is_init(), ("VECTOR not yet initialized."));
-		if (i >= SSVEC_elem_num(this)) {
+		if (i >= SVEC_elem_num(this)) {
 			grow(i * 2 + 1);
 		}
 		m_vec[i] = elem;
@@ -2759,7 +2782,7 @@ public:
 	UINT get_size() const
 	{
 		IS_TRUE(is_init(), ("VECTOR not yet initialized."));
-		return SSVEC_elem_num(this);
+		return SVEC_elem_num(this);
 	}
 
 	/* Growing vector by size, if 'm_size' is NULL , alloc vector.
@@ -2768,24 +2791,24 @@ public:
 	{
 		IS_TRUE(is_init(), ("VECTOR not yet initialized."));
 		if (size == 0) { return; }
-		if (SSVEC_elem_num(this) == 0) {
+		if (SVEC_elem_num(this) == 0) {
 			IS_TRUE(m_vec == NULL, ("vector should be NULL if size is zero."));
 			m_vec = (T*)::malloc(sizeof(T) * size);
 			IS_TRUE0(m_vec);
 			memset(m_vec, 0, sizeof(T) * size);
-			SSVEC_elem_num(this) = size;
+			SVEC_elem_num(this) = size;
 			return;
 		}
 
-		IS_TRUE0(size > SSVEC_elem_num(this));
+		IS_TRUE0(size > SVEC_elem_num(this));
 		T * tmp = (T*)::malloc(size * sizeof(T));
 		IS_TRUE0(tmp);
-		memcpy(tmp, m_vec, SSVEC_elem_num(this) * sizeof(T));
-		memset(((CHAR*)tmp) + SSVEC_elem_num(this) * sizeof(T),
-			   0 , (size - SSVEC_elem_num(this))* sizeof(T));
+		memcpy(tmp, m_vec, SVEC_elem_num(this) * sizeof(T));
+		memset(((CHAR*)tmp) + SVEC_elem_num(this) * sizeof(T),
+			   0 , (size - SVEC_elem_num(this))* sizeof(T));
 		::free(m_vec);
 		m_vec = tmp;
-		SSVEC_elem_num(this) = size;
+		SVEC_elem_num(this) = size;
 	}
 
 	bool is_init() const { return s1.m_is_init; }
@@ -2794,13 +2817,13 @@ public:
 
 
 /*
-SHASH
+SHash
 
-Hash element recorded not only in hash table but also in SVECTOR,
+Hash element recorded not only in hash table but also in Vector,
 which is used in order to speed up accessing hashed elements.
 
 NOTICE:
-	1.T(0) is defined as default NULL in SHASH, so do not use T(0) as element.
+	1.T(0) is defined as default NULL in SHash, so do not use T(0) as element.
 
 	2.There are four hash function classes are given as default, and
 	  if you are going to define you own hash function class, the
@@ -2834,14 +2857,14 @@ template <class T> struct HC {
 
 #define SHB_member(hm)		(hm).hash_member
 #define SHB_count(hm)		(hm).hash_member_count
-class SHASH_BUCKET {
+class SHashBucket {
 public:
     void * hash_member; //hash member list
 	UINT hash_member_count; //
 };
 
 
-template <class T> class HASH_FUNC_BASE {
+template <class T> class HashFuncBase {
 public:
 	UINT get_hash_value(T t, UINT bucket_size) const
 	{
@@ -2863,7 +2886,7 @@ public:
 };
 
 
-template <class T> class HASH_FUNC_BASE2 : public HASH_FUNC_BASE<T> {
+template <class T> class HashFuncBase2 : public HashFuncBase<T> {
 public:
 	UINT get_hash_value(T t, UINT bucket_size) const
 	{
@@ -2876,12 +2899,12 @@ public:
 	{
 		IS_TRUE0(bucket_size != 0);
 		IS_TRUE0(is_power_of_2(bucket_size));
-		return hash32bit((UINT)val) & (bucket_size - 1);
+		return hash32bit((UINT)(size_t)val) & (bucket_size - 1);
 	}
 };
 
 
-class HASH_FUNC_STR {
+class HashFuncString {
 public:
 	UINT get_hash_value(CHAR const* s, UINT bucket_size) const
 	{
@@ -2912,7 +2935,7 @@ public:
 };
 
 
-class HASH_FUNC_STR2 : public HASH_FUNC_STR {
+class HashFuncString2 : public HashFuncString {
 public:
 	UINT get_hash_value(CHAR const* s, UINT bucket_size) const
 	{
@@ -2929,14 +2952,14 @@ public:
 
 //'T': the element type.
 //'HF': Hash function type.
-template <class T, class HF = HASH_FUNC_BASE<T> > class SHASH {
+template <class T, class HF = HashFuncBase<T> > class SHash {
 protected:
 	HF m_hf;
-	SMEM_POOL * m_free_list_pool;
-	FREE_LIST<HC<T> > m_free_list; //Hold for available containers
+	SMemPool * m_free_list_pool;
+	FreeList<HC<T> > m_free_list; //Hold for available containers
 	UINT m_bucket_size;
-	SHASH_BUCKET * m_bucket;
-	SVECTOR_WITH_FREEIDX<T, 8> m_elem_vector;
+	SHashBucket * m_bucket;
+	SVectorWithFreeIndex<T, 8> m_elem_vector;
 	UINT m_elem_count;
 
 	inline HC<T> * newhc() //Allocate hash container.
@@ -2945,7 +2968,7 @@ protected:
 		IS_TRUE0(m_free_list_pool);
 		HC<T> * c = m_free_list.get_free_elem();
 		if (c == NULL) {
-			c = (HC<T>*)smpool_malloc_h_const_size(sizeof(HC<T>),
+			c = (HC<T>*)smpoolMallocConstSize(sizeof(HC<T>),
 												m_free_list_pool);
 			IS_TRUE0(c);
 			memset(c, 0, sizeof(HC<T>));
@@ -3017,11 +3040,11 @@ protected:
 	virtual T create(OBJTY v)
 	{
 		IS_TRUE(0, ("Inherited class need to implement"));
-		v = v;
+		UNUSED(v);
 		return T(0);
 	}
 public:
-	SHASH(UINT bsize = MAX_SHASH_BUCKET)
+	SHash(UINT bsize = MAX_SHASH_BUCKET)
 	{
 		m_bucket = NULL;
 		m_bucket_size = 0;
@@ -3029,11 +3052,11 @@ public:
 		m_elem_count = 0;
 		init(bsize);
 	}
-	COPY_CONSTRUCTOR(SHASH);
-	virtual ~SHASH() { destroy(); }
+	COPY_CONSTRUCTOR(SHash);
+	virtual ~SHash() { destroy(); }
 
 	/* Append 't' into hash table and record its reference into
-	SVECTOR in order to walk through the table rapidly.
+	Vector in order to walk through the table rapidly.
 	If 't' already exists, return the element immediately.
 	'find': set to true if 't' already exist.
 	
@@ -3042,7 +3065,7 @@ public:
 		Maximum size of T equals sizeof(void*). */
 	T append(T t, OUT HC<T> ** hct = NULL, bool * find = NULL)
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		if (t == T(0)) return T(0);
 	
 		UINT hashv = m_hf.get_hash_value(t, m_bucket_size);
@@ -3077,7 +3100,7 @@ public:
 	NOTE: Do NOT append T(0) to table. */
 	T append(OBJTY val, OUT HC<T> ** hct = NULL, bool * find = NULL)
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		UINT hashv = m_hf.get_hash_value(val, m_bucket_size);
 	
 		IS_TRUE(hashv < m_bucket_size, ("hash value must less than bucket size"));
@@ -3105,7 +3128,7 @@ public:
 	//Count up the memory which hash table used.
 	UINT count_mem() const
 	{
-		UINT count = smpool_get_pool_size_handle(m_free_list_pool);
+		UINT count = smpoolGetPoolSize(m_free_list_pool);
 		count += m_free_list.count_mem();
 		count += sizeof(m_bucket_size);
 		count += sizeof(m_bucket);
@@ -3119,7 +3142,7 @@ public:
 	void clean()
 	{
 		if (m_bucket == NULL) return;
-		memset(m_bucket, 0, sizeof(SHASH_BUCKET) * m_bucket_size);
+		memset(m_bucket, 0, sizeof(SHashBucket) * m_bucket_size);
 		m_elem_count = 0;
 		m_elem_vector.clean();
 	}
@@ -3128,11 +3151,11 @@ public:
 	UINT get_bucket_size() const { return m_bucket_size; }
 
 	//Get the hash bucket.
-	SHASH_BUCKET const* get_bucket() const { return m_bucket; }	
+	SHashBucket const* get_bucket() const { return m_bucket; }	
 	
 	//Get the memory pool handler of free_list.
 	//Note this pool is const size.
-	SMEM_POOL * get_free_list_pool() const { return m_free_list_pool; };
+	SMemPool * get_free_list_pool() const { return m_free_list_pool; };
 
 	//Get the number of element in hash table.
 	UINT get_elem_count() const { return m_elem_count; }
@@ -3148,7 +3171,7 @@ public:
 		or is -1. */
 	T get_first(INT & iter) const
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		T t = T(0);
 		iter = -1;
 		if (m_elem_count <= 0) return T(0);
@@ -3172,7 +3195,7 @@ public:
 		or is -1. */
 	T get_next(INT & iter) const
 	{
-		IS_TRUE(m_bucket != NULL && iter >= -1, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL && iter >= -1, ("SHash not yet initialized."));
 		T t = T(0);
 		if (m_elem_count <= 0) return T(0);
 		INT l = m_elem_vector.get_last_idx();
@@ -3196,7 +3219,7 @@ public:
 		or is -1. */
 	T get_last(INT & iter) const
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		T t = T(0);
 		iter = -1;
 		if (m_elem_count <= 0) return T(0);
@@ -3220,7 +3243,7 @@ public:
 		or is -1. */
 	T get_prev(INT & iter) const
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		T t = T(0);
 		if (m_elem_count <= 0) return T(0);
 		for (INT i = iter - 1; i >= 0; i--) {
@@ -3237,11 +3260,11 @@ public:
 	{
 		if (m_bucket != NULL) return;
 		if (bsize == 0) { return; }
-		m_bucket = (SHASH_BUCKET*)::malloc(sizeof(SHASH_BUCKET) * bsize);
-		memset(m_bucket, 0, sizeof(SHASH_BUCKET) * bsize);
+		m_bucket = (SHashBucket*)::malloc(sizeof(SHashBucket) * bsize);
+		memset(m_bucket, 0, sizeof(SHashBucket) * bsize);
 		m_bucket_size = bsize;
 		m_elem_count = 0;
-		m_free_list_pool = smpool_create_handle(sizeof(HC<T>) * 4, MEM_CONST_SIZE);
+		m_free_list_pool = smpoolCreate(sizeof(HC<T>) * 4, MEM_CONST_SIZE);
 		m_free_list.clean();
 		m_free_list.set_clean(true);
 		m_elem_vector.init();
@@ -3256,7 +3279,7 @@ public:
 		m_bucket_size = 0;
 		m_elem_count = 0;
 		m_elem_vector.destroy();
-		smpool_free_handle(m_free_list_pool);
+		smpoolDelete(m_free_list_pool);
 		m_free_list_pool = NULL;
 	}
 	
@@ -3265,8 +3288,8 @@ public:
 	{
 		if (h == NULL) return;
 		UINT bsize = get_bucket_size();
-		SHASH_BUCKET const* bucket = get_bucket();
-		fprintf(h, "\n=== SHASH ===");
+		SHashBucket const* bucket = get_bucket();
+		fprintf(h, "\n=== SHash ===");
 		for (UINT i = 0; i < bsize; i++) {
 			HC<T> * elemhc = (HC<T>*)bucket[i].hash_member;
 			fprintf(h, "\nENTRY[%d]:", i);
@@ -3290,7 +3313,7 @@ public:
 	get_next(), get_last() and get_prev(). */
 	T removed(T t)
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		if (t == 0) return T(0);
 	
 		UINT hashv = m_hf.get_hash_value(t, m_bucket_size);
@@ -3327,16 +3350,16 @@ public:
 		The position of element in m_elem_vector is unchanged. */
 	void grow(UINT bsize = 0)
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		if (bsize != 0) {
 			IS_TRUE0(bsize > m_bucket_size);
 		} else {
 			bsize = m_bucket_size * 2;
 		}
 	
-		SHASH_BUCKET * new_bucket =
-			(SHASH_BUCKET*)::malloc(sizeof(SHASH_BUCKET) * bsize);
-		memset(new_bucket, 0, sizeof(SHASH_BUCKET) * bsize);
+		SHashBucket * new_bucket =
+			(SHashBucket*)::malloc(sizeof(SHashBucket) * bsize);
+		memset(new_bucket, 0, sizeof(SHashBucket) * bsize);
 		if (m_elem_count == 0) {
 			::free(m_bucket);
 			m_bucket = new_bucket;
@@ -3387,7 +3410,7 @@ public:
 	get_last() and get_prev(). */
 	T find(OBJTY val) const
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		UINT hashv = m_hf.get_hash_value(val, m_bucket_size);
 		IS_TRUE(hashv < m_bucket_size, ("hash value must less than bucket size"));
 		HC<T> const* elemhc = (HC<T> const*)SHB_member(m_bucket[hashv]);
@@ -3412,7 +3435,7 @@ public:
 	get_last() and get_prev(). */
 	bool find(T t, HC<T> const** ct = NULL)
 	{
-		IS_TRUE(m_bucket != NULL, ("SHASH not yet initialized."));
+		IS_TRUE(m_bucket != NULL, ("SHash not yet initialized."));
 		if (t == T(0)) { return false; }
 	
 		UINT hashv = m_hf.get_hash_value(t, m_bucket_size);
@@ -3455,7 +3478,7 @@ public:
 		return false;
 	}	
 };
-//END SHASH
+//END SHash
 
 
 
@@ -3499,25 +3522,25 @@ public:
 };
 
 
-template <class T> class COMPARE_KEY_BASE {
+template <class T> class CompareKeyBase {
 public:
 	bool is_less(T t1, T t2) const { return t1 < t2; }
 	bool is_equ(T t1, T t2) const { return t1 == t2; }
 };
 
-template <class T, class Ttgt, class Compare_Key = COMPARE_KEY_BASE<T> >
+template <class T, class Ttgt, class CompareKey = CompareKeyBase<T> >
 class RBT {
 protected:
 	typedef RBTN<T, Ttgt> TN;
 	UINT m_num_of_tn;
 	TN * m_root;
-	SMEM_POOL * m_pool;
+	SMemPool * m_pool;
 	TN * m_free_list;
-	Compare_Key m_ck;
+	CompareKey m_ck;
 
 	TN * new_tn()
 	{
-		TN * p = (TN*)smpool_malloc_h_const_size(sizeof(TN), m_pool);
+		TN * p = (TN*)smpoolMallocConstSize(sizeof(TN), m_pool);
 		IS_TRUE0(p);
 		memset(p, 0, sizeof(TN));
 		return p;
@@ -3651,7 +3674,7 @@ public:
 	void init()
 	{
 		IS_TRUE0(m_pool == NULL);
-		m_pool = smpool_create_handle(sizeof(TN) * 4, MEM_CONST_SIZE);
+		m_pool = smpoolCreate(sizeof(TN) * 4, MEM_CONST_SIZE);
 		m_root = NULL;
 		m_num_of_tn = 0;
 		m_free_list = NULL;
@@ -3660,7 +3683,7 @@ public:
 	void destroy()
 	{
 		if (m_pool == NULL) { return; }
-		smpool_free_handle(m_pool);
+		smpoolDelete(m_pool);
 		m_pool = NULL;
 		m_num_of_tn = 0;
 		m_root = NULL;
@@ -3673,13 +3696,13 @@ public:
 		c += sizeof(m_root);
 		c += sizeof(m_pool);
 		c += sizeof(m_free_list);
-		c += smpool_get_pool_size_handle(m_pool);
+		c += smpoolGetPoolSize(m_pool);
 		return c;
 	}
 
 	void clean()
 	{
-		LIST<TN*> wl;
+		List<TN*> wl;
 		if (m_root != NULL) {
 			wl.append_tail(m_root);
 			m_root = NULL;
@@ -3698,7 +3721,7 @@ public:
 	}
 
 	UINT get_elem_count() const { return m_num_of_tn; }
-	SMEM_POOL * get_pool() { return m_pool; }
+	SMemPool * get_pool() { return m_pool; }
 	TN const* get_root_c() const { return m_root; }
 	TN * get_root() { return m_root; }
 
@@ -3949,7 +3972,7 @@ public:
 	}
 
 	//iter should be clean by caller.
-	T get_first(LIST<TN*> & iter, Ttgt * mapped = NULL) const
+	T get_first(List<TN*> & iter, Ttgt * mapped = NULL) const
 	{
 		if (m_root == NULL) {
 			if (mapped != NULL) { *mapped = Ttgt(0); }
@@ -3960,7 +3983,7 @@ public:
 		return m_root->key;
 	}
 
-	T get_next(LIST<TN*> & iter, Ttgt * mapped = NULL) const
+	T get_next(List<TN*> & iter, Ttgt * mapped = NULL) const
 	{
 		TN * x = iter.remove_head();
 		if (x == NULL) {
@@ -3987,7 +4010,7 @@ public:
 
 
 /*
-TMAP
+TMap
 
 Make a map between Tsrc and Ttgt.
 
@@ -3995,55 +4018,55 @@ Make a map between Tsrc and Ttgt.
 'Ttgt': target type.
 
 Usage: Make a mapping from SRC* to TGT*.
-	class SRC2TGT_MAP : public TMAP<SRC*, TGT*> {
+	class SRC2TGT_MAP : public TMap<SRC*, TGT*> {
 	public:
 	};
 
 NOTICE:
-	1. Tsrc(0) is defined as default NULL in TMAP, do NOT
+	1. Tsrc(0) is defined as default NULL in TMap, do NOT
 	   use T(0) as element.
 	2. Keep the key *UNIQUE* .
 	3. Overload operator == and operator < if Tsrc is neither basic type
 	   nor pointer type.
 */
 
-/* TMAP Iterator based on Double Linked List.
-This class is used to iterate elements in TMAP.
+/* TMap Iterator based on Double Linked List.
+This class is used to iterate elements in TMap.
 You should call clean() to initialize the iterator. */
 template <class Tsrc, class Ttgt>
-class TMAP_ITER : public LIST<RBTN<Tsrc, Ttgt>*> {
+class TMapIter : public List<RBTN<Tsrc, Ttgt>*> {
 public:
-	TMAP_ITER() {}
-	COPY_CONSTRUCTOR(TMAP_ITER);
+	TMapIter() {}
+	COPY_CONSTRUCTOR(TMapIter);
 };
 
 
-/* TMAP Iterator based on Single Linked List.
-This class is used to iterate elements in TMAP.
+/* TMap Iterator based on Single Linked List.
+This class is used to iterate elements in TMap.
 You should call clean() to initialize the iterator. */
 template <class Tsrc, class Ttgt>
-class TMAP_ITER2 : public SLIST<RBTN<Tsrc, Ttgt>*> {
+class TMapIter2 : public SList<RBTN<Tsrc, Ttgt>*> {
 public:
-	TMAP_ITER2(SMEM_POOL * pool) : SLIST<RBTN<Tsrc, Ttgt>*>(pool)
+	TMapIter2(SMemPool * pool) : SList<RBTN<Tsrc, Ttgt>*>(pool)
 	{ IS_TRUE0(pool); }
-	COPY_CONSTRUCTOR(TMAP_ITER2);
+	COPY_CONSTRUCTOR(TMapIter2);
 };
 
 
-template <class Tsrc, class Ttgt, class Compare_Key = COMPARE_KEY_BASE<Tsrc> >
-class TMAP : public RBT<Tsrc, Ttgt, Compare_Key> {
+template <class Tsrc, class Ttgt, class CompareKey = CompareKeyBase<Tsrc> >
+class TMap : public RBT<Tsrc, Ttgt, CompareKey> {
 public:
-	typedef RBT<Tsrc, Ttgt, Compare_Key> BASE_TY;
+	typedef RBT<Tsrc, Ttgt, CompareKey> BASE_TY;
 	typedef RBTN<Tsrc, Ttgt> TN;
-	TMAP() {}
-	COPY_CONSTRUCTOR(TMAP);
-	~TMAP() {}
+	TMap() {}
+	COPY_CONSTRUCTOR(TMap);
+	~TMap() {}
 
-	//This function should be invoked if TMAP is initialized manually.	
-	void init() { RBT<Tsrc, Ttgt, Compare_Key>::init(); }
+	//This function should be invoked if TMap is initialized manually.	
+	void init() { RBT<Tsrc, Ttgt, CompareKey>::init(); }
 
-	//This function should be invoked if TMAP is destroied manually.	
-	void destroy() { RBT<Tsrc, Ttgt, Compare_Key>::destroy(); }
+	//This function should be invoked if TMap is destroied manually.	
+	void destroy() { RBT<Tsrc, Ttgt, CompareKey>::destroy(); }
 
 	//Alway set new mapping even if it has done.
 	void aset(Tsrc t, Ttgt mapped)
@@ -4065,14 +4088,8 @@ public:
 	}
 
 	//Get mapped element of 't'. Set find to true if t is already be mapped.
-	Ttgt get(Tsrc t, bool * f = NULL)
-	{
-		return get_c(t, f);
-	}
-
-	//Get mapped element of 't'. Set find to true if t is already be mapped.
 	//Note this function is readonly.
-	Ttgt get_c(Tsrc t, bool * f = NULL) const
+	Ttgt get(Tsrc t, bool * f = NULL) const
 	{
 		TN * z = BASE_TY::find_rbtn(t);
 		if (z == NULL) {
@@ -4089,57 +4106,57 @@ public:
 	}
 	
 	//iter should be clean by caller.
-	Tsrc get_first(TMAP_ITER<Tsrc, Ttgt> & iter, Ttgt * mapped = NULL) const
+	Tsrc get_first(TMapIter<Tsrc, Ttgt> & iter, Ttgt * mapped = NULL) const
 	{ return BASE_TY::get_first(iter, mapped); }
 
-	Tsrc get_next(TMAP_ITER<Tsrc, Ttgt> & iter, Ttgt * mapped = NULL) const
+	Tsrc get_next(TMapIter<Tsrc, Ttgt> & iter, Ttgt * mapped = NULL) const
 	{ return BASE_TY::get_next(iter, mapped); }
 
 	bool find(Tsrc t) const
 	{
 		bool f;
-		get_c(t, &f);
+		get(t, &f);
 		return f;
 	}
 };
-//END TMAP
+//END TMap
 
 
 /*
-TTAB
+TTab
 
 NOTICE:
-	1. T(0) is defined as default NULL in TTAB, do not use T(0) as element.
+	1. T(0) is defined as default NULL in TTab, do not use T(0) as element.
 	2. Keep the key *UNIQUE*.
 	3. Overload operator == and operator < if Tsrc is neither basic type
 	   nor pointer type.
 
 	e.g: Make a table to record OPND.
-		class OPND_TAB : public TTAB<OPND*> {
+		class OPND_TAB : public TTab<OPND*> {
 		public:
 		};
 */
 
 /*
-TTAB Iterator.
-This class is used to iterate elements in TTAB.
+TTab Iterator.
+This class is used to iterate elements in TTab.
 You should call clean() to initialize the iterator.
 */
 template <class T>
-class TAB_ITER : public LIST<RBTN<T, T>*> {
+class TabIter : public List<RBTN<T, T>*> {
 public:
-	TAB_ITER() {}
-	COPY_CONSTRUCTOR(TAB_ITER);
+	TabIter() {}
+	COPY_CONSTRUCTOR(TabIter);
 };
 
-template <class T, class Compare_Key = COMPARE_KEY_BASE<T> >
-class TTAB : public TMAP<T, T, Compare_Key> {
+template <class T, class CompareKey = CompareKeyBase<T> >
+class TTab : public TMap<T, T, CompareKey> {
 public:
-	TTAB() {}
-	COPY_CONSTRUCTOR(TTAB);
+	TTab() {}
+	COPY_CONSTRUCTOR(TTab);
 	
-	typedef RBT<T, T, Compare_Key> BASE_TY;
-	typedef TMAP<T, T, Compare_Key> BASE_TTY;
+	typedef RBT<T, T, CompareKey> BASE_TY;
+	typedef TMap<T, T, CompareKey> BASE_TTY;
 
 	//Add element into table.
 	//Note: the element in the table must be unqiue.
@@ -4178,50 +4195,50 @@ public:
 	}
 
 	//iter should be clean by caller.
-	T get_first(TAB_ITER<T> & iter) const
+	T get_first(TabIter<T> & iter) const
 	{ return BASE_TY::get_first(iter, NULL); }
 
-	T get_next(TAB_ITER<T> & iter) const
+	T get_next(TabIter<T> & iter) const
 	{ return BASE_TY::get_next(iter, NULL); }
 };
-//END TTAB
+//END TTab
 
 
 /*
 Unidirectional Hashed Map
 
 Usage: Make a mapping from OPND to OPER.
-	typedef HMAP<OPND*, OPER*, HASH_FUNC_BASE<OPND*> > OPND2OPER_MAP;
+	typedef HMap<OPND*, OPER*, HashFuncBase<OPND*> > OPND2OPER_MAP;
 
 NOTICE:
-	1. Tsrc(0) is defined as default NULL in HMAP, so do not use T(0) as element.
-	2. The map is implemented base on SHASH, and one hash function class
+	1. Tsrc(0) is defined as default NULL in HMap, so do not use T(0) as element.
+	2. The map is implemented base on SHash, and one hash function class
 	   have been given.
 
 	3. Must use 'new'/'delete' operator to allocate/free the
 	   memory of dynamic object of MAP, because the
 	   virtual-function-pointers-table is needed.
 */
-template <class Tsrc, class Ttgt, class HF = HASH_FUNC_BASE<Tsrc> >
-class HMAP : public SHASH<Tsrc, HF> {
+template <class Tsrc, class Ttgt, class HF = HashFuncBase<Tsrc> >
+class HMap : public SHash<Tsrc, HF> {
 protected:
-	SVECTOR<Ttgt> m_mapped_elem_table;
+	Vector<Ttgt> m_mapped_elem_table;
 
 	//Find hash container
 	HC<Tsrc> * findhc(Tsrc t) const
 	{
 		if (t == Tsrc(0)) { return NULL; }
-		UINT hashv = SHASH<Tsrc, HF>::m_hf.get_hash_value(t,
-								SHASH<Tsrc, HF>::m_bucket_size);
-		IS_TRUE((hashv < SHASH<Tsrc, HF>::m_bucket_size),
+		UINT hashv = SHash<Tsrc, HF>::m_hf.get_hash_value(t,
+								SHash<Tsrc, HF>::m_bucket_size);
+		IS_TRUE((hashv < SHash<Tsrc, HF>::m_bucket_size),
 				("hash value must less than bucket size"));
 		HC<Tsrc> * elemhc =
-			(HC<Tsrc>*)SHB_member((SHASH<Tsrc, HF>::m_bucket[hashv]));
+			(HC<Tsrc>*)SHB_member((SHash<Tsrc, HF>::m_bucket[hashv]));
 		if (elemhc != NULL) {
 			while (elemhc != NULL) {
 				IS_TRUE(HC_val(elemhc) != Tsrc(0),
 						("Hash element has so far as to be overrided!"));
-				if (SHASH<Tsrc, HF>::m_hf.compare(HC_val(elemhc), t)) {
+				if (SHash<Tsrc, HF>::m_hf.compare(HC_val(elemhc), t)) {
 					return elemhc;
 				}
 				elemhc = HC_next(elemhc);
@@ -4230,28 +4247,28 @@ protected:
 		return NULL;
 	}
 public:
-	HMAP(UINT bsize = MAX_SHASH_BUCKET) : SHASH<Tsrc, HF>(bsize)
+	HMap(UINT bsize = MAX_SHASH_BUCKET) : SHash<Tsrc, HF>(bsize)
 	{ m_mapped_elem_table.init(); }
-	COPY_CONSTRUCTOR(HMAP);
-	virtual ~HMAP() { destroy(); }
+	COPY_CONSTRUCTOR(HMap);
+	virtual ~HMap() { destroy(); }
 
 	//Alway set new mapping even if it has done.
 	void aset(Tsrc t, Ttgt mapped)
 	{
-		IS_TRUE((SHASH<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
+		IS_TRUE((SHash<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
 		if (t == Tsrc(0)) { return; }
 		HC<Tsrc> * elemhc = NULL;
-		SHASH<Tsrc, HF>::append(t, &elemhc, NULL);
+		SHash<Tsrc, HF>::append(t, &elemhc, NULL);
 		IS_TRUE(elemhc != NULL, ("Element does not append into hash table."));
 		m_mapped_elem_table.set(HC_vec_idx(elemhc), mapped);
 	}
 
-	SMEM_POOL * get_pool() { return SHASH<Tsrc, HF>::get_free_list_pool(); }
+	SMemPool * get_pool() { return SHash<Tsrc, HF>::get_free_list_pool(); }
 
 	//Get mapped pointer of 't'
 	Ttgt get(Tsrc t, bool * find = NULL)
 	{
-		IS_TRUE((SHASH<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
+		IS_TRUE((SHash<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
 		HC<Tsrc> * elemhc = findhc(t);
 		if (elemhc != NULL) {
 			if (find != NULL) { *find = true; }
@@ -4264,7 +4281,7 @@ public:
 	//Get mapped object of 't', this function is readonly.
 	Ttgt get_c(Tsrc t, bool * find = NULL) const
 	{
-		IS_TRUE((SHASH<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
+		IS_TRUE((SHash<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
 		HC<Tsrc> * elemhc = findhc(t);
 		if (elemhc != NULL) {
 			if (find != NULL) { *find = true; }
@@ -4274,32 +4291,32 @@ public:
 		return Ttgt(0);
 	}
 
-	SVECTOR<Ttgt> * get_tgt_elem_vec() { return &m_mapped_elem_table; }
+	Vector<Ttgt> * get_tgt_elem_vec() { return &m_mapped_elem_table; }
 
 	void clean()
 	{
-		IS_TRUE((SHASH<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
-		SHASH<Tsrc, HF>::clean();
+		IS_TRUE((SHash<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
+		SHash<Tsrc, HF>::clean();
 		m_mapped_elem_table.clean();
 	}
 
 	UINT count_mem() const
 	{
 		UINT count = m_mapped_elem_table.count_mem();
-		count += ((SHASH<Tsrc, HF>*)this)->count_mem();
+		count += ((SHash<Tsrc, HF>*)this)->count_mem();
 		return count;
 	}
 
 	void init(UINT bsize = MAX_SHASH_BUCKET)
 	{
 		//Only do initialization while m_bucket is NULL.
-		SHASH<Tsrc, HF>::init(bsize);
+		SHash<Tsrc, HF>::init(bsize);
 		m_mapped_elem_table.init();
 	}
 
 	void destroy()
 	{
-		SHASH<Tsrc, HF>::destroy();
+		SHash<Tsrc, HF>::destroy();
 		m_mapped_elem_table.destroy();
 	}
 
@@ -4340,11 +4357,11 @@ public:
 	//Establishing mapping in between 't' and 'mapped'.
 	void set(Tsrc t, Ttgt mapped)
 	{
-		IS_TRUE((SHASH<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
+		IS_TRUE((SHash<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
 		if (t == Tsrc(0)) { return; }
 
 		HC<Tsrc> * elemhc = NULL;
-		SHASH<Tsrc, HF>::append(t, &elemhc, NULL);
+		SHash<Tsrc, HF>::append(t, &elemhc, NULL);
 
 		IS_TRUE(elemhc != NULL,
 				("Element does not append into hash table yet."));
@@ -4355,11 +4372,11 @@ public:
 
 	void setv(OBJTY v, Ttgt mapped)
 	{
-		IS_TRUE((SHASH<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
+		IS_TRUE((SHash<Tsrc, HF>::m_bucket != NULL), ("not yet initialize."));
 		if (v == 0) { return; }
 
 		HC<Tsrc> * elemhc = NULL;
-		SHASH<Tsrc, HF>::append(v, &elemhc, NULL);
+		SHash<Tsrc, HF>::append(v, &elemhc, NULL);
 		IS_TRUE(elemhc != NULL,
 				("Element does not append into hash table yet."));
 		IS_TRUE(Ttgt(0) == m_mapped_elem_table.get(HC_vec_idx(elemhc)),
@@ -4374,33 +4391,33 @@ public:
 /*
 Dual directional Map
 
-MAP_Tsrc2Ttgt: class derive from HMAP<Tsrc, Ttgt>
-MAP_Ttgt2Tsrc: class derive from HMAP<Ttgt, Tsrc>
+MAP_Tsrc2Ttgt: class derive from HMap<Tsrc, Ttgt>
+MAP_Ttgt2Tsrc: class derive from HMap<Ttgt, Tsrc>
 
 Usage: Mapping OPND to corresponding OPER.
-	class MAP1 : public HMAP<OPND*, OPER*> {
+	class MAP1 : public HMap<OPND*, OPER*> {
 	public:
 	};
 
-	class MAP2 : public HMAP<OPER*, OPND*>{
+	class MAP2 : public HMap<OPER*, OPND*>{
 	public:
 	};
 
-	DMAP<OPND*, OPER*, MAP1, MAP2> opnd2oper_dmap;
+	DMap<OPND*, OPER*, MAP1, MAP2> opnd2oper_dmap;
 
 NOTICE:
-	1. Tsrc(0) is defined as default NULL in DMAP, so do not use T(0) as element.
-	2. DMAP Object's memory can be allocated by malloc() dynamically.
+	1. Tsrc(0) is defined as default NULL in DMap, so do not use T(0) as element.
+	2. DMap Object's memory can be allocated by malloc() dynamically.
 */
 template <class Tsrc, class Ttgt, class MAP_Tsrc2Ttgt, class MAP_Ttgt2Tsrc>
-class DMAP {
+class DMap {
 protected:
 	MAP_Tsrc2Ttgt m_src2tgt_map;
 	MAP_Ttgt2Tsrc m_tgt2src_map;
 public:
-	DMAP() {}
-	COPY_CONSTRUCTOR(DMAP);
-	~DMAP() {}
+	DMap() {}
+	COPY_CONSTRUCTOR(DMap);
+	~DMap() {}
 
 	//Alway overlap the old value by new 'mapped' value.
 	void aset(Tsrc t, Ttgt mapped)
@@ -4433,7 +4450,7 @@ public:
 	Tsrc geti(Ttgt t)
 	{ return m_tgt2src_map.get(t); }
 };
-//END DMAP
+//END DMap
 
 
 
@@ -4442,32 +4459,32 @@ Multiple Target Map
 Map src with type Tsrc to many tgt elements with type Ttgt.
 
 'TAB_Ttgt': records tgt elements.
-	e.g: We implement TAB_Ttgt via deriving from SHASH.
+	e.g: We implement TAB_Ttgt via deriving from SHash.
 
-	class TAB_Ttgt: public SHASH<Ttgt, HASH_FUNC_BASE<Ttgt> > {
+	class TAB_Ttgt: public SHash<Ttgt, HashFuncBase<Ttgt> > {
 	public:
 	};
 
-	or deriving from LIST, typedef LIST<Ttgt> TAB_Ttgt;
+	or deriving from List, typedef List<Ttgt> TAB_Ttgt;
 
 NOTICE:
-	1. Tsrc(0) is defined as default NULL in MMAP, do not use T(0) as element.
+	1. Tsrc(0) is defined as default NULL in MMap, do not use T(0) as element.
 
-	2. MMAP allocate memory for 'TAB_Ttgt' and return 'TAB_Ttgt *'
+	2. MMap allocate memory for 'TAB_Ttgt' and return 'TAB_Ttgt *'
 		when get(Tsrc) be invoked. DO NOT free these objects yourself.
 
 	3. TAB_Ttgt should be pointer type.
 		e.g: Given type of tgt's table is a class that
-			OP_HASH : public SHASH<OPER*>,
-			then type MMAP<OPND*, OPER*, OP_HASH> is ok, but
-			type MMAP<OPND*, OPER*, OP_HASH*> is not expected.
+			OP_HASH : public SHash<OPER*>,
+			then type MMap<OPND*, OPER*, OP_HASH> is ok, but
+			type MMap<OPND*, OPER*, OP_HASH*> is not expected.
 
-	4. Do not use DMAP directly, please overload following functions optionally:
+	4. Do not use DMap directly, please overload following functions optionally:
 		* create hash-element container.
 			T * create(OBJTY v)
 
 		e.g: Mapping one OPND to a number of OPERs.
-			class OPND2OPER_MMAP : public MMAP<OPND*, OPER*, OP_TAB> {
+			class OPND2OPER_MMAP : public MMap<OPND*, OPER*, OP_TAB> {
 			public:
 				virtual T create(OBJTY id)
 				{
@@ -4477,26 +4494,26 @@ NOTICE:
 			};
 
 	4. Please use 'new'/'delete' operator to allocate/free
-	   the memory of dynamic object of MMAP, because the
+	   the memory of dynamic object of MMap, because the
 	   virtual-function-pointers-table is needed.
 */
 template <class Tsrc, class Ttgt, class TAB_Ttgt,
-		  class HF = HASH_FUNC_BASE<Tsrc> >
-class MMAP : public HMAP<Tsrc, TAB_Ttgt*, HF> {
+		  class HF = HashFuncBase<Tsrc> >
+class MMap : public HMap<Tsrc, TAB_Ttgt*, HF> {
 protected:
 	bool m_is_init;
 public:
-	MMAP()
+	MMap()
 	{
 		m_is_init = false;
 		init();
 	}
-	COPY_CONSTRUCTOR(MMAP);
-	virtual ~MMAP() { destroy(); }
+	COPY_CONSTRUCTOR(MMap);
+	virtual ~MMap() { destroy(); }
 
 	UINT count_mem() const
 	{
-		return ((HMAP<Tsrc, TAB_Ttgt*, HF>*)this)->count_mem() +
+		return ((HMap<Tsrc, TAB_Ttgt*, HF>*)this)->count_mem() +
 			   sizeof(m_is_init);
 	}
 
@@ -4504,41 +4521,41 @@ public:
 	void set(Tsrc t, Ttgt mapped)
 	{
 		if (t == Tsrc(0)) return;
-		TAB_Ttgt * tgttab = HMAP<Tsrc, TAB_Ttgt*, HF>::get(t);
+		TAB_Ttgt * tgttab = HMap<Tsrc, TAB_Ttgt*, HF>::get(t);
 		if (tgttab == NULL) {
-			//Do NOT use SHASH::xmalloc(sizeof(TAB_Ttgt)) to allocate memory,
+			//Do NOT use SHash::xmalloc(sizeof(TAB_Ttgt)) to allocate memory,
 			//because __vfptr is NULL. __vfptr points to TAB_Ttgt::vftable.
 			tgttab = new TAB_Ttgt;
-			HMAP<Tsrc, TAB_Ttgt*, HF>::set(t, tgttab);
+			HMap<Tsrc, TAB_Ttgt*, HF>::set(t, tgttab);
 		}
 		tgttab->append_node(mapped);
 	}
 
 	//Get mapped elements of 't'
 	TAB_Ttgt * get(Tsrc t)
-	{ return HMAP<Tsrc, TAB_Ttgt*, HF>::get(t); }
+	{ return HMap<Tsrc, TAB_Ttgt*, HF>::get(t); }
 
 	void init()
 	{
 		if (m_is_init) { return; }
-		HMAP<Tsrc, TAB_Ttgt*, HF>::init();
+		HMap<Tsrc, TAB_Ttgt*, HF>::init();
 		m_is_init = true;
 	}
 
 	void destroy()
 	{
 		if (!m_is_init) { return; }
-		TAB_Ttgt * tgttab = get(HMAP<Tsrc, TAB_Ttgt*, HF>::get_first());
-		UINT n = HMAP<Tsrc, TAB_Ttgt*, HF>::get_elem_count();
+		TAB_Ttgt * tgttab = get(HMap<Tsrc, TAB_Ttgt*, HF>::get_first());
+		UINT n = HMap<Tsrc, TAB_Ttgt*, HF>::get_elem_count();
 		for (UINT i = 0; i < n; i++) {
 			IS_TRUE0(tgttab);
 			delete tgttab;
-			tgttab = HMAP<Tsrc, TAB_Ttgt*, HF>::
-							get(HMAP<Tsrc, TAB_Ttgt*, HF>::get_next());
+			tgttab = HMap<Tsrc, TAB_Ttgt*, HF>::
+							get(HMap<Tsrc, TAB_Ttgt*, HF>::get_next());
 		}
 
-		HMAP<Tsrc, TAB_Ttgt*, HF>::destroy();
+		HMap<Tsrc, TAB_Ttgt*, HF>::destroy();
 		m_is_init = false;
 	}
 };
-#endif
\ No newline at end of file
+#endif
diff --git a/src/util/label.cpp b/src/util/label.cpp
index 7ea04f3..758680b 100644
--- a/src/util/label.cpp
+++ b/src/util/label.cpp
@@ -6,33 +6,33 @@
 #include "symtab.h"
 #include "label.h"
 
-LABEL_INFO * new_clabel(SYM * st, SMEM_POOL * pool)
+LabelInfo * newCustomerLabel(SYM * st, SMemPool * pool)
 {
-	LABEL_INFO * li = new_label(pool);
+	LabelInfo * li = newLabel(pool);
 	LABEL_INFO_name(li) = st;
 	LABEL_INFO_type(li) = L_CLABEL;
 	return li;
 }
 
 
-LABEL_INFO * new_ilabel(SMEM_POOL * pool)
+LabelInfo * newInternalLabel(SMemPool * pool)
 {
-	LABEL_INFO * n = new_label(pool);
+	LabelInfo * n = newLabel(pool);
 	LABEL_INFO_type(n) = L_ILABEL;
 	return n;
 }
 
 
-LABEL_INFO * new_label(SMEM_POOL * pool)
+LabelInfo * newLabel(SMemPool * pool)
 {
-	LABEL_INFO * p = (LABEL_INFO*)smpool_malloc_h(sizeof(LABEL_INFO), pool);
+	LabelInfo * p = (LabelInfo*)smpoolMalloc(sizeof(LabelInfo), pool);
 	IS_TRUE0(p);
-	memset(p, 0, sizeof(LABEL_INFO));
+	memset(p, 0, sizeof(LabelInfo));
 	return p;
 }
 
 
-void dump_lab(LABEL_INFO const* li)
+void dumpLabel(LabelInfo const* li)
 {
 	if (g_tfile == NULL) return;
 	if (LABEL_INFO_type(li) == L_ILABEL) {
diff --git a/src/util/label.h b/src/util/label.h
index 5d5ee69..78c85b7 100644
--- a/src/util/label.h
+++ b/src/util/label.h
@@ -33,7 +33,7 @@ typedef enum {
 #define LABEL_INFO_is_unreachable(l)	((l)->u2.s1.is_unreachable)
 #define LABEL_INFO_is_pragma(l)			(LABEL_INFO_type(l) == L_PRAGMA)
 #define LABEL_INFO_b1(l)				((l)->u2.b1)
-class LABEL_INFO {
+class LabelInfo {
 public:
 	LABEL_TYPE ltype;
 	
@@ -66,7 +66,8 @@ public:
 		BYTE b1;
 	} u2;
 
-	void copy(LABEL_INFO const& li)
+public:
+	void copy(LabelInfo const& li)
 	{
 		ltype = li.ltype;
 		u1.lab_name = li.u1.lab_name;
@@ -77,7 +78,7 @@ public:
 
 //Exported Functions
 //Simplest method to compute hash value.
-inline UINT lab_hash_value(LABEL_INFO const* li)
+inline UINT computeLabelHashValue(LabelInfo const* li)
 {
 	INT v = 0;
 	if (LABEL_INFO_type(li) == L_CLABEL) {
@@ -95,10 +96,10 @@ inline UINT lab_hash_value(LABEL_INFO const* li)
 }
 
 
-LABEL_INFO * new_label(SMEM_POOL * pool);
-LABEL_INFO * new_ilabel(SMEM_POOL * pool);
-LABEL_INFO * new_clabel(SYM * st, SMEM_POOL * pool);
-inline bool is_same_label(LABEL_INFO const* li1, LABEL_INFO const* li2)
+LabelInfo * newLabel(SMemPool * pool);
+LabelInfo * newInternalLabel(SMemPool * pool);
+LabelInfo * newCustomerLabel(SYM * st, SMemPool * pool);
+inline bool isSameLabel(LabelInfo const* li1, LabelInfo const* li2)
 {
 	IS_TRUE0(li1 && li2);
 	if (li1 == li2) { return true; }
@@ -108,25 +109,25 @@ inline bool is_same_label(LABEL_INFO const* li1, LABEL_INFO const* li2)
 	}
 	return false;
 }
-void dump_lab(LABEL_INFO const* li);
+void dumpLabel(LabelInfo const* li);
 
 
-class LAB_HF : public HASH_FUNC_BASE<LABEL_INFO*> {
+class LabelHashFunc : public HashFuncBase<LabelInfo*> {
 public:
-	UINT get_hash_value(LABEL_INFO * li, UINT bucket_size) const
-	{ return ((UINT)lab_hash_value(li)) % bucket_size; }
+	UINT get_hash_value(LabelInfo * li, UINT bucket_size) const
+	{ return ((UINT)computeLabelHashValue(li)) % bucket_size; }
 
-	bool compare(LABEL_INFO * li1, LABEL_INFO * li2) const
-	{ return is_same_label(li1, li2); }
+	bool compare(LabelInfo * li1, LabelInfo * li2) const
+	{ return isSameLabel(li1, li2); }
 };
 
 
-class CLAB_HF : public HASH_FUNC_BASE<LABEL_INFO const*> {
+class CustomerLabelHashFunc : public HashFuncBase<LabelInfo const*> {
 public:
-	UINT get_hash_value(LABEL_INFO const* li, UINT bucket_size) const
-	{ return ((UINT)lab_hash_value(li)) % bucket_size; }
+	UINT get_hash_value(LabelInfo const* li, UINT bucket_size) const
+	{ return ((UINT)computeLabelHashValue(li)) % bucket_size; }
 
-	bool compare(LABEL_INFO const* li1, LABEL_INFO const* li2) const
-	{ return is_same_label(li1, li2); }
+	bool compare(LabelInfo const* li1, LabelInfo const* li2) const
+	{ return isSameLabel(li1, li2); }
 };
 #endif
\ No newline at end of file
diff --git a/src/util/symtab.h b/src/util/symtab.h
index 418aacd..9c4fc16 100644
--- a/src/util/symtab.h
+++ b/src/util/symtab.h
@@ -12,9 +12,9 @@ public:
 };
 
 
-class CSYM_HASH_FUNC {
+class ConstSymbolHashFunc {
 public:
-	UINT compute_char_sum(CHAR const* s) const
+	UINT computeCharSum(CHAR const* s) const
 	{
 		UINT v = 0 ;
 		UINT cnt = 0;
@@ -28,7 +28,7 @@ public:
 	UINT get_hash_value(SYM const* s, UINT bs) const
 	{
 		IS_TRUE0(is_power_of_2(bs));
-		UINT v = compute_char_sum(SYM_name(s));
+		UINT v = computeCharSum(SYM_name(s));
 		return hash32bit(v) & (bs - 1);
 	}
 
@@ -38,7 +38,7 @@ public:
 		IS_TRUE(sizeof(OBJTY) == sizeof(CHAR const*),
 				("exception will taken place in type-cast"));
 		IS_TRUE0(is_power_of_2(bs));
-		UINT n = compute_char_sum((CHAR const*)v);
+		UINT n = computeCharSum((CHAR const*)v);
 		return hash32bit(n) & (bs - 1);
 	}
 
@@ -54,9 +54,9 @@ public:
 };
 
 
-class SYM_HASH_FUNC {
+class SymbolHashFunc {
 public:
-	UINT compute_char_sum(CHAR const* s) const
+	UINT computeCharSum(CHAR const* s) const
 	{
 		UINT v = 0;
 		UINT cnt = 0;
@@ -70,7 +70,7 @@ public:
 	UINT get_hash_value(SYM * s, UINT bs) const
 	{
 		IS_TRUE0(is_power_of_2(bs));
-		UINT v = compute_char_sum(SYM_name(s));
+		UINT v = computeCharSum(SYM_name(s));
 		return hash32bit(v) & (bs - 1);
 	}
 
@@ -80,7 +80,7 @@ public:
 		IS_TRUE(sizeof(OBJTY) == sizeof(CHAR*),
 				("exception will taken place in type-cast"));
 		IS_TRUE0(is_power_of_2(bs));
-		UINT n = compute_char_sum((CHAR*)v);
+		UINT n = computeCharSum((CHAR*)v);
 		return hash32bit(n) & (bs - 1);
 	}
 
@@ -96,13 +96,13 @@ public:
 };
 
 
-class SYM_TAB : public SHASH<SYM*, SYM_HASH_FUNC> {
-	SMEM_POOL * m_pool;
+class SymTab : public SHash<SYM*, SymbolHashFunc> {
+	SMemPool * m_pool;
 public:
-	explicit SYM_TAB(UINT bsize) : SHASH<SYM*, SYM_HASH_FUNC>(bsize)
-	{ m_pool = smpool_create_handle(64, MEM_COMM); }
-	virtual ~SYM_TAB()
-	{ smpool_free_handle(m_pool); }
+	explicit SymTab(UINT bsize) : SHash<SYM*, SymbolHashFunc>(bsize)
+	{ m_pool = smpoolCreate(64, MEM_COMM); }
+	virtual ~SymTab()
+	{ smpoolDelete(m_pool); }
 
 	inline CHAR * strdup(CHAR const* s)
 	{
@@ -110,7 +110,7 @@ public:
 			return NULL;
 		}
 		UINT l = strlen(s);
-		CHAR * ns = (CHAR*)smpool_malloc_h(l + 1, m_pool);
+		CHAR * ns = (CHAR*)smpoolMalloc(l + 1, m_pool);
 		memcpy(ns, s, l);
 		ns[l] = 0;
 		return ns;
@@ -118,21 +118,21 @@ public:
 
 	SYM * create(OBJTY v)
 	{
-		SYM * sym = (SYM*)smpool_malloc_h(sizeof(SYM), m_pool);
+		SYM * sym = (SYM*)smpoolMalloc(sizeof(SYM), m_pool);
 		SYM_name(sym) = strdup((CHAR const*)v);
 		return sym;
 	}
 
 	inline SYM * add(CHAR const* s)
 	{
-		UINT sz = SHASH<SYM*, SYM_HASH_FUNC>::get_bucket_size() * 4;
-		if (sz < SHASH<SYM*, SYM_HASH_FUNC>::get_elem_count()) {
-			SHASH<SYM*, SYM_HASH_FUNC>::grow(sz);
+		UINT sz = SHash<SYM*, SymbolHashFunc>::get_bucket_size() * 4;
+		if (sz < SHash<SYM*, SymbolHashFunc>::get_elem_count()) {
+			SHash<SYM*, SymbolHashFunc>::grow(sz);
 		}
-		return SHASH<SYM*, SYM_HASH_FUNC>::append((OBJTY)s); 
+		return SHash<SYM*, SymbolHashFunc>::append((OBJTY)s); 
 	}
 
 	inline SYM * get(CHAR const* s)
-	{ return SHASH<SYM*, SYM_HASH_FUNC>::find((OBJTY)s); }
+	{ return SHash<SYM*, SymbolHashFunc>::find((OBJTY)s); }
 };
 #endif
\ No newline at end of file
diff --git a/src/util/util.cpp b/src/util/util.cpp
index db79740..46e6922 100644
--- a/src/util/util.cpp
+++ b/src/util/util.cpp
@@ -9,7 +9,7 @@
 
 INT g_indent = 0;
 CHAR * g_indent_chars = (CHAR*)" ";
-SMEM_POOL * g_pool_tmp_used = NULL;
+SMemPool * g_pool_tmp_used = NULL;
 FILE * g_tfile = NULL;
 
 void interwarn(CHAR const* format, ...)
@@ -147,9 +147,9 @@ void * tlloc(LONG size)
 {
 	if (size < 0 || size == 0) return NULL;
 	if (g_pool_tmp_used == NULL) {
-		g_pool_tmp_used = smpool_create_handle(8, MEM_COMM);
+		g_pool_tmp_used = smpoolCreate(8, MEM_COMM);
 	}
-	void * p = smpool_malloc_h(size, g_pool_tmp_used);
+	void * p = smpoolMalloc(size, g_pool_tmp_used);
 	if (p == NULL) return NULL;
 	memset(p, 0, size);
 	return p;
@@ -159,13 +159,13 @@ void * tlloc(LONG size)
 void tfree()
 {
 	if (g_pool_tmp_used != NULL) {
-		smpool_free_handle(g_pool_tmp_used);
+		smpoolDelete(g_pool_tmp_used);
 		g_pool_tmp_used = NULL;
 	}
 }
 
 
-void dump_vec(SVECTOR<UINT> & v)
+void dump_vec(Vector<UINT> & v)
 {
 	if (g_tfile == NULL) return;
 	fprintf(g_tfile, "\n");
@@ -196,7 +196,7 @@ public:
 			return;
 		}
 
-		LIST<TN*> lst;
+		List<TN*> lst;
 		lst.append_tail(x);
 		while (lst.get_elem_count() != 0) {
 			x = lst.remove_head();
@@ -231,7 +231,7 @@ public:
 			return;
 		}
 
-		LIST<TN*> lst;
+		List<TN*> lst;
 		lst.append_tail(x);
 		while (lst.get_elem_count() != 0) {
 			x = lst.remove_head();
diff --git a/src/util/util.h b/src/util/util.h
index ec2b1a2..0a3922d 100644
--- a/src/util/util.h
+++ b/src/util/util.h
@@ -25,7 +25,7 @@ void dump_rbt(RBT<T, Ttgt> & rbt, CHAR const* name = NULL,
 			  UINT nil_count = NIL_START)
 {
 	typedef RBTN<T, Ttgt> TN;
-	SVECTOR<TN*> nilvec;
+	Vector<TN*> nilvec;
 	if (name == NULL) {
 		name = "graph_rbt.vcg";
 	}
@@ -68,7 +68,7 @@ void dump_rbt(RBT<T, Ttgt> & rbt, CHAR const* name = NULL,
 			  "edge.color: darkgreen\n");
 
 	//Print node
-	LIST<TN*> lst;
+	List<TN*> lst;
 	TN const* root = rbt.get_root();
 	if (root != NULL) {
 		lst.append_tail(const_cast<TN*>(root));
@@ -160,7 +160,7 @@ void dump_rbt(RBT<T, Ttgt> & rbt, CHAR const* name = NULL,
 	fclose(hvcg);
 }
 
-void dump_vec(SVECTOR<UINT> & v);
+void dump_vec(Vector<UINT> & v);
 void initdump(CHAR const* f, bool is_del);
 void interwarn(CHAR const* format, ...);
 void finidump();
